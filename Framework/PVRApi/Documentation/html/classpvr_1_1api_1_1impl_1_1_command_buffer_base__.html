<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRApi: pvr::api::impl::CommandBufferBase_ Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRApi</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pvr</b></li><li class="navelem"><b>api</b></li><li class="navelem"><b>impl</b></li><li class="navelem"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html">CommandBufferBase_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::api::impl::CommandBufferBase_ Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. In debug builds (define DEBUG or define PVR_STORE_STACK_TRACE_WITH_API_COMMANDS), a limited stack trace is stored with each command so that if an error occurs, the site where the command was actually added to the command buffer can be determined.  
 <a href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::api::impl::CommandBufferBase_:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1api_1_1impl_1_1_command_buffer_base____inherit__graph.png" border="0" usemap="#pvr_1_1api_1_1impl_1_1_command_buffer_base___inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1api_1_1impl_1_1_command_buffer_base___inherit__map" id="pvr_1_1api_1_1impl_1_1_command_buffer_base___inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline..." alt="" coords="5,104,211,131"/><area shape="rect" id="node3" href="classpvr_1_1api_1_1impl_1_1_secondary_command_buffer__.html" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline..." alt="" coords="235,97,401,138"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a085614fc5885fc5df5ef326e3a3a01ed"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a085614fc5885fc5df5ef326e3a3a01ed">~CommandBufferBase_</a> ()</td></tr>
<tr class="memdesc:a085614fc5885fc5df5ef326e3a3a01ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <a href="#a085614fc5885fc5df5ef326e3a3a01ed">More...</a><br/></td></tr>
<tr class="separator:a085614fc5885fc5df5ef326e3a3a01ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7d358802ca484e7a8be735b09d83fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a7b7d358802ca484e7a8be735b09d83fe">beginSceneHierarchy</a> (const SceneHierarchy &amp;sceneHierarchy, pvr::math::AxisAlignedBox &amp;extents)</td></tr>
<tr class="memdesc:a7b7d358802ca484e7a8be735b09d83fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins the recording of scene hierarchy generation commands.  <a href="#a7b7d358802ca484e7a8be735b09d83fe">More...</a><br/></td></tr>
<tr class="separator:a7b7d358802ca484e7a8be735b09d83fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c074492d6949ed275a8b45b5c169cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a30c074492d6949ed275a8b45b5c169cc">bindAccumulationImages</a> (pvr::uint32 startBinding, pvr::uint32 bindingCount, const TextureView *imageViews)</td></tr>
<tr class="memdesc:a30c074492d6949ed275a8b45b5c169cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a number of accumulation images making accumulation to them possible in subsequent commands which dispatch rays. <a href="#a30c074492d6949ed275a8b45b5c169cc">More...</a><br/></td></tr>
<tr class="separator:a30c074492d6949ed275a8b45b5c169cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08ef00d0041fe5028502f844fed236c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ab08ef00d0041fe5028502f844fed236c">bindDescriptorSet</a> (const api::PipelineLayout &amp;pipelineLayout, uint32 index, const DescriptorSet &amp;set, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffsets=0)</td></tr>
<tr class="memdesc:ab08ef00d0041fe5028502f844fed236c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet to the Graphics Pipeline binding point <a href="#ab08ef00d0041fe5028502f844fed236c">More...</a><br/></td></tr>
<tr class="separator:ab08ef00d0041fe5028502f844fed236c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36453a83eed132b55306f6a1da75ab66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a36453a83eed132b55306f6a1da75ab66">bindDescriptorSetCompute</a> (const api::PipelineLayout &amp;pipelineLayout, uint32 index, const DescriptorSet &amp;set, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffsets=0)</td></tr>
<tr class="memdesc:a36453a83eed132b55306f6a1da75ab66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet to the Compute Pipeline binding point <a href="#a36453a83eed132b55306f6a1da75ab66">More...</a><br/></td></tr>
<tr class="separator:a36453a83eed132b55306f6a1da75ab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e7eeacb4ae57ad3acf0bda43cdc42e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a05e7eeacb4ae57ad3acf0bda43cdc42e">bindDescriptorSetRayTracing</a> (const api::PipelineLayout &amp;pipelineLayout, uint32 index, const DescriptorSet &amp;set, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffsets=0)</td></tr>
<tr class="memdesc:a05e7eeacb4ae57ad3acf0bda43cdc42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet to the Ray Tracing Pipeline binding point <a href="#a05e7eeacb4ae57ad3acf0bda43cdc42e">More...</a><br/></td></tr>
<tr class="separator:a05e7eeacb4ae57ad3acf0bda43cdc42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1f2311a10d6d592809685bb4383c7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a8b1f2311a10d6d592809685bb4383c7d">bindDescriptorSets</a> (types::PipelineBindPoint bindingPoint, const api::PipelineLayout &amp;pipelineLayout, uint32 firstSet, const DescriptorSet *sets, uint32 numDescSets, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffsets=0)</td></tr>
<tr class="memdesc:a8b1f2311a10d6d592809685bb4383c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind multiple DescriptorSets <a href="#a8b1f2311a10d6d592809685bb4383c7d">More...</a><br/></td></tr>
<tr class="separator:a8b1f2311a10d6d592809685bb4383c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4f6de0ca2d21418896d6dff7ff1970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#afa4f6de0ca2d21418896d6dff7ff1970">bindDescriptorSetSHG</a> (const api::PipelineLayout &amp;pipelineLayout, uint32 index, const DescriptorSet &amp;set, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffsets=0)</td></tr>
<tr class="memdesc:afa4f6de0ca2d21418896d6dff7ff1970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet to the Scene Hierarchy Generator Pipeline binding point <a href="#afa4f6de0ca2d21418896d6dff7ff1970">More...</a><br/></td></tr>
<tr class="separator:afa4f6de0ca2d21418896d6dff7ff1970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a42a80f1a60693eff86f37989b0ede0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a0a42a80f1a60693eff86f37989b0ede0">bindIndexBuffer</a> (const <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;buffer, uint32 offset, types::IndexType indexType)</td></tr>
<tr class="memdesc:a0a42a80f1a60693eff86f37989b0ede0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an index buffer for drawing <a href="#a0a42a80f1a60693eff86f37989b0ede0">More...</a><br/></td></tr>
<tr class="separator:a0a42a80f1a60693eff86f37989b0ede0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c52c2e276ce8e0530f1b9367d351be3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3c52c2e276ce8e0530f1b9367d351be3">bindPipeline</a> (GraphicsPipeline pipeline)</td></tr>
<tr class="memdesc:a3c52c2e276ce8e0530f1b9367d351be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a graphics pipeline. <a href="#a3c52c2e276ce8e0530f1b9367d351be3">More...</a><br/></td></tr>
<tr class="separator:a3c52c2e276ce8e0530f1b9367d351be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d2777f4821115ac50b28343329bbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ac6d2777f4821115ac50b28343329bbfa">bindPipeline</a> (ComputePipeline &amp;pipeline)</td></tr>
<tr class="memdesc:ac6d2777f4821115ac50b28343329bbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a compute pipeline <a href="#ac6d2777f4821115ac50b28343329bbfa">More...</a><br/></td></tr>
<tr class="separator:ac6d2777f4821115ac50b28343329bbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf97f03e8d635082f1f2368b9224fe8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adf97f03e8d635082f1f2368b9224fe8f">bindPipeline</a> (SceneTraversalPipeline &amp;pipeline)</td></tr>
<tr class="memdesc:adf97f03e8d635082f1f2368b9224fe8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a Scene Traversal pipeline <a href="#adf97f03e8d635082f1f2368b9224fe8f">More...</a><br/></td></tr>
<tr class="separator:adf97f03e8d635082f1f2368b9224fe8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa652603f8ef0cd1955441c6f2eb116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3aa652603f8ef0cd1955441c6f2eb116">bindPipeline</a> (VertexRayPipeline &amp;pipeline)</td></tr>
<tr class="memdesc:a3aa652603f8ef0cd1955441c6f2eb116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a Vertex Ray pipeline <a href="#a3aa652603f8ef0cd1955441c6f2eb116">More...</a><br/></td></tr>
<tr class="separator:a3aa652603f8ef0cd1955441c6f2eb116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035a1c1722d636da391dd7abda4d9aa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a035a1c1722d636da391dd7abda4d9aa3">bindSceneHierarchies</a> (const SceneHierarchy *sceneHierarchies, pvr::uint32 firstBinding, const pvr::uint32 numberOfSceneHierarchies)</td></tr>
<tr class="memdesc:a035a1c1722d636da391dd7abda4d9aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a number of scene hierarchies making it possible to use them in subsequent dispatches. <a href="#a035a1c1722d636da391dd7abda4d9aa3">More...</a><br/></td></tr>
<tr class="separator:a035a1c1722d636da391dd7abda4d9aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecde8359a87bb2da46c141974a5c6e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aecde8359a87bb2da46c141974a5c6e16">bindVertexBuffer</a> (const <a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer, uint32 offset, uint16 bindingIndex)</td></tr>
<tr class="memdesc:aecde8359a87bb2da46c141974a5c6e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> for drawing <a href="#aecde8359a87bb2da46c141974a5c6e16">More...</a><br/></td></tr>
<tr class="separator:aecde8359a87bb2da46c141974a5c6e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b052b600d0111a278a203ebb3701c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a71b052b600d0111a278a203ebb3701c8">bindVertexBuffer</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> const *buffers, uint32 *offsets, uint16 numBuffers, uint16 startBinding, uint16 bindingCount)</td></tr>
<tr class="memdesc:a71b052b600d0111a278a203ebb3701c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an array of Vertex Buffers <a href="#a71b052b600d0111a278a203ebb3701c8">More...</a><br/></td></tr>
<tr class="separator:a71b052b600d0111a278a203ebb3701c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16249a7acca496e5604269badc31046d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a16249a7acca496e5604269badc31046d">blitImage</a> (api::TextureStore &amp;src, api::TextureStore &amp;dest, types::ImageLayout srcLayout, types::ImageLayout dstLayout, types::ImageBlitRange *regions, uint32 numRegions, types::SamplerFilter filter)</td></tr>
<tr class="memdesc:a16249a7acca496e5604269badc31046d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blit Image <a href="#a16249a7acca496e5604269badc31046d">More...</a><br/></td></tr>
<tr class="separator:a16249a7acca496e5604269badc31046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2535755a017951dd67eb6df7569e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a7f2535755a017951dd67eb6df7569e78">clear</a> (bool releaseAllResources=false)</td></tr>
<tr class="memdesc:a7f2535755a017951dd67eb6df7569e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the command queue. It is invalid to clear the command buffer while it is being recorded.  <a href="#a7f2535755a017951dd67eb6df7569e78">More...</a><br/></td></tr>
<tr class="separator:a7f2535755a017951dd67eb6df7569e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efc4189a71a18db50301e1e26b7b504"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a9efc4189a71a18db50301e1e26b7b504">clearColorAttachment</a> (uint32 const *attachmentIndices, glm::vec4 const *clearColors, uint32 attachmentCount, const Rectanglei *rects, const uint32 *baseArrayLayers, const uint32 *layerCounts, uint32 rectCount)</td></tr>
<tr class="memdesc:a9efc4189a71a18db50301e1e26b7b504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear multiple attachments with separate clear colors and clear rectangle for each. NOTE: This clear operation must be called inside the render pass <a href="#a9efc4189a71a18db50301e1e26b7b504">More...</a><br/></td></tr>
<tr class="separator:a9efc4189a71a18db50301e1e26b7b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145b815bfacb166db9d9b1e2294a0053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a145b815bfacb166db9d9b1e2294a0053">clearColorAttachment</a> (uint32 attachmentIndex, glm::vec4 clearColor, const Rectanglei rect, const uint32 baseArrayLayer=0u, const uint32 layerCount=1u)</td></tr>
<tr class="memdesc:a145b815bfacb166db9d9b1e2294a0053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color attachment. NOTE: This clear operation must be called inside the render pass <a href="#a145b815bfacb166db9d9b1e2294a0053">More...</a><br/></td></tr>
<tr class="separator:a145b815bfacb166db9d9b1e2294a0053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17338a8346b0a574532e6a7b5bab9400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a17338a8346b0a574532e6a7b5bab9400">clearColorAttachment</a> (api::Fbo fbo, glm::vec4 clearColor)</td></tr>
<tr class="memdesc:a17338a8346b0a574532e6a7b5bab9400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all attachment for a single fbo with a single clear color. NOTE: This clear operation must be called inside the render pass <a href="#a17338a8346b0a574532e6a7b5bab9400">More...</a><br/></td></tr>
<tr class="separator:a17338a8346b0a574532e6a7b5bab9400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a4fc7aec52d357cc5b45f57d146418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a82a4fc7aec52d357cc5b45f57d146418">clearColorImage</a> (api::TextureView &amp;image, glm::vec4 clearColor, const uint32 baseMipLevel=0u, const uint32 levelCount=1u, const uint32 baseArrayLayer=0u, const uint32 layerCount=1u, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:a82a4fc7aec52d357cc5b45f57d146418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified color image using the clear color specified. NOTE: This clear operation must be called outside the render pass <a href="#a82a4fc7aec52d357cc5b45f57d146418">More...</a><br/></td></tr>
<tr class="separator:a82a4fc7aec52d357cc5b45f57d146418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c882100d42cc4b9cdc83c6d73fa3e3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3c882100d42cc4b9cdc83c6d73fa3e3d">clearColorImage</a> (api::TextureView &amp;image, glm::vec4 clearColor, const uint32 *baseMipLevel, const uint32 *levelCount, const uint32 *baseArrayLayers, const uint32 *layerCount, uint32 rangeCount, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:a3c882100d42cc4b9cdc83c6d73fa3e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears rangeCount sub resource ranges of the specified color image using the clear color specified. NOTE: This clear operation must be called outside the render pass <a href="#a3c882100d42cc4b9cdc83c6d73fa3e3d">More...</a><br/></td></tr>
<tr class="separator:a3c882100d42cc4b9cdc83c6d73fa3e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ba43f43ffa0b49b9f6bf2321d3d1c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa0ba43f43ffa0b49b9f6bf2321d3d1c4">clearDepthAttachment</a> (const Rectanglei &amp;clearRect, float32 depth=1.f)</td></tr>
<tr class="memdesc:aa0ba43f43ffa0b49b9f6bf2321d3d1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the depth attachment of an fbo. NOTE: This clear operation must be called inside the render pass  <a href="#aa0ba43f43ffa0b49b9f6bf2321d3d1c4">More...</a><br/></td></tr>
<tr class="separator:aa0ba43f43ffa0b49b9f6bf2321d3d1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34af62437abb4ec58407b0cdf66e236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ac34af62437abb4ec58407b0cdf66e236">clearDepthImage</a> (api::TextureView &amp;image, float clearDepth, const uint32 baseMipLevel=0u, const uint32 levelCount=1u, const uint32 baseArrayLayer=0u, const uint32 layerCount=1u, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:ac34af62437abb4ec58407b0cdf66e236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified depth image using the clear depth color specified. NOTE: This clear operation must be called outside the render pass <a href="#ac34af62437abb4ec58407b0cdf66e236">More...</a><br/></td></tr>
<tr class="separator:ac34af62437abb4ec58407b0cdf66e236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94096a45591eed976e3c189e4fa16c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#af94096a45591eed976e3c189e4fa16c8">clearDepthImage</a> (api::TextureView &amp;image, float clearDepth, const uint32 *baseMipLevel, const uint32 *levelCount, const uint32 *baseArrayLayers, const uint32 *layerCount, uint32 rangeCount, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:af94096a45591eed976e3c189e4fa16c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears rangeCount sub resource ranges of the specified depth image using the clear depth color specified. NOTE This clear operation must be called outside the render pass <a href="#af94096a45591eed976e3c189e4fa16c8">More...</a><br/></td></tr>
<tr class="separator:af94096a45591eed976e3c189e4fa16c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4cab34eba3d7df92ada9bf8ab2e5df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a6a4cab34eba3d7df92ada9bf8ab2e5df">clearDepthStencilAttachment</a> (const Rectanglei &amp;clearRect, float32 depth=1.f, int32 stencil=0)</td></tr>
<tr class="memdesc:a6a4cab34eba3d7df92ada9bf8ab2e5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the depth stencil attachment <a href="#a6a4cab34eba3d7df92ada9bf8ab2e5df">More...</a><br/></td></tr>
<tr class="separator:a6a4cab34eba3d7df92ada9bf8ab2e5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c27570a5619317f93d8dde85c1dad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ae2c27570a5619317f93d8dde85c1dad5">clearDepthStencilImage</a> (api::TextureView &amp;image, float clearDepth, uint32 clearStencil, const uint32 baseMipLevel=0u, const uint32 levelCount=1u, const uint32 baseArrayLayers=0u, const uint32 layerCount=1u, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:ae2c27570a5619317f93d8dde85c1dad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified depth stencil image using the clear depth and stencil color specified. NOTE: This clear operation must be called outside the render pass <a href="#ae2c27570a5619317f93d8dde85c1dad5">More...</a><br/></td></tr>
<tr class="separator:ae2c27570a5619317f93d8dde85c1dad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840fc7fdea26889bab025876e876a6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a840fc7fdea26889bab025876e876a6b2">clearDepthStencilImage</a> (api::TextureView &amp;image, float clearDepth, uint32 clearStencil, const uint32 *baseMipLevel, const uint32 *levelCount, const uint32 *baseArrayLayers, const uint32 *layerCount, uint32 rangeCount, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:a840fc7fdea26889bab025876e876a6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears rangeCount sub resource ranges of the specified depth stencil image using the clear depth and stencil color specified. NOTE: This clear operation must be called outside the render pass <a href="#a840fc7fdea26889bab025876e876a6b2">More...</a><br/></td></tr>
<tr class="separator:a840fc7fdea26889bab025876e876a6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ada2b65ca439623e7a48a68d1291dce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a4ada2b65ca439623e7a48a68d1291dce">clearStencilAttachment</a> (const Rectanglei &amp;clearRect, int32 stencil=0)</td></tr>
<tr class="memdesc:a4ada2b65ca439623e7a48a68d1291dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stencil attachment of an fbo. NOTE: This clear operation must be called inside the render pass <a href="#a4ada2b65ca439623e7a48a68d1291dce">More...</a><br/></td></tr>
<tr class="separator:a4ada2b65ca439623e7a48a68d1291dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c67e5c58a68ec6753b55aaa6fd757d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a59c67e5c58a68ec6753b55aaa6fd757d">clearStencilImage</a> (api::TextureView &amp;image, uint32 clearStencil, const uint32 baseMipLevel=0u, const uint32 levelCount=1u, const uint32 baseArrayLayers=0u, const uint32 layerCount=1u, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:a59c67e5c58a68ec6753b55aaa6fd757d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified stencil image using the clear stencil color specified. NOTE This clear operation must be called outside the render pass <a href="#a59c67e5c58a68ec6753b55aaa6fd757d">More...</a><br/></td></tr>
<tr class="separator:a59c67e5c58a68ec6753b55aaa6fd757d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c80f839ba5eff8143dc8b284aaa9557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a7c80f839ba5eff8143dc8b284aaa9557">clearStencilImage</a> (api::TextureView &amp;image, uint32 clearStencil, const uint32 *baseMipLevel, const uint32 *levelCount, const uint32 *baseArrayLayers, const uint32 *layerCount, uint32 rangeCount, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:a7c80f839ba5eff8143dc8b284aaa9557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears rangeCount sub resource ranges of the specified stencil image using the clear stencil color specified. NOTE: This clear operation must be called outside the render pass <a href="#a7c80f839ba5eff8143dc8b284aaa9557">More...</a><br/></td></tr>
<tr class="separator:a7c80f839ba5eff8143dc8b284aaa9557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f74e975c767fa54c80ede3e2bd20ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a20f74e975c767fa54c80ede3e2bd20ee">copyBuffer</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> src, <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> dest, uint32 srcOffset, uint32 destOffset, uint32 sizeInBytes)</td></tr>
<tr class="memdesc:a20f74e975c767fa54c80ede3e2bd20ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffer <a href="#a20f74e975c767fa54c80ede3e2bd20ee">More...</a><br/></td></tr>
<tr class="separator:a20f74e975c767fa54c80ede3e2bd20ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce1c73dd20392b3e8e28d16548f2041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a7ce1c73dd20392b3e8e28d16548f2041">copyImageToBuffer</a> (api::TextureStore &amp;srcImage, types::ImageLayout srcImageLayout, <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;dstBuffer, types::BufferImageCopy *regions, uint32 numRegions)</td></tr>
<tr class="memdesc:a7ce1c73dd20392b3e8e28d16548f2041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image to a buffer <a href="#a7ce1c73dd20392b3e8e28d16548f2041">More...</a><br/></td></tr>
<tr class="separator:a7ce1c73dd20392b3e8e28d16548f2041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd746bf34236572a51b9a961238f06fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#afd746bf34236572a51b9a961238f06fe">dispatchCompute</a> (uint32 numGroupsX, uint32 numGroupsY=1, uint32 numGroupsZ=1)</td></tr>
<tr class="memdesc:afd746bf34236572a51b9a961238f06fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a ComputeShader execution using the ComputeShader that is in the currently bound ComputePipeline.  <a href="#afd746bf34236572a51b9a961238f06fe">More...</a><br/></td></tr>
<tr class="separator:afd746bf34236572a51b9a961238f06fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2579355a81b3bc07666f46b2bbe32d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a2579355a81b3bc07666f46b2bbe32d89">dispatchRays</a> (pvr::uint32 xOffset, pvr::uint32 yOffset, pvr::uint32 frameWidth, pvr::uint32 frameHeight)</td></tr>
<tr class="memdesc:a2579355a81b3bc07666f46b2bbe32d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a frame shader for each pixel in the box [x, y, x+width, y+height]. <a href="#a2579355a81b3bc07666f46b2bbe32d89">More...</a><br/></td></tr>
<tr class="separator:a2579355a81b3bc07666f46b2bbe32d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d3e332d34f8c1838f929f9dfbcf5cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a80d3e332d34f8c1838f929f9dfbcf5cf">drawArrays</a> (uint32 firstVertex, uint32 vertexCount, uint32 firstInstance=0, uint32 instanceCount=1)</td></tr>
<tr class="memdesc:a80d3e332d34f8c1838f929f9dfbcf5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Does not use an IndexBuffer. <a href="#a80d3e332d34f8c1838f929f9dfbcf5cf">More...</a><br/></td></tr>
<tr class="separator:a80d3e332d34f8c1838f929f9dfbcf5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0578ef087e598e0222fb15c7e86ee3b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a0578ef087e598e0222fb15c7e86ee3b2">drawArraysIndirect</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;buffer, uint32 offset, uint32 drawCount, uint32 stride)</td></tr>
<tr class="memdesc:a0578ef087e598e0222fb15c7e86ee3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawArraysIndirect <a href="#a0578ef087e598e0222fb15c7e86ee3b2">More...</a><br/></td></tr>
<tr class="separator:a0578ef087e598e0222fb15c7e86ee3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa3b2218d55301095a4664d7d56586c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3fa3b2218d55301095a4664d7d56586c">drawIndexed</a> (uint32 firstIndex, uint32 indexCount, uint32 vertexOffset=0, uint32 firstInstance=0, uint32 instanceCount=1)</td></tr>
<tr class="memdesc:a3fa3b2218d55301095a4664d7d56586c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Uses the currently bound IndexBuffer for indexes into the currently bound VBOs.  <a href="#a3fa3b2218d55301095a4664d7d56586c">More...</a><br/></td></tr>
<tr class="separator:a3fa3b2218d55301095a4664d7d56586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49007f7233b526cf8e240d6649eac83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a49007f7233b526cf8e240d6649eac83f">drawIndexedIndirect</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer)</td></tr>
<tr class="memdesc:a49007f7233b526cf8e240d6649eac83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirect Draw command. Use buffer to obtain the draw call parameters. <a href="#a49007f7233b526cf8e240d6649eac83f">More...</a><br/></td></tr>
<tr class="separator:a49007f7233b526cf8e240d6649eac83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba30e81cac9351a93f2cae4e26b85d3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aba30e81cac9351a93f2cae4e26b85d3d">drawIndirect</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer, uint32 offset, uint32 count, uint32 stride)</td></tr>
<tr class="memdesc:aba30e81cac9351a93f2cae4e26b85d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This draw command behaves similarly to drawArray except that the parameters are read by the device from a buffer during execution. <a href="#aba30e81cac9351a93f2cae4e26b85d3d">More...</a><br/></td></tr>
<tr class="separator:aba30e81cac9351a93f2cae4e26b85d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b0f42c3c3fc27de7401436383b1e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a33b0f42c3c3fc27de7401436383b1e97">endRecording</a> ()</td></tr>
<tr class="memdesc:a33b0f42c3c3fc27de7401436383b1e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you are done recording commands. BeginRecording must be called first.  <a href="#a33b0f42c3c3fc27de7401436383b1e97">More...</a><br/></td></tr>
<tr class="separator:a33b0f42c3c3fc27de7401436383b1e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c6e34e5bf7ecabe44d49b267c4da2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa99c6e34e5bf7ecabe44d49b267c4da2">endSceneHierarchy</a> ()</td></tr>
<tr class="memdesc:aa99c6e34e5bf7ecabe44d49b267c4da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the recording of scene hierarchy generation commands. <a href="#aa99c6e34e5bf7ecabe44d49b267c4da2">More...</a><br/></td></tr>
<tr class="separator:aa99c6e34e5bf7ecabe44d49b267c4da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda7dfc8e8c31b9508daac194f48a557"><td class="memItemLeft" align="right" valign="top">GraphicsContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adda7dfc8e8c31b9508daac194f48a557">getContext</a> ()</td></tr>
<tr class="memdesc:adda7dfc8e8c31b9508daac194f48a557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the context used by this CommandBuffer. <a href="#adda7dfc8e8c31b9508daac194f48a557">More...</a><br/></td></tr>
<tr class="separator:adda7dfc8e8c31b9508daac194f48a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ab01539119a2d4c9d629e46aec6e03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a81ab01539119a2d4c9d629e46aec6e03">isRecording</a> ()</td></tr>
<tr class="memdesc:a81ab01539119a2d4c9d629e46aec6e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if a command buffer is in the recording state <a href="#a81ab01539119a2d4c9d629e46aec6e03">More...</a><br/></td></tr>
<tr class="separator:a81ab01539119a2d4c9d629e46aec6e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0c00c0a250dbe0c8aa0b9482d01549"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a6d0c00c0a250dbe0c8aa0b9482d01549">mergeSceneHierarchies</a> (const SceneHierarchy &amp;destinationSceneHierarchy, pvr::math::AxisAlignedBox &amp;extents, const SceneHierarchy *sourceSceneHierarchies, const pvr::uint32 numberOfSourceSceneHierarchies, const pvr::uint32 mergeQuality)</td></tr>
<tr class="memdesc:a6d0c00c0a250dbe0c8aa0b9482d01549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges a number of scene hierarchies into a single merged hierarchy. <a href="#a6d0c00c0a250dbe0c8aa0b9482d01549">More...</a><br/></td></tr>
<tr class="separator:a6d0c00c0a250dbe0c8aa0b9482d01549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5506e55f62155f1d81a8dc436ace5d84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a5506e55f62155f1d81a8dc436ace5d84">pipelineBarrier</a> (types::PipelineStageFlags srcStage, types::PipelineStageFlags dstStage, const <a class="el" href="classpvr_1_1api_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers, bool dependencyByRegion=true)</td></tr>
<tr class="memdesc:a5506e55f62155f1d81a8dc436ace5d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed. <a href="#a5506e55f62155f1d81a8dc436ace5d84">More...</a><br/></td></tr>
<tr class="separator:a5506e55f62155f1d81a8dc436ace5d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9aabed41319304de1f36ad4b5b7026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3c9aabed41319304de1f36ad4b5b7026">popPipeline</a> ()</td></tr>
<tr class="memdesc:a3c9aabed41319304de1f36ad4b5b7026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the previously pushed pipeline (See pushGraphicsPipeline) <a href="#a3c9aabed41319304de1f36ad4b5b7026">More...</a><br/></td></tr>
<tr class="separator:a3c9aabed41319304de1f36ad4b5b7026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fada6bcf071b51e17f17d525bc9ba5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a82fada6bcf071b51e17f17d525bc9ba5">pushPipeline</a> ()</td></tr>
<tr class="memdesc:a82fada6bcf071b51e17f17d525bc9ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store which pipeline is currently bound, so that it can later be retrieved and bound with a popPipeline command. <a href="#a82fada6bcf071b51e17f17d525bc9ba5">More...</a><br/></td></tr>
<tr class="separator:a82fada6bcf071b51e17f17d525bc9ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a759341fd752a954ca56ca3aa35266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa0a759341fd752a954ca56ca3aa35266">pushSharedRayConstants</a> (uint32 offset, uint32 size, const void *pValues)</td></tr>
<tr class="memdesc:aa0a759341fd752a954ca56ca3aa35266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push shared ray constant data. <a href="#aa0a759341fd752a954ca56ca3aa35266">More...</a><br/></td></tr>
<tr class="separator:aa0a759341fd752a954ca56ca3aa35266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09862df3dc41a6813b8c8841694221d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ab09862df3dc41a6813b8c8841694221d">resetPipeline</a> ()</td></tr>
<tr class="memdesc:ab09862df3dc41a6813b8c8841694221d"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERNAL. reset the currently bound pipeline. <a href="#ab09862df3dc41a6813b8c8841694221d">More...</a><br/></td></tr>
<tr class="separator:ab09862df3dc41a6813b8c8841694221d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43fb0991e490a512bd4968ca267616c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad43fb0991e490a512bd4968ca267616c">sceneHierarchyAppend</a> (pvr::uint32 vertexCount, pvr::uint32 instanceCount, pvr::uint32 firstVertex, pvr::uint32 firstInstance)</td></tr>
<tr class="memdesc:ad43fb0991e490a512bd4968ca267616c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends geometry for use in scene hierarchy building. <a href="#ad43fb0991e490a512bd4968ca267616c">More...</a><br/></td></tr>
<tr class="separator:ad43fb0991e490a512bd4968ca267616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8739f9eba083eff664bb47968efd84f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad8739f9eba083eff664bb47968efd84f">sceneHierarchyAppendIndexed</a> (pvr::uint32 indexCount, pvr::uint32 instanceCount, pvr::uint32 firstIndex, pvr::uint32 vertexOffset, pvr::uint32 firstInstance)</td></tr>
<tr class="memdesc:ad8739f9eba083eff664bb47968efd84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends indexed geometry for use in scene hierarchy building. <a href="#ad8739f9eba083eff664bb47968efd84f">More...</a><br/></td></tr>
<tr class="separator:ad8739f9eba083eff664bb47968efd84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ba580bbf18f9f8e56276fa5d417c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a25ba580bbf18f9f8e56276fa5d417c74">sceneHierarchyAppendIndexedIndirect</a> (pvr::api::BufferView &amp;indirectBuffer, pvr::uint32 offset, pvr::uint32 drawCount, pvr::uint32 stride)</td></tr>
<tr class="memdesc:a25ba580bbf18f9f8e56276fa5d417c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirectly appends indexed geometry for use in scene hierarchy building. <a href="#a25ba580bbf18f9f8e56276fa5d417c74">More...</a><br/></td></tr>
<tr class="separator:a25ba580bbf18f9f8e56276fa5d417c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815271c5a31617cb98872bf10b855442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a815271c5a31617cb98872bf10b855442">sceneHierarchyAppendIndirect</a> (pvr::api::BufferView &amp;indirectBuffer, pvr::uint32 offset, pvr::uint32 drawCount, pvr::uint32 stride)</td></tr>
<tr class="memdesc:a815271c5a31617cb98872bf10b855442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirectly appends geometry for use in scene hierarchy building. <a href="#a815271c5a31617cb98872bf10b855442">More...</a><br/></td></tr>
<tr class="separator:a815271c5a31617cb98872bf10b855442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfefa9d65cd7b481c628517cbbb5f6c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#abfefa9d65cd7b481c628517cbbb5f6c4">setBlendConstants</a> (glm::vec4 rgba)</td></tr>
<tr class="memdesc:abfefa9d65cd7b481c628517cbbb5f6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set blend constants for blend operation using constant colors <a href="#abfefa9d65cd7b481c628517cbbb5f6c4">More...</a><br/></td></tr>
<tr class="separator:abfefa9d65cd7b481c628517cbbb5f6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafcdc7cdcdbce966593ff8b9f4f5a27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aaafcdc7cdcdbce966593ff8b9f4f5a27">setDepthBias</a> (float32 depthBiasConstantFactor, float32 depthBiasClamp, float32 depthBiasSlopeFactor)</td></tr>
<tr class="memdesc:aaafcdc7cdcdbce966593ff8b9f4f5a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a dynamic command which controll the offset of depth values of all fragments generated by the rasterization of a polygon. NOTE: If depthBiasEnable is set to false in <a class="el" href="structpvr_1_1api_1_1pipeline_creation_1_1_raster_state_create_param.html" title="Pipeline Rasterisation, clipping and culling state configuration. Culling, winding order...">pipelineCreation::RasterStateCreateParam</a> then no depth bias is applied and the fragment's depth values are unchanged. <a href="#aaafcdc7cdcdbce966593ff8b9f4f5a27">More...</a><br/></td></tr>
<tr class="separator:aaafcdc7cdcdbce966593ff8b9f4f5a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dcda0cde4b373682c2a908649cd1a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a98dcda0cde4b373682c2a908649cd1a5">setDepthBound</a> (float32 min=0.0f, float32 max=1)</td></tr>
<tr class="memdesc:a98dcda0cde4b373682c2a908649cd1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set minimum and maximum depth <a href="#a98dcda0cde4b373682c2a908649cd1a5">More...</a><br/></td></tr>
<tr class="separator:a98dcda0cde4b373682c2a908649cd1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5486b945bb413470d37961d19b6c2732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a5486b945bb413470d37961d19b6c2732">setLineWidth</a> (float32 lineWidth)</td></tr>
<tr class="memdesc:a5486b945bb413470d37961d19b6c2732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the line width <a href="#a5486b945bb413470d37961d19b6c2732">More...</a><br/></td></tr>
<tr class="separator:a5486b945bb413470d37961d19b6c2732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4c107d37232266c3e3e7744c5250bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aff4c107d37232266c3e3e7744c5250bd">setRayBounceLimit</a> (uint32 limit)</td></tr>
<tr class="memdesc:aff4c107d37232266c3e3e7744c5250bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ray bounce limit. <a href="#aff4c107d37232266c3e3e7744c5250bd">More...</a><br/></td></tr>
<tr class="separator:aff4c107d37232266c3e3e7744c5250bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36750f46eb10f52389aab772a97c7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa36750f46eb10f52389aab772a97c7f6">setRaySizes</a> (uint32 raySizeCount, const uint32 *pRaySizes)</td></tr>
<tr class="memdesc:aa36750f46eb10f52389aab772a97c7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sizes of rays used in a renderpass. <a href="#aa36750f46eb10f52389aab772a97c7f6">More...</a><br/></td></tr>
<tr class="separator:aa36750f46eb10f52389aab772a97c7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfde75092656782a733986836aa14c35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adfde75092656782a733986836aa14c35">setScissor</a> (const Rectanglei &amp;scissor)</td></tr>
<tr class="memdesc:adfde75092656782a733986836aa14c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scissor rectangle <a href="#adfde75092656782a733986836aa14c35">More...</a><br/></td></tr>
<tr class="separator:adfde75092656782a733986836aa14c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2f968a5744aa0b91918c92fc49e763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3c2f968a5744aa0b91918c92fc49e763">setStencilCompareMask</a> (types::StencilFace face, uint32 compareMask)</td></tr>
<tr class="memdesc:a3c2f968a5744aa0b91918c92fc49e763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stencil comparison mask <a href="#a3c2f968a5744aa0b91918c92fc49e763">More...</a><br/></td></tr>
<tr class="separator:a3c2f968a5744aa0b91918c92fc49e763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f204d1a61924a5559c0cbdec039af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa7f204d1a61924a5559c0cbdec039af3">setStencilReference</a> (types::StencilFace face, uint32 ref)</td></tr>
<tr class="memdesc:aa7f204d1a61924a5559c0cbdec039af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stencil reference value <a href="#aa7f204d1a61924a5559c0cbdec039af3">More...</a><br/></td></tr>
<tr class="separator:aa7f204d1a61924a5559c0cbdec039af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ceab439157fc658f32552f50963bd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a52ceab439157fc658f32552f50963bd7">setStencilWriteMask</a> (types::StencilFace face, uint32 writeMask)</td></tr>
<tr class="memdesc:a52ceab439157fc658f32552f50963bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stencil write mask <a href="#a52ceab439157fc658f32552f50963bd7">More...</a><br/></td></tr>
<tr class="separator:a52ceab439157fc658f32552f50963bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b02946cb8a720619381e395fdb20aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a1b02946cb8a720619381e395fdb20aa6">setUniform</a> (int32 location, const uint32 &amp;val)</td></tr>
<tr class="memdesc:a1b02946cb8a720619381e395fdb20aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a1b02946cb8a720619381e395fdb20aa6">More...</a><br/></td></tr>
<tr class="separator:a1b02946cb8a720619381e395fdb20aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac909e5e03cdcfc6100c4fdf02a48d5cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ac909e5e03cdcfc6100c4fdf02a48d5cd">setUniform</a> (int32 location, const int32 &amp;val)</td></tr>
<tr class="memdesc:ac909e5e03cdcfc6100c4fdf02a48d5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#ac909e5e03cdcfc6100c4fdf02a48d5cd">More...</a><br/></td></tr>
<tr class="separator:ac909e5e03cdcfc6100c4fdf02a48d5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8aec90c4019deeb6d8db43a37c5579c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad8aec90c4019deeb6d8db43a37c5579c">setUniform</a> (int32 location, const float32 &amp;val)</td></tr>
<tr class="memdesc:ad8aec90c4019deeb6d8db43a37c5579c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#ad8aec90c4019deeb6d8db43a37c5579c">More...</a><br/></td></tr>
<tr class="separator:ad8aec90c4019deeb6d8db43a37c5579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4c093621d382784f8e2406731e84ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a6b4c093621d382784f8e2406731e84ce">setUniform</a> (int32 location, const glm::vec2 &amp;val)</td></tr>
<tr class="memdesc:a6b4c093621d382784f8e2406731e84ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a6b4c093621d382784f8e2406731e84ce">More...</a><br/></td></tr>
<tr class="separator:a6b4c093621d382784f8e2406731e84ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3285ce1e6df5eabe0984c0cc0d0aeb6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3285ce1e6df5eabe0984c0cc0d0aeb6a">setUniform</a> (int32 location, const glm::ivec2 &amp;val)</td></tr>
<tr class="memdesc:a3285ce1e6df5eabe0984c0cc0d0aeb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a3285ce1e6df5eabe0984c0cc0d0aeb6a">More...</a><br/></td></tr>
<tr class="separator:a3285ce1e6df5eabe0984c0cc0d0aeb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af551b190c46874c6b68639ebf4cb462f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#af551b190c46874c6b68639ebf4cb462f">setUniform</a> (int32 location, const glm::uvec2 &amp;val)</td></tr>
<tr class="memdesc:af551b190c46874c6b68639ebf4cb462f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#af551b190c46874c6b68639ebf4cb462f">More...</a><br/></td></tr>
<tr class="separator:af551b190c46874c6b68639ebf4cb462f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991c4e11cae022d3ff9cb6bcca54bef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a991c4e11cae022d3ff9cb6bcca54bef8">setUniform</a> (int32 location, const glm::vec3 &amp;val)</td></tr>
<tr class="memdesc:a991c4e11cae022d3ff9cb6bcca54bef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a991c4e11cae022d3ff9cb6bcca54bef8">More...</a><br/></td></tr>
<tr class="separator:a991c4e11cae022d3ff9cb6bcca54bef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162d0a010bdb15d09c383d12b551601c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a162d0a010bdb15d09c383d12b551601c">setUniform</a> (int32 location, const glm::ivec3 &amp;val)</td></tr>
<tr class="memdesc:a162d0a010bdb15d09c383d12b551601c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a162d0a010bdb15d09c383d12b551601c">More...</a><br/></td></tr>
<tr class="separator:a162d0a010bdb15d09c383d12b551601c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee6239a34140b5daa677b2eef9aebc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a9ee6239a34140b5daa677b2eef9aebc6">setUniform</a> (int32 location, const glm::uvec3 &amp;val)</td></tr>
<tr class="memdesc:a9ee6239a34140b5daa677b2eef9aebc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a9ee6239a34140b5daa677b2eef9aebc6">More...</a><br/></td></tr>
<tr class="separator:a9ee6239a34140b5daa677b2eef9aebc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea93b97c839ff1826737ee39e849a892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aea93b97c839ff1826737ee39e849a892">setUniform</a> (int32 location, const glm::vec4 &amp;val)</td></tr>
<tr class="memdesc:aea93b97c839ff1826737ee39e849a892"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#aea93b97c839ff1826737ee39e849a892">More...</a><br/></td></tr>
<tr class="separator:aea93b97c839ff1826737ee39e849a892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cece054dcbe7348a35aa1ac7478c1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a28cece054dcbe7348a35aa1ac7478c1d">setUniform</a> (int32 location, const glm::ivec4 &amp;val)</td></tr>
<tr class="memdesc:a28cece054dcbe7348a35aa1ac7478c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a28cece054dcbe7348a35aa1ac7478c1d">More...</a><br/></td></tr>
<tr class="separator:a28cece054dcbe7348a35aa1ac7478c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52de50d45c0d4b288dab63b793a9cbb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a52de50d45c0d4b288dab63b793a9cbb3">setUniform</a> (int32 location, const glm::uvec4 &amp;val)</td></tr>
<tr class="memdesc:a52de50d45c0d4b288dab63b793a9cbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a52de50d45c0d4b288dab63b793a9cbb3">More...</a><br/></td></tr>
<tr class="separator:a52de50d45c0d4b288dab63b793a9cbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda906d610351a5f04cf17d3dfe00e63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#abda906d610351a5f04cf17d3dfe00e63">setUniform</a> (int32 location, const glm::mat2 &amp;val)</td></tr>
<tr class="memdesc:abda906d610351a5f04cf17d3dfe00e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#abda906d610351a5f04cf17d3dfe00e63">More...</a><br/></td></tr>
<tr class="separator:abda906d610351a5f04cf17d3dfe00e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bb24f25d814b9f41f9afae9bd8a989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a16bb24f25d814b9f41f9afae9bd8a989">setUniform</a> (int32 location, const glm::mat2x3 &amp;val)</td></tr>
<tr class="memdesc:a16bb24f25d814b9f41f9afae9bd8a989"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a16bb24f25d814b9f41f9afae9bd8a989">More...</a><br/></td></tr>
<tr class="separator:a16bb24f25d814b9f41f9afae9bd8a989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f2cc5275071ab09813c331c7f741de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a59f2cc5275071ab09813c331c7f741de">setUniform</a> (int32 location, const glm::mat2x4 &amp;val)</td></tr>
<tr class="memdesc:a59f2cc5275071ab09813c331c7f741de"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a59f2cc5275071ab09813c331c7f741de">More...</a><br/></td></tr>
<tr class="separator:a59f2cc5275071ab09813c331c7f741de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa548a85f2cb7bafec11ecddd91204f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a8fa548a85f2cb7bafec11ecddd91204f">setUniform</a> (int32 location, const glm::mat3x2 &amp;val)</td></tr>
<tr class="memdesc:a8fa548a85f2cb7bafec11ecddd91204f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a8fa548a85f2cb7bafec11ecddd91204f">More...</a><br/></td></tr>
<tr class="separator:a8fa548a85f2cb7bafec11ecddd91204f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3470ff11bcf88d07724f67de6f0e6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a9d3470ff11bcf88d07724f67de6f0e6a">setUniform</a> (int32 location, const glm::mat3 &amp;val)</td></tr>
<tr class="memdesc:a9d3470ff11bcf88d07724f67de6f0e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a9d3470ff11bcf88d07724f67de6f0e6a">More...</a><br/></td></tr>
<tr class="separator:a9d3470ff11bcf88d07724f67de6f0e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d43dff8b5653d7980f8d520fe92e93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ae8d43dff8b5653d7980f8d520fe92e93">setUniform</a> (int32 location, const glm::mat3x4 &amp;val)</td></tr>
<tr class="memdesc:ae8d43dff8b5653d7980f8d520fe92e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#ae8d43dff8b5653d7980f8d520fe92e93">More...</a><br/></td></tr>
<tr class="separator:ae8d43dff8b5653d7980f8d520fe92e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac046512c225f69b60db50e6ae30d7d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ac046512c225f69b60db50e6ae30d7d64">setUniform</a> (int32 location, const glm::mat4x2 &amp;val)</td></tr>
<tr class="memdesc:ac046512c225f69b60db50e6ae30d7d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#ac046512c225f69b60db50e6ae30d7d64">More...</a><br/></td></tr>
<tr class="separator:ac046512c225f69b60db50e6ae30d7d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b7a7a69ad282b8b5ca750d41800635"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a73b7a7a69ad282b8b5ca750d41800635">setUniform</a> (int32 location, const glm::mat4x3 &amp;val)</td></tr>
<tr class="memdesc:a73b7a7a69ad282b8b5ca750d41800635"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a73b7a7a69ad282b8b5ca750d41800635">More...</a><br/></td></tr>
<tr class="separator:a73b7a7a69ad282b8b5ca750d41800635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760f42bdb4a38ca6c9de0e02d9344117"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a760f42bdb4a38ca6c9de0e02d9344117">setUniform</a> (int32 location, const glm::mat4x4 &amp;val)</td></tr>
<tr class="memdesc:a760f42bdb4a38ca6c9de0e02d9344117"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a760f42bdb4a38ca6c9de0e02d9344117">More...</a><br/></td></tr>
<tr class="separator:a760f42bdb4a38ca6c9de0e02d9344117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22aadd54bea402313ed21e3260328d40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a22aadd54bea402313ed21e3260328d40">setUniformPtr</a> (int32 location, uint32 count, const uint32 *ptr)</td></tr>
<tr class="memdesc:a22aadd54bea402313ed21e3260328d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a22aadd54bea402313ed21e3260328d40">More...</a><br/></td></tr>
<tr class="separator:a22aadd54bea402313ed21e3260328d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7062b2d4a6ca4973bd7b054a112f58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a9f7062b2d4a6ca4973bd7b054a112f58">setUniformPtr</a> (int32 location, uint32 count, const int32 *ptr)</td></tr>
<tr class="memdesc:a9f7062b2d4a6ca4973bd7b054a112f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a9f7062b2d4a6ca4973bd7b054a112f58">More...</a><br/></td></tr>
<tr class="separator:a9f7062b2d4a6ca4973bd7b054a112f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d54db440cf087f040bbda86e5e95a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a54d54db440cf087f040bbda86e5e95a3">setUniformPtr</a> (int32 location, uint32 count, const float32 *ptr)</td></tr>
<tr class="memdesc:a54d54db440cf087f040bbda86e5e95a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a54d54db440cf087f040bbda86e5e95a3">More...</a><br/></td></tr>
<tr class="separator:a54d54db440cf087f040bbda86e5e95a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baa3038d44b3a7e3e870f3a10fbae71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a6baa3038d44b3a7e3e870f3a10fbae71">setUniformPtr</a> (int32 location, uint32 count, const glm::vec2 *ptr)</td></tr>
<tr class="memdesc:a6baa3038d44b3a7e3e870f3a10fbae71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a6baa3038d44b3a7e3e870f3a10fbae71">More...</a><br/></td></tr>
<tr class="separator:a6baa3038d44b3a7e3e870f3a10fbae71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82486522419a41265f9f8df4789bb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#af82486522419a41265f9f8df4789bb0c">setUniformPtr</a> (int32 location, uint32 count, const glm::ivec2 *ptr)</td></tr>
<tr class="memdesc:af82486522419a41265f9f8df4789bb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#af82486522419a41265f9f8df4789bb0c">More...</a><br/></td></tr>
<tr class="separator:af82486522419a41265f9f8df4789bb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3dcb29504db57df1b5c6b256414cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a1e3dcb29504db57df1b5c6b256414cb4">setUniformPtr</a> (int32 location, uint32 count, const glm::uvec2 *ptr)</td></tr>
<tr class="memdesc:a1e3dcb29504db57df1b5c6b256414cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a1e3dcb29504db57df1b5c6b256414cb4">More...</a><br/></td></tr>
<tr class="separator:a1e3dcb29504db57df1b5c6b256414cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050b1a9a98049382acca50937c758bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a050b1a9a98049382acca50937c758bce">setUniformPtr</a> (int32 location, uint32 count, const glm::vec3 *ptr)</td></tr>
<tr class="memdesc:a050b1a9a98049382acca50937c758bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a050b1a9a98049382acca50937c758bce">More...</a><br/></td></tr>
<tr class="separator:a050b1a9a98049382acca50937c758bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73da778d67c9a32f44a9bf0e119e4b8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a73da778d67c9a32f44a9bf0e119e4b8c">setUniformPtr</a> (int32 location, uint32 count, const glm::ivec3 *ptr)</td></tr>
<tr class="memdesc:a73da778d67c9a32f44a9bf0e119e4b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a73da778d67c9a32f44a9bf0e119e4b8c">More...</a><br/></td></tr>
<tr class="separator:a73da778d67c9a32f44a9bf0e119e4b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9ddd0b0a8a6acc46c071ede9ecac97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a8d9ddd0b0a8a6acc46c071ede9ecac97">setUniformPtr</a> (int32 location, uint32 count, const glm::uvec3 *ptr)</td></tr>
<tr class="memdesc:a8d9ddd0b0a8a6acc46c071ede9ecac97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a8d9ddd0b0a8a6acc46c071ede9ecac97">More...</a><br/></td></tr>
<tr class="separator:a8d9ddd0b0a8a6acc46c071ede9ecac97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b085146682c8f9c18e5030dfebb892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad4b085146682c8f9c18e5030dfebb892">setUniformPtr</a> (int32 location, uint32 count, const glm::vec4 *ptr)</td></tr>
<tr class="memdesc:ad4b085146682c8f9c18e5030dfebb892"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#ad4b085146682c8f9c18e5030dfebb892">More...</a><br/></td></tr>
<tr class="separator:ad4b085146682c8f9c18e5030dfebb892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10b47337b55eeb12c3de0d914404de6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad10b47337b55eeb12c3de0d914404de6">setUniformPtr</a> (int32 location, uint32 count, const glm::ivec4 *ptr)</td></tr>
<tr class="memdesc:ad10b47337b55eeb12c3de0d914404de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#ad10b47337b55eeb12c3de0d914404de6">More...</a><br/></td></tr>
<tr class="separator:ad10b47337b55eeb12c3de0d914404de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f47a63f71756adbbf4f0adb6d1bd701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a6f47a63f71756adbbf4f0adb6d1bd701">setUniformPtr</a> (int32 location, uint32 count, const glm::uvec4 *ptr)</td></tr>
<tr class="memdesc:a6f47a63f71756adbbf4f0adb6d1bd701"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a6f47a63f71756adbbf4f0adb6d1bd701">More...</a><br/></td></tr>
<tr class="separator:a6f47a63f71756adbbf4f0adb6d1bd701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f40c7c2c51ca3f5413a3e58f9386ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a81f40c7c2c51ca3f5413a3e58f9386ae">setUniformPtr</a> (int32 location, uint32 count, const glm::mat2 *ptr)</td></tr>
<tr class="memdesc:a81f40c7c2c51ca3f5413a3e58f9386ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a81f40c7c2c51ca3f5413a3e58f9386ae">More...</a><br/></td></tr>
<tr class="separator:a81f40c7c2c51ca3f5413a3e58f9386ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10591384fe73401fba7c6f70c5290802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a10591384fe73401fba7c6f70c5290802">setUniformPtr</a> (int32 location, uint32 count, const glm::mat2x3 *ptr)</td></tr>
<tr class="memdesc:a10591384fe73401fba7c6f70c5290802"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a10591384fe73401fba7c6f70c5290802">More...</a><br/></td></tr>
<tr class="separator:a10591384fe73401fba7c6f70c5290802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603d52631827f45e4acf442296ee4fcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a603d52631827f45e4acf442296ee4fcc">setUniformPtr</a> (int32 location, uint32 count, const glm::mat2x4 *ptr)</td></tr>
<tr class="memdesc:a603d52631827f45e4acf442296ee4fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a603d52631827f45e4acf442296ee4fcc">More...</a><br/></td></tr>
<tr class="separator:a603d52631827f45e4acf442296ee4fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea89274467964db30e970b35249c505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a8ea89274467964db30e970b35249c505">setUniformPtr</a> (int32 location, uint32 count, const glm::mat3x2 *ptr)</td></tr>
<tr class="memdesc:a8ea89274467964db30e970b35249c505"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a8ea89274467964db30e970b35249c505">More...</a><br/></td></tr>
<tr class="separator:a8ea89274467964db30e970b35249c505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f13dd6a2743bc17aeb6a93a4e6c6ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ab4f13dd6a2743bc17aeb6a93a4e6c6ba">setUniformPtr</a> (int32 location, uint32 count, const glm::mat3 *ptr)</td></tr>
<tr class="memdesc:ab4f13dd6a2743bc17aeb6a93a4e6c6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#ab4f13dd6a2743bc17aeb6a93a4e6c6ba">More...</a><br/></td></tr>
<tr class="separator:ab4f13dd6a2743bc17aeb6a93a4e6c6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb30f6a0f833293f9025a9c6f22c15c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adb30f6a0f833293f9025a9c6f22c15c1">setUniformPtr</a> (int32 location, uint32 count, const glm::mat3x4 *ptr)</td></tr>
<tr class="memdesc:adb30f6a0f833293f9025a9c6f22c15c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#adb30f6a0f833293f9025a9c6f22c15c1">More...</a><br/></td></tr>
<tr class="separator:adb30f6a0f833293f9025a9c6f22c15c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0b2a199cf6bc391b4451817a68b648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ace0b2a199cf6bc391b4451817a68b648">setUniformPtr</a> (int32 location, uint32 count, const glm::mat4x2 *ptr)</td></tr>
<tr class="memdesc:ace0b2a199cf6bc391b4451817a68b648"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#ace0b2a199cf6bc391b4451817a68b648">More...</a><br/></td></tr>
<tr class="separator:ace0b2a199cf6bc391b4451817a68b648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ac7522a204fedebac5530c4788dba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad0ac7522a204fedebac5530c4788dba0">setUniformPtr</a> (int32 location, uint32 count, const glm::mat4x3 *ptr)</td></tr>
<tr class="memdesc:ad0ac7522a204fedebac5530c4788dba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#ad0ac7522a204fedebac5530c4788dba0">More...</a><br/></td></tr>
<tr class="separator:ad0ac7522a204fedebac5530c4788dba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941bcb3e189792e13fe4bca6eddb41f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a941bcb3e189792e13fe4bca6eddb41f3">setUniformPtr</a> (int32 location, uint32 count, const glm::mat4x4 *ptr)</td></tr>
<tr class="memdesc:a941bcb3e189792e13fe4bca6eddb41f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a941bcb3e189792e13fe4bca6eddb41f3">More...</a><br/></td></tr>
<tr class="separator:a941bcb3e189792e13fe4bca6eddb41f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf768f84801a0915feef75a926f12e3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adf768f84801a0915feef75a926f12e3c">setViewport</a> (const Rectanglei &amp;viewport)</td></tr>
<tr class="memdesc:adf768f84801a0915feef75a926f12e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the viewport rectangle <a href="#adf768f84801a0915feef75a926f12e3c">More...</a><br/></td></tr>
<tr class="separator:adf768f84801a0915feef75a926f12e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d3a922739e0a25c2118766f40d9842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa4d3a922739e0a25c2118766f40d9842">updateBuffer</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer, const void *data, uint32 offset, uint32 length)</td></tr>
<tr class="memdesc:aa4d3a922739e0a25c2118766f40d9842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the buffer. <a href="#aa4d3a922739e0a25c2118766f40d9842">More...</a><br/></td></tr>
<tr class="separator:aa4d3a922739e0a25c2118766f40d9842"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. In debug builds (define DEBUG or define PVR_STORE_STACK_TRACE_WITH_API_COMMANDS), a limited stack trace is stored with each command so that if an error occurs, the site where the command was actually added to the command buffer can be determined. </p>
<p>Primary command buffers can contain RenderPasses, and can be submitted to the GPU. Secondary command buffers cannot contain RenderPasses, and can be enqueued to PrimaryCommandBuffers.</p>
<p>-It is invalid to submit commands to a command buffer while it is not being recorded.</p>
<p>-It is invalid to reset a command buffer while it is being recorded.</p>
<p>-It is invalid to submit a command buffer more than once if it is one time submit command buffer</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a085614fc5885fc5df5ef326e3a3a01ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pvr::api::impl::CommandBufferBase_::~CommandBufferBase_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7b7d358802ca484e7a8be735b09d83fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::beginSceneHierarchy </td>
          <td>(</td>
          <td class="paramtype">const SceneHierarchy &amp;&#160;</td>
          <td class="paramname"><em>sceneHierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::math::AxisAlignedBox &amp;&#160;</td>
          <td class="paramname"><em>extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins the recording of scene hierarchy generation commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneHierarchy</td><td>The scene hierarchy which will be target of build commands in the command buffer.</td></tr>
    <tr><td class="paramname">extents</td><td>The scene hierarchy extents to use when building the hierarchy.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30c074492d6949ed275a8b45b5c169cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindAccumulationImages </td>
          <td>(</td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>startBinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>bindingCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TextureView *&#160;</td>
          <td class="paramname"><em>imageViews</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a number of accumulation images making accumulation to them possible in subsequent commands which dispatch rays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startBinding</td><td>The initial binding index to use.</td></tr>
    <tr><td class="paramname">bindingCount</td><td>The accumulation image count.</td></tr>
    <tr><td class="paramname">imageViews</td><td>The accumulation images to bind.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab08ef00d0041fe5028502f844fed236c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindDescriptorSet </td>
          <td>(</td>
          <td class="paramtype">const api::PipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DescriptorSet &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a single DescriptorSet to the Graphics Pipeline binding point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineLayout</td><td>The pipelineLayout that the GraphicsPipeline will have</td></tr>
    <tr><td class="paramname">index</td><td>The index to which to bind the descriptor set</td></tr>
    <tr><td class="paramname">set</td><td>The descriptorSet to bind to the binding point bindingPoint</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>A c-style array of unsigned integers, each of which is consecutively applied as a Dynamic Offset to a Dynamic buffer (uniform/storage) of this descriptor set, in order.</td></tr>
    <tr><td class="paramname">numDynamicOffsets</td><td>The number of dynamic offsets in <em>dynamicOffsets.</em> Must exactly much the number of Dynamic objects in the <em>set.</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36453a83eed132b55306f6a1da75ab66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindDescriptorSetCompute </td>
          <td>(</td>
          <td class="paramtype">const api::PipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DescriptorSet &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a single DescriptorSet to the Compute Pipeline binding point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineLayout</td><td>The pipelineLayout that the ComputePipeline will have</td></tr>
    <tr><td class="paramname">index</td><td>The index to which to bind the descriptor set</td></tr>
    <tr><td class="paramname">set</td><td>The descriptorSet to bind to the binding point bindingPoint</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>A c-style array of unsigned integers, each of which is consecutively applied as a Dynamic Offset to a Dynamic buffer (uniform/storage) of this descriptor set, in order.</td></tr>
    <tr><td class="paramname">numDynamicOffsets</td><td>The number of dynamic offsets in <em>dynamicOffsets.</em> Must exactly much the number of Dynamic objects in the <em>set.</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05e7eeacb4ae57ad3acf0bda43cdc42e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindDescriptorSetRayTracing </td>
          <td>(</td>
          <td class="paramtype">const api::PipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DescriptorSet &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a single DescriptorSet to the Ray Tracing Pipeline binding point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineLayout</td><td>The pipelineLayout that the Ray Tracing Pipeline will have</td></tr>
    <tr><td class="paramname">index</td><td>The index to which to bind the descriptor set</td></tr>
    <tr><td class="paramname">set</td><td>The descriptorSet to bind to the binding point bindingPoint</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>A c-style array of unsigned integers, each of which is consecutively applied as a Dynamic Offset to a Dynamic buffer (uniform/storage) of this descriptor set, in order.</td></tr>
    <tr><td class="paramname">numDynamicOffsets</td><td>The number of dynamic offsets in <em>dynamicOffsets.</em> Must exactly much the number of Dynamic objects in the <em>set.</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b1f2311a10d6d592809685bb4383c7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindDescriptorSets </td>
          <td>(</td>
          <td class="paramtype">types::PipelineBindPoint&#160;</td>
          <td class="paramname"><em>bindingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const api::PipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DescriptorSet *&#160;</td>
          <td class="paramname"><em>sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numDescSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind multiple DescriptorSets</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td>The index where the first descriptor set will bind to. The rest will be bound successively.</td></tr>
    <tr><td class="paramname">pipelineLayout</td><td>The pipelineLayout that the GraphicsPipeline will have</td></tr>
    <tr><td class="paramname">firstSet</td><td>The first index to start binding descriptor sets to.</td></tr>
    <tr><td class="paramname">sets</td><td>The array of descriptorSets. The first item in the array will be bound to binding point <em>firstSet</em> and each one after to the next binding point</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>An array of Offsets that will be used when binding items of this descriptor set respectively</td></tr>
    <tr><td class="paramname">numDescSets</td><td>The number of descriptor sets in the array</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>A c-style array of unsigned integers, each of which is consecutively applied as a Dynamic Offset to a Dynamic buffer (uniform/storage) of this descriptor set, in order.</td></tr>
    <tr><td class="paramname">numDynamicOffsets</td><td>The number of dynamic offsets in <em>dynamicOffsets.</em> Must exactly much the number of Dynamic objects in the <em>set.</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa4f6de0ca2d21418896d6dff7ff1970"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindDescriptorSetSHG </td>
          <td>(</td>
          <td class="paramtype">const api::PipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DescriptorSet &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a single DescriptorSet to the Scene Hierarchy Generator Pipeline binding point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineLayout</td><td>The pipelineLayout that the Scene Hierarchy Generator Pipeline will have</td></tr>
    <tr><td class="paramname">index</td><td>The index to which to bind the descriptor set</td></tr>
    <tr><td class="paramname">set</td><td>The descriptorSet to bind to the binding point bindingPoint</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>A c-style array of unsigned integers, each of which is consecutively applied as a Dynamic Offset to a Dynamic buffer (uniform/storage) of this descriptor set, in order.</td></tr>
    <tr><td class="paramname">numDynamicOffsets</td><td>The number of dynamic offsets in <em>dynamicOffsets.</em> Must exactly much the number of Dynamic objects in the <em>set.</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a42a80f1a60693eff86f37989b0ede0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::IndexType&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind an index buffer for drawing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to bind as an IndexBuffer</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the Index buffer to bind</td></tr>
    <tr><td class="paramname">indexType</td><td>the type of indices the buffer contains</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c52c2e276ce8e0530f1b9367d351be3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">GraphicsPipeline&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a graphics pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The GraphicsPipeline to bind.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6d2777f4821115ac50b28343329bbfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">ComputePipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a compute pipeline</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The ComputePipeline to bind</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf97f03e8d635082f1f2368b9224fe8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">SceneTraversalPipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a Scene Traversal pipeline</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The SceneTraversalPipeline to bind</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3aa652603f8ef0cd1955441c6f2eb116"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">VertexRayPipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a Vertex Ray pipeline</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The VertexRayPipeline to bind</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a035a1c1722d636da391dd7abda4d9aa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindSceneHierarchies </td>
          <td>(</td>
          <td class="paramtype">const SceneHierarchy *&#160;</td>
          <td class="paramname"><em>sceneHierarchies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>firstBinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvr::uint32&#160;</td>
          <td class="paramname"><em>numberOfSceneHierarchies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a number of scene hierarchies making it possible to use them in subsequent dispatches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneHierarchies</td><td>The scene hierarchies to bind.</td></tr>
    <tr><td class="paramname">firstBinding</td><td>The index to use for the first binding.</td></tr>
    <tr><td class="paramname">numberOfSceneHierarchies</td><td>The number of scene hierarchies to bind.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecde8359a87bb2da46c141974a5c6e16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bindingIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> for drawing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vertex buffer to bind</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the vertex buffer to bind</td></tr>
    <tr><td class="paramname">bindingIndex</td><td>The Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> index to bind the vertex buffer to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71b052b600d0111a278a203ebb3701c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>startBinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bindingCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind an array of Vertex Buffers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The array of buffers</td></tr>
    <tr><td class="paramname">offsets</td><td>The array of offsets into the vertex buffer, each corresponding to a vertex buffer </td></tr>
    <tr><td class="paramname">startBinding</td><td>The binding index that the first buffer will be bound</td></tr>
    <tr><td class="paramname">numBuffers</td><td>The number of buffers to bind</td></tr>
    <tr><td class="paramname">bindingCount</td><td>The number of bindings</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16249a7acca496e5604269badc31046d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::blitImage </td>
          <td>(</td>
          <td class="paramtype">api::TextureStore &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::TextureStore &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>srcLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>dstLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageBlitRange *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::SamplerFilter&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blit Image</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source image to blit from</td></tr>
    <tr><td class="paramname">dest</td><td>Destination image to blit in to</td></tr>
    <tr><td class="paramname">srcLayout</td><td>layout of the source image subresources for the blit</td></tr>
    <tr><td class="paramname">dstLayout</td><td>Layout of the destination image subresources for the blit</td></tr>
    <tr><td class="paramname">regions</td><td>An array of regions to blit</td></tr>
    <tr><td class="paramname">numRegions</td><td>Number of regions</td></tr>
    <tr><td class="paramname">filter</td><td>Sampler Filter to apply if the blits require scaling</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f2535755a017951dd67eb6df7569e78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>releaseAllResources</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the command queue. It is invalid to clear the command buffer while it is being recorded. </p>

</div>
</div>
<a class="anchor" id="a9efc4189a71a18db50301e1e26b7b504"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearColorAttachment </td>
          <td>(</td>
          <td class="paramtype">uint32 const *&#160;</td>
          <td class="paramname"><em>attachmentIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4 const *&#160;</td>
          <td class="paramname"><em>clearColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>attachmentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rectanglei *&#160;</td>
          <td class="paramname"><em>rects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>layerCounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>rectCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear multiple attachments with separate clear colors and clear rectangle for each. NOTE: This clear operation must be called inside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentIndices</td><td>Current subpass color attachment binding indices to clear.</td></tr>
    <tr><td class="paramname">clearColors</td><td>An array of colors to clear to, each corresponding to an attachment</td></tr>
    <tr><td class="paramname">attachmentCount</td><td>Number of attachments to clear</td></tr>
    <tr><td class="paramname">rects</td><td>An array of rectangles, each corresponding to the clear area of an attachment</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>An array of base array layers corresponding to the first layer to be cleared for the attachment</td></tr>
    <tr><td class="paramname">layerCounts</td><td>An array of layer counts corresponding to number of layers to clear for the attachment</td></tr>
    <tr><td class="paramname">rectCount</td><td>The number of rectangles to clear (the number of rectangles in <em>rects</em> )</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a145b815bfacb166db9d9b1e2294a0053"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearColorAttachment </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>attachmentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rectanglei&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>layerCount</em> = <code>1u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a color attachment. NOTE: This clear operation must be called inside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentIndex</td><td>Current subpass color attachment binding index to clear.</td></tr>
    <tr><td class="paramname">clearColor</td><td>The color to which to clear</td></tr>
    <tr><td class="paramname">rect</td><td>The rectangle to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>The array layer corresponding to the first layer to be cleared for the attachment </td></tr>
    <tr><td class="paramname">layerCount</td><td>The number of layers to clear for the attachment</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17338a8346b0a574532e6a7b5bab9400"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearColorAttachment </td>
          <td>(</td>
          <td class="paramtype">api::Fbo&#160;</td>
          <td class="paramname"><em>fbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>clearColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all attachment for a single fbo with a single clear color. NOTE: This clear operation must be called inside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbo</td><td>The fbo to clear attachments</td></tr>
    <tr><td class="paramname">clearColor</td><td>The clear area</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82a4fc7aec52d357cc5b45f57d146418"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearColorImage </td>
          <td>(</td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>baseMipLevel</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>levelCount</em> = <code>1u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>layerCount</em> = <code>1u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em> = <code>types::ImageLayout::General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the specified color image using the clear color specified. NOTE: This clear operation must be called outside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image to clear</td></tr>
    <tr><td class="paramname">layout</td><td>The layout of the image</td></tr>
    <tr><td class="paramname">clearColor</td><td>The clear color to use for the clear</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>base mip levels</td></tr>
    <tr><td class="paramname">levelCount</td><td>level counts</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>base array layers</td></tr>
    <tr><td class="paramname">layerCount</td><td>number of layers to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c882100d42cc4b9cdc83c6d73fa3e3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearColorImage </td>
          <td>(</td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>levelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>rangeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em> = <code>types::ImageLayout::General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears rangeCount sub resource ranges of the specified color image using the clear color specified. NOTE: This clear operation must be called outside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image to clear</td></tr>
    <tr><td class="paramname">layout</td><td>The layout of the image</td></tr>
    <tr><td class="paramname">clearColor</td><td>The clear color to use for the clear</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>rangeCount base mip levels</td></tr>
    <tr><td class="paramname">levelCount</td><td>rangeCount level counts</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>rangeCount base array layers</td></tr>
    <tr><td class="paramname">layerCount</td><td>rangeCount number of layers to clear</td></tr>
    <tr><td class="paramname">rangeCount</td><td>The number of sub resource ranges to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0ba43f43ffa0b49b9f6bf2321d3d1c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearDepthAttachment </td>
          <td>(</td>
          <td class="paramtype">const Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>clearRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the depth attachment of an fbo. NOTE: This clear operation must be called inside the render pass </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearRect</td><td>The clear area</td></tr>
    <tr><td class="paramname">depth</td><td>The clear value</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac34af62437abb4ec58407b0cdf66e236"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearDepthImage </td>
          <td>(</td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>baseMipLevel</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>levelCount</em> = <code>1u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>layerCount</em> = <code>1u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em> = <code>types::ImageLayout::General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the specified depth image using the clear depth color specified. NOTE: This clear operation must be called outside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image to clear</td></tr>
    <tr><td class="paramname">layout</td><td>The layout of the image</td></tr>
    <tr><td class="paramname">clearDepth</td><td>The clear color to use for the clear</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>base mip levels</td></tr>
    <tr><td class="paramname">levelCount</td><td>level counts</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>base array layer</td></tr>
    <tr><td class="paramname">layerCount</td><td>number of layers to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af94096a45591eed976e3c189e4fa16c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearDepthImage </td>
          <td>(</td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>levelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>rangeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em> = <code>types::ImageLayout::General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears rangeCount sub resource ranges of the specified depth image using the clear depth color specified. NOTE This clear operation must be called outside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image to clear</td></tr>
    <tr><td class="paramname">layout</td><td>The layout of the image</td></tr>
    <tr><td class="paramname">clearDepth</td><td>The clear color to use for the clear</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>rangeCount base mip levels</td></tr>
    <tr><td class="paramname">levelCount</td><td>rangeCount level counts</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>rangeCount base array layers</td></tr>
    <tr><td class="paramname">layerCount</td><td>rangeCount number of layers to clear</td></tr>
    <tr><td class="paramname">rangeCount</td><td>The number of sub resource ranges to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a4cab34eba3d7df92ada9bf8ab2e5df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearDepthStencilAttachment </td>
          <td>(</td>
          <td class="paramtype">const Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>clearRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the depth stencil attachment</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearRect</td><td>clear area</td></tr>
    <tr><td class="paramname">depth</td><td>The depth clear value</td></tr>
    <tr><td class="paramname">stencil</td><td>The stencil clear value</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2c27570a5619317f93d8dde85c1dad5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearDepthStencilImage </td>
          <td>(</td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>baseMipLevel</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>levelCount</em> = <code>1u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>layerCount</em> = <code>1u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em> = <code>types::ImageLayout::General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the specified depth stencil image using the clear depth and stencil color specified. NOTE: This clear operation must be called outside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image to clear</td></tr>
    <tr><td class="paramname">layout</td><td>The layout of the image</td></tr>
    <tr><td class="paramname">clearDepth</td><td>The clear depth color to use for the clear</td></tr>
    <tr><td class="paramname">clearStencil</td><td>The clear color to use for the clear</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>base mip levels</td></tr>
    <tr><td class="paramname">levelCount</td><td>level counts</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>base array layers</td></tr>
    <tr><td class="paramname">layerCount</td><td>number of layers to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a840fc7fdea26889bab025876e876a6b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearDepthStencilImage </td>
          <td>(</td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>levelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>rangeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em> = <code>types::ImageLayout::General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears rangeCount sub resource ranges of the specified depth stencil image using the clear depth and stencil color specified. NOTE: This clear operation must be called outside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image to clear</td></tr>
    <tr><td class="paramname">layout</td><td>The layout of the image</td></tr>
    <tr><td class="paramname">clearDepth</td><td>The clear depth color to use for the clear</td></tr>
    <tr><td class="paramname">clearStencil</td><td>The clear color to use for the clear</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>rangeCount base mip levels</td></tr>
    <tr><td class="paramname">levelCount</td><td>rangeCount level counts</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>rangeCount base array layers</td></tr>
    <tr><td class="paramname">layerCount</td><td>rangeCount number of layers to clear</td></tr>
    <tr><td class="paramname">rangeCount</td><td>The number of sub resource ranges to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ada2b65ca439623e7a48a68d1291dce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearStencilAttachment </td>
          <td>(</td>
          <td class="paramtype">const Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>clearRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the stencil attachment of an fbo. NOTE: This clear operation must be called inside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearRect</td><td>The clear area</td></tr>
    <tr><td class="paramname">stencil</td><td>The clear value</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59c67e5c58a68ec6753b55aaa6fd757d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearStencilImage </td>
          <td>(</td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>baseMipLevel</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>levelCount</em> = <code>1u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>layerCount</em> = <code>1u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em> = <code>types::ImageLayout::General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the specified stencil image using the clear stencil color specified. NOTE This clear operation must be called outside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image to clear</td></tr>
    <tr><td class="paramname">layout</td><td>The layout of the image</td></tr>
    <tr><td class="paramname">clearStencil</td><td>The clear color to use for the clear</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>base mip levels</td></tr>
    <tr><td class="paramname">levelCount</td><td>level counts</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>base array layers</td></tr>
    <tr><td class="paramname">layerCount</td><td>number of layers to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c80f839ba5eff8143dc8b284aaa9557"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearStencilImage </td>
          <td>(</td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>levelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>rangeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em> = <code>types::ImageLayout::General</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears rangeCount sub resource ranges of the specified stencil image using the clear stencil color specified. NOTE: This clear operation must be called outside the render pass</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image to clear</td></tr>
    <tr><td class="paramname">layout</td><td>The layout of the image</td></tr>
    <tr><td class="paramname">clearStencil</td><td>The clear color to use for the clear</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>rangeCount base mip levels</td></tr>
    <tr><td class="paramname">levelCount</td><td>rangeCount level counts</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>rangeCount base array layers</td></tr>
    <tr><td class="paramname">layerCount</td><td>rangeCount number of layers to clear</td></tr>
    <tr><td class="paramname">rangeCount</td><td>The number of sub resource ranges to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20f74e975c767fa54c80ede3e2bd20ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::copyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>srcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>destOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source buffer to copy from</td></tr>
    <tr><td class="paramname">dest</td><td>Destination buffer to copy in to</td></tr>
    <tr><td class="paramname">srcOffset</td><td>Source buffer offset</td></tr>
    <tr><td class="paramname">destOffset</td><td>Destination buffer offset</td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>Data size in bytes</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ce1c73dd20392b3e8e28d16548f2041"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::copyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype">api::TextureStore &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ImageLayout&#160;</td>
          <td class="paramname"><em>srcImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::BufferImageCopy *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numRegions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy image to a buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>Source image to copy from</td></tr>
    <tr><td class="paramname">srcImageLayout</td><td>Layout of the source image subresources for the copy</td></tr>
    <tr><td class="paramname">dstBuffer</td><td><a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> to copy into</td></tr>
    <tr><td class="paramname">regions</td><td>An array of regions to copy</td></tr>
    <tr><td class="paramname">numRegions</td><td>Number of regions in the array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd746bf34236572a51b9a961238f06fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::dispatchCompute </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numGroupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numGroupsY</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numGroupsZ</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues a ComputeShader execution using the ComputeShader that is in the currently bound ComputePipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numGroupsX</td><td>The number of workgroups enqueued in the X direction.</td></tr>
    <tr><td class="paramname">numGroupsY</td><td>The number of workgroups enqueued in the Y direction (default 1).</td></tr>
    <tr><td class="paramname">numGroupsZ</td><td>The number of workgroups enqueued in the Z direction (default 1).</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2579355a81b3bc07666f46b2bbe32d89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::dispatchRays </td>
          <td>(</td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>xOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>yOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>frameWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>frameHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a frame shader for each pixel in the box [x, y, x+width, y+height].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xOffset</td><td>The offset for the x axis.</td></tr>
    <tr><td class="paramname">yOffset</td><td>The offset for the y axis.</td></tr>
    <tr><td class="paramname">frameWidth</td><td>Specifies the number of pixels in the x axis.</td></tr>
    <tr><td class="paramname">frameHeight</td><td>Specifies the number of pixels in the y axis.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80d3e332d34f8c1838f929f9dfbcf5cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::drawArrays </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Does not use an IndexBuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstVertex</td><td>The vertex from where to start drawing</td></tr>
    <tr><td class="paramname">vertexCount</td><td>The number of vertices to draw</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The Instance from which to draw from</td></tr>
    <tr><td class="paramname">instanceCount</td><td>The number of instances to draw</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0578ef087e598e0222fb15c7e86ee3b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::drawArraysIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>drawCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>drawArraysIndirect</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> containing draw parameters. The parameters of each draw must be encoded in an array of DrawIndirectCmd structures</td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes in the buffer where draw parameters begin</td></tr>
    <tr><td class="paramname">drawCount</td><td>Number of draws to execute, can be zero. If the the drawCount is greater than 1 then the stride must be multiple of 4.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride in byte between sets of draw parameters</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fa3b2218d55301095a4664d7d56586c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vertexOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Uses the currently bound IndexBuffer for indexes into the currently bound VBOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstIndex</td><td>Offset into the Index buffer to start drawing from</td></tr>
    <tr><td class="paramname">indexCount</td><td>The number of indexes to draw</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>Index into the Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> to start drawing from</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The Instance from which to draw from</td></tr>
    <tr><td class="paramname">instanceCount</td><td>The number of instances to draw</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49007f7233b526cf8e240d6649eac83f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::drawIndexedIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indirect Draw command. Use buffer to obtain the draw call parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer containing the draw call parameters in the form of a DrawIndexedIndirectCommand</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba30e81cac9351a93f2cae4e26b85d3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::drawIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This draw command behaves similarly to drawArray except that the parameters are read by the device from a buffer during execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td><a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> which contains the parameters.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset in to the buffer where parameters begin</td></tr>
    <tr><td class="paramname">count</td><td>Number of draws to execute, and can be zero</td></tr>
    <tr><td class="paramname">stride</td><td>Byte stride between successive sets of draw parameters</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33b0f42c3c3fc27de7401436383b1e97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::endRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function when you are done recording commands. BeginRecording must be called first. </p>

</div>
</div>
<a class="anchor" id="aa99c6e34e5bf7ecabe44d49b267c4da2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::endSceneHierarchy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends the recording of scene hierarchy generation commands.</p>

</div>
</div>
<a class="anchor" id="adda7dfc8e8c31b9508daac194f48a557"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GraphicsContext&amp; pvr::api::impl::CommandBufferBase_::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the context used by this CommandBuffer.</p>

</div>
</div>
<a class="anchor" id="a81ab01539119a2d4c9d629e46aec6e03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::impl::CommandBufferBase_::isRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries if a command buffer is in the recording state</p>
<dl class="section return"><dt>Returns</dt><dd>True if recording, false otherwise</dd></dl>

</div>
</div>
<a class="anchor" id="a6d0c00c0a250dbe0c8aa0b9482d01549"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::mergeSceneHierarchies </td>
          <td>(</td>
          <td class="paramtype">const SceneHierarchy &amp;&#160;</td>
          <td class="paramname"><em>destinationSceneHierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::math::AxisAlignedBox &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SceneHierarchy *&#160;</td>
          <td class="paramname"><em>sourceSceneHierarchies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvr::uint32&#160;</td>
          <td class="paramname"><em>numberOfSourceSceneHierarchies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvr::uint32&#160;</td>
          <td class="paramname"><em>mergeQuality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges a number of scene hierarchies into a single merged hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destinationSceneHierarchy</td><td>The scene hierarchy which will be target of the merge.</td></tr>
    <tr><td class="paramname">extents</td><td>The scene hierarchy extents to use when merging the hierarchy.</td></tr>
    <tr><td class="paramname">sourceSceneHierarchies</td><td>The source hierarchies to use in the merge.</td></tr>
    <tr><td class="paramname">numberOfSourceSceneHierarchies</td><td>The number of source hierarchies to use in the merge.</td></tr>
    <tr><td class="paramname">mergeQuality</td><td>The merge quality to use (Ranges between 0 and 1).</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5506e55f62155f1d81a8dc436ace5d84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::pipelineBarrier </td>
          <td>(</td>
          <td class="paramtype">types::PipelineStageFlags&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::PipelineStageFlags&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependencyByRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed.</p>

</div>
</div>
<a class="anchor" id="a3c9aabed41319304de1f36ad4b5b7026"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::popPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the previously pushed pipeline (See pushGraphicsPipeline)</p>

</div>
</div>
<a class="anchor" id="a82fada6bcf071b51e17f17d525bc9ba5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::pushPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store which pipeline is currently bound, so that it can later be retrieved and bound with a popPipeline command.</p>

</div>
</div>
<a class="anchor" id="aa0a759341fd752a954ca56ca3aa35266"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::pushSharedRayConstants </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push shared ray constant data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset into the ray constant data.</td></tr>
    <tr><td class="paramname">size</td><td>The size of ray constant data.</td></tr>
    <tr><td class="paramname">pValues</td><td>The data to use as shared ray data.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab09862df3dc41a6813b8c8841694221d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::resetPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>INTERNAL. reset the currently bound pipeline.</p>

</div>
</div>
<a class="anchor" id="ad43fb0991e490a512bd4968ca267616c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::sceneHierarchyAppend </td>
          <td>(</td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>instanceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>firstVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>firstInstance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends geometry for use in scene hierarchy building.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexCount</td><td>The number of vertices.</td></tr>
    <tr><td class="paramname">instanceCount</td><td>The number of instances.</td></tr>
    <tr><td class="paramname">firstVertex</td><td>The first vertex.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The first instance.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8739f9eba083eff664bb47968efd84f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::sceneHierarchyAppendIndexed </td>
          <td>(</td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>instanceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>vertexOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>firstInstance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends indexed geometry for use in scene hierarchy building.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexCount</td><td>The number of indices.</td></tr>
    <tr><td class="paramname">instanceCount</td><td>The number of instances.</td></tr>
    <tr><td class="paramname">firstIndex</td><td>The first index.</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>The vertex offset.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The first instance.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25ba580bbf18f9f8e56276fa5d417c74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::sceneHierarchyAppendIndexedIndirect </td>
          <td>(</td>
          <td class="paramtype">pvr::api::BufferView &amp;&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>drawCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indirectly appends indexed geometry for use in scene hierarchy building.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indirectBuffer</td><td>The buffer to use as the source of indirect information.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the buffer.</td></tr>
    <tr><td class="paramname">drawCount</td><td>The number of draws.</td></tr>
    <tr><td class="paramname">stride</td><td>The stride used in the buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a815271c5a31617cb98872bf10b855442"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::sceneHierarchyAppendIndirect </td>
          <td>(</td>
          <td class="paramtype">pvr::api::BufferView &amp;&#160;</td>
          <td class="paramname"><em>indirectBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>drawCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indirectly appends geometry for use in scene hierarchy building.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indirectBuffer</td><td>The buffer to use as the source of indirect information.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the buffer.</td></tr>
    <tr><td class="paramname">drawCount</td><td>The number of draws.</td></tr>
    <tr><td class="paramname">stride</td><td>The stride used in the buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfefa9d65cd7b481c628517cbbb5f6c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setBlendConstants </td>
          <td>(</td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>rgba</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set blend constants for blend operation using constant colors</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgba</td><td>Red Green Blue Alpha blend constant</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaafcdc7cdcdbce966593ff8b9f4f5a27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setDepthBias </td>
          <td>(</td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>depthBiasConstantFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>depthBiasClamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>depthBiasSlopeFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a dynamic command which controll the offset of depth values of all fragments generated by the rasterization of a polygon. NOTE: If depthBiasEnable is set to false in <a class="el" href="structpvr_1_1api_1_1pipeline_creation_1_1_raster_state_create_param.html" title="Pipeline Rasterisation, clipping and culling state configuration. Culling, winding order...">pipelineCreation::RasterStateCreateParam</a> then no depth bias is applied and the fragment's depth values are unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthBiasConstantFactor</td><td>Scalar factor controlling the constant depth value added to each fragment. </td></tr>
    <tr><td class="paramname">depthBiasClamp</td><td>Maximum or minimum depth bias of a fragment</td></tr>
    <tr><td class="paramname">depthBiasSlopeFactor</td><td>Scalar factor applied to a fragment's slope in depth bias calculations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98dcda0cde4b373682c2a908649cd1a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setDepthBound </td>
          <td>(</td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>min</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>max</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set minimum and maximum depth</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum depth (default 0.0f)</td></tr>
    <tr><td class="paramname">max</td><td>Maximum depth (default 1.0f)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5486b945bb413470d37961d19b6c2732"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setLineWidth </td>
          <td>(</td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>lineWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the line width</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lineWidth</td><td>the new width of lines drawn</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff4c107d37232266c3e3e7744c5250bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setRayBounceLimit </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the ray bounce limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The maximum number of times any ray may bounce in a renderpass.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa36750f46eb10f52389aab772a97c7f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setRaySizes </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>raySizeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>pRaySizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the sizes of rays used in a renderpass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raySizeCount</td><td>The number of ray sizes.</td></tr>
    <tr><td class="paramname">pRaySizes</td><td>The size of ray user data.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfde75092656782a733986836aa14c35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setScissor </td>
          <td>(</td>
          <td class="paramtype">const Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>scissor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scissor rectangle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scissor</td><td>The scissor rectangle</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c2f968a5744aa0b91918c92fc49e763"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setStencilCompareMask </td>
          <td>(</td>
          <td class="paramtype">types::StencilFace&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>compareMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the stencil comparison mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The face/faces for which to set the stencil mask</td></tr>
    <tr><td class="paramname">compareMask</td><td>A uint32 which will mask both the values and the reference before stencil comparisons</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7f204d1a61924a5559c0cbdec039af3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setStencilReference </td>
          <td>(</td>
          <td class="paramtype">types::StencilFace&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set stencil reference value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The face/faces for which to set the stencil reference value</td></tr>
    <tr><td class="paramname">ref</td><td>The stencil reference value</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52ceab439157fc658f32552f50963bd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setStencilWriteMask </td>
          <td>(</td>
          <td class="paramtype">types::StencilFace&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>writeMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the stencil write mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The face/faces for which to set the stencil write mask</td></tr>
    <tr><td class="paramname">writeMask</td><td>A uint32 which will mask the values when writing the stencil</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b02946cb8a720619381e395fdb20aa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="ac909e5e03cdcfc6100c4fdf02a48d5cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="ad8aec90c4019deeb6d8db43a37c5579c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float32 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a6b4c093621d382784f8e2406731e84ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec2 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a3285ce1e6df5eabe0984c0cc0d0aeb6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::ivec2 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="af551b190c46874c6b68639ebf4cb462f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::uvec2 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a991c4e11cae022d3ff9cb6bcca54bef8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a162d0a010bdb15d09c383d12b551601c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::ivec3 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a9ee6239a34140b5daa677b2eef9aebc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::uvec3 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="aea93b97c839ff1826737ee39e849a892"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a28cece054dcbe7348a35aa1ac7478c1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::ivec4 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a52de50d45c0d4b288dab63b793a9cbb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::uvec4 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="abda906d610351a5f04cf17d3dfe00e63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat2 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a16bb24f25d814b9f41f9afae9bd8a989"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat2x3 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a59f2cc5275071ab09813c331c7f741de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat2x4 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a8fa548a85f2cb7bafec11ecddd91204f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat3x2 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a9d3470ff11bcf88d07724f67de6f0e6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat3 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="ae8d43dff8b5653d7980f8d520fe92e93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat3x4 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="ac046512c225f69b60db50e6ae30d7d64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x2 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a73b7a7a69ad282b8b5ca750d41800635"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x3 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a760f42bdb4a38ca6c9de0e02d9344117"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<p>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr.</p>

</div>
</div>
<a class="anchor" id="a22aadd54bea402313ed21e3260328d40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a9f7062b2d4a6ca4973bd7b054a112f58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a54d54db440cf087f040bbda86e5e95a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float32 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a6baa3038d44b3a7e3e870f3a10fbae71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec2 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="af82486522419a41265f9f8df4789bb0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::ivec2 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a1e3dcb29504db57df1b5c6b256414cb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::uvec2 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a050b1a9a98049382acca50937c758bce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a73da778d67c9a32f44a9bf0e119e4b8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::ivec3 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a8d9ddd0b0a8a6acc46c071ede9ecac97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::uvec3 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="ad4b085146682c8f9c18e5030dfebb892"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="ad10b47337b55eeb12c3de0d914404de6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::ivec4 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a6f47a63f71756adbbf4f0adb6d1bd701"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::uvec4 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a81f40c7c2c51ca3f5413a3e58f9386ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat2 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a10591384fe73401fba7c6f70c5290802"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat2x3 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a603d52631827f45e4acf442296ee4fcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat2x4 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a8ea89274467964db30e970b35249c505"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat3x2 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="ab4f13dd6a2743bc17aeb6a93a4e6c6ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat3 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="adb30f6a0f833293f9025a9c6f22c15c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat3x4 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="ace0b2a199cf6bc391b4451817a68b648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x2 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="ad0ac7522a204fedebac5530c4788dba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x3 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="a941bcb3e189792e13fe4bca6eddb41f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x4 *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported.</p>

</div>
</div>
<a class="anchor" id="adf768f84801a0915feef75a926f12e3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setViewport </td>
          <td>(</td>
          <td class="paramtype">const Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>viewport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the viewport rectangle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>The viewport rectangle</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4d3a922739e0a25c2118766f40d9842"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::updateBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to update</td></tr>
    <tr><td class="paramname">offset</td><td>Offset in the buffer updates begin</td></tr>
    <tr><td class="paramname">length</td><td><a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> update length</td></tr>
    <tr><td class="paramname">data</td><td>New update data.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRApi/ApiObjects/<a class="el" href="_command_buffer_8h_source.html">CommandBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
