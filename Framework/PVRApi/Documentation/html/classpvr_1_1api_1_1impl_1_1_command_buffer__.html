<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRApi: pvr::api::impl::CommandBuffer_ Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRApi</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pvr</b></li><li class="navelem"><b>api</b></li><li class="navelem"><b>impl</b></li><li class="navelem"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html">CommandBuffer_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1api_1_1impl_1_1_command_buffer__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::api::impl::CommandBuffer_ Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer.  
 <a href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::api::impl::CommandBuffer_:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1api_1_1impl_1_1_command_buffer____inherit__graph.png" border="0" usemap="#pvr_1_1api_1_1impl_1_1_command_buffer___inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1api_1_1impl_1_1_command_buffer___inherit__map" id="pvr_1_1api_1_1impl_1_1_command_buffer___inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline..." alt="" coords="8,6,207,47"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1cedcb377db3dce30f5527c1d7b083ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a1cedcb377db3dce30f5527c1d7b083ba">beginRecording</a> ()</td></tr>
<tr class="memdesc:a1cedcb377db3dce30f5527c1d7b083ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands. <a href="#a1cedcb377db3dce30f5527c1d7b083ba">More...</a><br/></td></tr>
<tr class="separator:a1cedcb377db3dce30f5527c1d7b083ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a05b346e2fdf90c782d92000666ed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a34a05b346e2fdf90c782d92000666ed4">beginRenderPass</a> (api::Fbo &amp;fbo, const Rectanglei &amp;renderArea, bool inlineFirstSubpass, const glm::vec4 &amp;clearColor=glm::vec4(0.0f, 0.0f, 0.0f, 1.0f), float32 clearDepth=1.f, uint32 clearStencil=0)</td></tr>
<tr class="memdesc:a34a05b346e2fdf90c782d92000666ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a RenderPass, i.e. binding an FBO and preparing to draw into it. Executes the LoadOp. <a href="#a34a05b346e2fdf90c782d92000666ed4">More...</a><br/></td></tr>
<tr class="separator:a34a05b346e2fdf90c782d92000666ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466d4e39dfedb9a7c0b546fdd822ca96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a466d4e39dfedb9a7c0b546fdd822ca96">beginRenderPass</a> (api::Fbo &amp;fbo, const Rectanglei &amp;renderArea, bool inlineFirstSubpass, const glm::vec4 *clearColors, uint32 numClearColors, float32 clearDepth=1.f, uint32 clearStencil=0)</td></tr>
<tr class="memdesc:a466d4e39dfedb9a7c0b546fdd822ca96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a RenderPass, i.e. binding an FBO and preparing to draw into it. Executes the LoadOp. <a href="#a466d4e39dfedb9a7c0b546fdd822ca96">More...</a><br/></td></tr>
<tr class="separator:a466d4e39dfedb9a7c0b546fdd822ca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa7a78c3f3953897780e1edbebfe8df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#acaa7a78c3f3953897780e1edbebfe8df">beginRenderPass</a> (api::Fbo &amp;fbo, bool inlineFirstSubpass, const glm::vec4 &amp;clearColor=glm::vec4(0.0f, 0.0f, 0.0f, 1.0f), float32 clearDepth=1.f, uint32 clearStencil=0)</td></tr>
<tr class="memdesc:acaa7a78c3f3953897780e1edbebfe8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a renderPass i.e. binding an FBO and preparing to draw into it. Executes the LoadOp. <a href="#acaa7a78c3f3953897780e1edbebfe8df">More...</a><br/></td></tr>
<tr class="separator:acaa7a78c3f3953897780e1edbebfe8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fe825910dfb23e466cb30767a78a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#ad6fe825910dfb23e466cb30767a78a82">beginRenderPass</a> (api::Fbo &amp;fbo, const RenderPass &amp;renderPass, const Rectanglei &amp;renderArea, bool inlineFirstSubpass, const glm::vec4 &amp;clearColor=glm::vec4(0.0f, 0.0f, 0.0f, 1.0f), float32 clearDepth=1.f, uint32 clearStencil=0)</td></tr>
<tr class="memdesc:ad6fe825910dfb23e466cb30767a78a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a renderPass i.e. binding an FBO and preparing to draw into it. Executes the LoadOp. <a href="#ad6fe825910dfb23e466cb30767a78a82">More...</a><br/></td></tr>
<tr class="separator:ad6fe825910dfb23e466cb30767a78a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2182275cd1ff938b675925e72601de55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a2182275cd1ff938b675925e72601de55">beginRenderPass</a> (api::Fbo &amp;fbo, const api::RenderPass &amp;renderPass, const Rectanglei &amp;renderArea, bool inlineFirstSubpass, const glm::vec4 *clearColors, uint32 numClearColors, float32 *clearDepth, uint32 *clearStencil, uint32 numClearDepthStencil)</td></tr>
<tr class="memdesc:a2182275cd1ff938b675925e72601de55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a renderPass i.e. binding an FBO and preparing to draw into it. Executes the LoadOp. <a href="#a2182275cd1ff938b675925e72601de55">More...</a><br/></td></tr>
<tr class="separator:a2182275cd1ff938b675925e72601de55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee35971cf7681a41986c21edfe9792c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#aee35971cf7681a41986c21edfe9792c4">beginRenderPass</a> (api::Fbo &amp;fbo, const api::RenderPass &amp;renderPass, bool inlineFirstSubpass, const glm::vec4 &amp;clearColor=glm::vec4(0.0f, 0.0f, 0.0f, 1.0f), float32 clearDepth=1.f, uint32 clearStencil=0)</td></tr>
<tr class="memdesc:aee35971cf7681a41986c21edfe9792c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a renderPass i.e. binding an FBO and preparing to draw into it. Executes the LoadOp. <a href="#aee35971cf7681a41986c21edfe9792c4">More...</a><br/></td></tr>
<tr class="separator:aee35971cf7681a41986c21edfe9792c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76aaf2b2e03afa5529120210c27ab63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#aa76aaf2b2e03afa5529120210c27ab63">endRenderPass</a> ()</td></tr>
<tr class="memdesc:aa76aaf2b2e03afa5529120210c27ab63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish the a renderpass (executes the StoreOp). <a href="#aa76aaf2b2e03afa5529120210c27ab63">More...</a><br/></td></tr>
<tr class="separator:aa76aaf2b2e03afa5529120210c27ab63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e91bbcad5923769b728a3dada16569c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a9e91bbcad5923769b728a3dada16569c">enqueueSecondaryCmds</a> (SecondaryCommandBuffer &amp;secondaryCmdBuffer)</td></tr>
<tr class="memdesc:a9e91bbcad5923769b728a3dada16569c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record commands from the secondary command buffer. <a href="#a9e91bbcad5923769b728a3dada16569c">More...</a><br/></td></tr>
<tr class="separator:a9e91bbcad5923769b728a3dada16569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58179c8c6af004fe1f1914fb15949a52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a58179c8c6af004fe1f1914fb15949a52">enqueueSecondaryCmds</a> (SecondaryCommandBuffer *secondaryCmdBuffers, uint32 numCmdBuffers)</td></tr>
<tr class="memdesc:a58179c8c6af004fe1f1914fb15949a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record commands from an array of secondary command buffer <a href="#a58179c8c6af004fe1f1914fb15949a52">More...</a><br/></td></tr>
<tr class="separator:a58179c8c6af004fe1f1914fb15949a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc500578fe832db59d2218e4202221d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#acc500578fe832db59d2218e4202221d1">enqueueSecondaryCmds_BeginMultiple</a> (uint32 expectedMax=255)</td></tr>
<tr class="memdesc:acc500578fe832db59d2218e4202221d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record commands from an secondary command buffer. Multiple enqueueing mode. This is an optimized version where the user is expected to be enqueueing multiple secondary command buffers, but does not necessarily immediately have them available. <a href="#acc500578fe832db59d2218e4202221d1">More...</a><br/></td></tr>
<tr class="separator:acc500578fe832db59d2218e4202221d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2598b34fd3ae7c8ea0b7c391b6880c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a2598b34fd3ae7c8ea0b7c391b6880c8e">enqueueSecondaryCmds_EnqueueMultiple</a> (SecondaryCommandBuffer *secondaryCmdBuffers, uint32 numCmdBuffers)</td></tr>
<tr class="memdesc:a2598b34fd3ae7c8ea0b7c391b6880c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect commands for the multiple enqueueing mode. Must be called after enqueueSecondaryCmds_BeginMultiple.  <a href="#a2598b34fd3ae7c8ea0b7c391b6880c8e">More...</a><br/></td></tr>
<tr class="separator:a2598b34fd3ae7c8ea0b7c391b6880c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4b4806a8865bc921a048a1fad2d5dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#acf4b4806a8865bc921a048a1fad2d5dd">enqueueSecondaryCmds_SubmitMultiple</a> (bool keepAllocated=false)</td></tr>
<tr class="memdesc:acf4b4806a8865bc921a048a1fad2d5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit the commands collected in multiple enqueueing mode. <a href="#acf4b4806a8865bc921a048a1fad2d5dd">More...</a><br/></td></tr>
<tr class="separator:acf4b4806a8865bc921a048a1fad2d5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7f186ed42ca969457fa56ea6182785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#acb7f186ed42ca969457fa56ea6182785">nextSubPassInline</a> ()</td></tr>
<tr class="memdesc:acb7f186ed42ca969457fa56ea6182785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin recording commands for the next surpass in this render pass. <a href="#acb7f186ed42ca969457fa56ea6182785">More...</a><br/></td></tr>
<tr class="separator:acb7f186ed42ca969457fa56ea6182785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bff4073bfe107dfcb89a9bc99ee7f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a74bff4073bfe107dfcb89a9bc99ee7f1">nextSubPassSecondaryCmds</a> (SecondaryCommandBuffer &amp;cmdBuffer)</td></tr>
<tr class="memdesc:a74bff4073bfe107dfcb89a9bc99ee7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record next sub pass commands from a secondary-commandbuffer. <a href="#a74bff4073bfe107dfcb89a9bc99ee7f1">More...</a><br/></td></tr>
<tr class="separator:a74bff4073bfe107dfcb89a9bc99ee7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d103ff34e335e312c25680cb2f7562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a63d103ff34e335e312c25680cb2f7562">submit</a> (const Semaphore &amp;waitSemaphore, const Semaphore &amp;signalSemaphore, const Fence &amp;fence=Fence())</td></tr>
<tr class="memdesc:a63d103ff34e335e312c25680cb2f7562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit this command buffer to the GPU <a href="#a63d103ff34e335e312c25680cb2f7562">More...</a><br/></td></tr>
<tr class="separator:a63d103ff34e335e312c25680cb2f7562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d352142dca558ea5c25d90775f2055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#ac9d352142dca558ea5c25d90775f2055">submit</a> (SemaphoreSet &amp;waitSemaphores, SemaphoreSet &amp;signalSemaphores, const Fence &amp;fence=Fence())</td></tr>
<tr class="memdesc:ac9d352142dca558ea5c25d90775f2055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit this command buffer to the GPU <a href="#ac9d352142dca558ea5c25d90775f2055">More...</a><br/></td></tr>
<tr class="separator:ac9d352142dca558ea5c25d90775f2055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41eaf80ca9434f765c3fbb4b6d3c3b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a41eaf80ca9434f765c3fbb4b6d3c3b99">submit</a> (Fence &amp;fence)</td></tr>
<tr class="memdesc:a41eaf80ca9434f765c3fbb4b6d3c3b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit this command buffer to the GPU <a href="#a41eaf80ca9434f765c3fbb4b6d3c3b99">More...</a><br/></td></tr>
<tr class="separator:a41eaf80ca9434f765c3fbb4b6d3c3b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb83b1103f00b5921bea30a8e53505c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a8eb83b1103f00b5921bea30a8e53505c">submit</a> ()</td></tr>
<tr class="memdesc:a8eb83b1103f00b5921bea30a8e53505c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit this command buffer to the GPU <a href="#a8eb83b1103f00b5921bea30a8e53505c">More...</a><br/></td></tr>
<tr class="separator:a8eb83b1103f00b5921bea30a8e53505c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eae86fac3f5635df4539b5e7684e5e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#a2eae86fac3f5635df4539b5e7684e5e5">submitEndOfFrame</a> (Semaphore &amp;waitSemaphore)</td></tr>
<tr class="memdesc:a2eae86fac3f5635df4539b5e7684e5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit this command buffer to the GPU <a href="#a2eae86fac3f5635df4539b5e7684e5e5">More...</a><br/></td></tr>
<tr class="separator:a2eae86fac3f5635df4539b5e7684e5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f6ea0f6660de080ef2299e21528984"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html#ac1f6ea0f6660de080ef2299e21528984">submitStartOfFrame</a> (Semaphore &amp;signalSemaphore, const Fence &amp;fence=Fence())</td></tr>
<tr class="memdesc:ac1f6ea0f6660de080ef2299e21528984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit this command buffer to the GPU <a href="#ac1f6ea0f6660de080ef2299e21528984">More...</a><br/></td></tr>
<tr class="separator:ac1f6ea0f6660de080ef2299e21528984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html">pvr::api::impl::CommandBufferBase_</a></td></tr>
<tr class="memitem:a085614fc5885fc5df5ef326e3a3a01ed inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a085614fc5885fc5df5ef326e3a3a01ed">~CommandBufferBase_</a> ()</td></tr>
<tr class="memdesc:a085614fc5885fc5df5ef326e3a3a01ed inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <a href="#a085614fc5885fc5df5ef326e3a3a01ed">More...</a><br/></td></tr>
<tr class="separator:a085614fc5885fc5df5ef326e3a3a01ed inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7d358802ca484e7a8be735b09d83fe inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a7b7d358802ca484e7a8be735b09d83fe">beginSceneHierarchy</a> (const SceneHierarchy &amp;sceneHierarchy, pvr::math::AxisAlignedBox &amp;extents)</td></tr>
<tr class="memdesc:a7b7d358802ca484e7a8be735b09d83fe inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins the recording of scene hierarchy generation commands.  <a href="#a7b7d358802ca484e7a8be735b09d83fe">More...</a><br/></td></tr>
<tr class="separator:a7b7d358802ca484e7a8be735b09d83fe inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c074492d6949ed275a8b45b5c169cc inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a30c074492d6949ed275a8b45b5c169cc">bindAccumulationImages</a> (pvr::uint32 startBinding, pvr::uint32 bindingCount, const TextureView *imageViews)</td></tr>
<tr class="memdesc:a30c074492d6949ed275a8b45b5c169cc inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a number of accumulation images making accumulation to them possible in subsequent commands which dispatch rays. <a href="#a30c074492d6949ed275a8b45b5c169cc">More...</a><br/></td></tr>
<tr class="separator:a30c074492d6949ed275a8b45b5c169cc inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08ef00d0041fe5028502f844fed236c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ab08ef00d0041fe5028502f844fed236c">bindDescriptorSet</a> (const api::PipelineLayout &amp;pipelineLayout, uint32 index, const DescriptorSet &amp;set, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffsets=0)</td></tr>
<tr class="memdesc:ab08ef00d0041fe5028502f844fed236c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet to the Graphics Pipeline binding point <a href="#ab08ef00d0041fe5028502f844fed236c">More...</a><br/></td></tr>
<tr class="separator:ab08ef00d0041fe5028502f844fed236c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36453a83eed132b55306f6a1da75ab66 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a36453a83eed132b55306f6a1da75ab66">bindDescriptorSetCompute</a> (const api::PipelineLayout &amp;pipelineLayout, uint32 index, const DescriptorSet &amp;set, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffsets=0)</td></tr>
<tr class="memdesc:a36453a83eed132b55306f6a1da75ab66 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet to the Compute Pipeline binding point <a href="#a36453a83eed132b55306f6a1da75ab66">More...</a><br/></td></tr>
<tr class="separator:a36453a83eed132b55306f6a1da75ab66 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e7eeacb4ae57ad3acf0bda43cdc42e inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a05e7eeacb4ae57ad3acf0bda43cdc42e">bindDescriptorSetRayTracing</a> (const api::PipelineLayout &amp;pipelineLayout, uint32 index, const DescriptorSet &amp;set, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffsets=0)</td></tr>
<tr class="memdesc:a05e7eeacb4ae57ad3acf0bda43cdc42e inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet to the Ray Tracing Pipeline binding point <a href="#a05e7eeacb4ae57ad3acf0bda43cdc42e">More...</a><br/></td></tr>
<tr class="separator:a05e7eeacb4ae57ad3acf0bda43cdc42e inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1f2311a10d6d592809685bb4383c7d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a8b1f2311a10d6d592809685bb4383c7d">bindDescriptorSets</a> (types::PipelineBindPoint bindingPoint, const api::PipelineLayout &amp;pipelineLayout, uint32 firstSet, const DescriptorSet *sets, uint32 numDescSets, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffsets=0)</td></tr>
<tr class="memdesc:a8b1f2311a10d6d592809685bb4383c7d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind multiple DescriptorSets <a href="#a8b1f2311a10d6d592809685bb4383c7d">More...</a><br/></td></tr>
<tr class="separator:a8b1f2311a10d6d592809685bb4383c7d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4f6de0ca2d21418896d6dff7ff1970 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#afa4f6de0ca2d21418896d6dff7ff1970">bindDescriptorSetSHG</a> (const api::PipelineLayout &amp;pipelineLayout, uint32 index, const DescriptorSet &amp;set, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffsets=0)</td></tr>
<tr class="memdesc:afa4f6de0ca2d21418896d6dff7ff1970 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet to the Scene Hierarchy Generator Pipeline binding point <a href="#afa4f6de0ca2d21418896d6dff7ff1970">More...</a><br/></td></tr>
<tr class="separator:afa4f6de0ca2d21418896d6dff7ff1970 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a42a80f1a60693eff86f37989b0ede0 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a0a42a80f1a60693eff86f37989b0ede0">bindIndexBuffer</a> (const <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;buffer, uint32 offset, types::IndexType indexType)</td></tr>
<tr class="memdesc:a0a42a80f1a60693eff86f37989b0ede0 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an index buffer for drawing <a href="#a0a42a80f1a60693eff86f37989b0ede0">More...</a><br/></td></tr>
<tr class="separator:a0a42a80f1a60693eff86f37989b0ede0 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c52c2e276ce8e0530f1b9367d351be3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3c52c2e276ce8e0530f1b9367d351be3">bindPipeline</a> (GraphicsPipeline pipeline)</td></tr>
<tr class="memdesc:a3c52c2e276ce8e0530f1b9367d351be3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a graphics pipeline. <a href="#a3c52c2e276ce8e0530f1b9367d351be3">More...</a><br/></td></tr>
<tr class="separator:a3c52c2e276ce8e0530f1b9367d351be3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d2777f4821115ac50b28343329bbfa inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ac6d2777f4821115ac50b28343329bbfa">bindPipeline</a> (ComputePipeline &amp;pipeline)</td></tr>
<tr class="memdesc:ac6d2777f4821115ac50b28343329bbfa inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a compute pipeline <a href="#ac6d2777f4821115ac50b28343329bbfa">More...</a><br/></td></tr>
<tr class="separator:ac6d2777f4821115ac50b28343329bbfa inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf97f03e8d635082f1f2368b9224fe8f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adf97f03e8d635082f1f2368b9224fe8f">bindPipeline</a> (SceneTraversalPipeline &amp;pipeline)</td></tr>
<tr class="memdesc:adf97f03e8d635082f1f2368b9224fe8f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a Scene Traversal pipeline <a href="#adf97f03e8d635082f1f2368b9224fe8f">More...</a><br/></td></tr>
<tr class="separator:adf97f03e8d635082f1f2368b9224fe8f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa652603f8ef0cd1955441c6f2eb116 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3aa652603f8ef0cd1955441c6f2eb116">bindPipeline</a> (VertexRayPipeline &amp;pipeline)</td></tr>
<tr class="memdesc:a3aa652603f8ef0cd1955441c6f2eb116 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a Vertex Ray pipeline <a href="#a3aa652603f8ef0cd1955441c6f2eb116">More...</a><br/></td></tr>
<tr class="separator:a3aa652603f8ef0cd1955441c6f2eb116 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035a1c1722d636da391dd7abda4d9aa3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a035a1c1722d636da391dd7abda4d9aa3">bindSceneHierarchies</a> (const SceneHierarchy *sceneHierarchies, pvr::uint32 firstBinding, const pvr::uint32 numberOfSceneHierarchies)</td></tr>
<tr class="memdesc:a035a1c1722d636da391dd7abda4d9aa3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a number of scene hierarchies making it possible to use them in subsequent dispatches. <a href="#a035a1c1722d636da391dd7abda4d9aa3">More...</a><br/></td></tr>
<tr class="separator:a035a1c1722d636da391dd7abda4d9aa3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecde8359a87bb2da46c141974a5c6e16 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aecde8359a87bb2da46c141974a5c6e16">bindVertexBuffer</a> (const <a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer, uint32 offset, uint16 bindingIndex)</td></tr>
<tr class="memdesc:aecde8359a87bb2da46c141974a5c6e16 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> for drawing <a href="#aecde8359a87bb2da46c141974a5c6e16">More...</a><br/></td></tr>
<tr class="separator:aecde8359a87bb2da46c141974a5c6e16 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b052b600d0111a278a203ebb3701c8 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a71b052b600d0111a278a203ebb3701c8">bindVertexBuffer</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> const *buffers, uint32 *offsets, uint16 numBuffers, uint16 startBinding, uint16 bindingCount)</td></tr>
<tr class="memdesc:a71b052b600d0111a278a203ebb3701c8 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an array of Vertex Buffers <a href="#a71b052b600d0111a278a203ebb3701c8">More...</a><br/></td></tr>
<tr class="separator:a71b052b600d0111a278a203ebb3701c8 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16249a7acca496e5604269badc31046d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a16249a7acca496e5604269badc31046d">blitImage</a> (api::TextureStore &amp;src, api::TextureStore &amp;dest, types::ImageLayout srcLayout, types::ImageLayout dstLayout, types::ImageBlitRange *regions, uint32 numRegions, types::SamplerFilter filter)</td></tr>
<tr class="memdesc:a16249a7acca496e5604269badc31046d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blit Image <a href="#a16249a7acca496e5604269badc31046d">More...</a><br/></td></tr>
<tr class="separator:a16249a7acca496e5604269badc31046d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2535755a017951dd67eb6df7569e78 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a7f2535755a017951dd67eb6df7569e78">clear</a> (bool releaseAllResources=false)</td></tr>
<tr class="memdesc:a7f2535755a017951dd67eb6df7569e78 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the command queue. It is invalid to clear the command buffer while it is being recorded.  <a href="#a7f2535755a017951dd67eb6df7569e78">More...</a><br/></td></tr>
<tr class="separator:a7f2535755a017951dd67eb6df7569e78 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efc4189a71a18db50301e1e26b7b504 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a9efc4189a71a18db50301e1e26b7b504">clearColorAttachment</a> (uint32 const *attachmentIndices, glm::vec4 const *clearColors, uint32 attachmentCount, const Rectanglei *rects, const uint32 *baseArrayLayers, const uint32 *layerCounts, uint32 rectCount)</td></tr>
<tr class="memdesc:a9efc4189a71a18db50301e1e26b7b504 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear multiple attachments with separate clear colors and clear rectangle for each. NOTE: This clear operation must be called inside the render pass <a href="#a9efc4189a71a18db50301e1e26b7b504">More...</a><br/></td></tr>
<tr class="separator:a9efc4189a71a18db50301e1e26b7b504 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145b815bfacb166db9d9b1e2294a0053 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a145b815bfacb166db9d9b1e2294a0053">clearColorAttachment</a> (uint32 attachmentIndex, glm::vec4 clearColor, const Rectanglei rect, const uint32 baseArrayLayer=0u, const uint32 layerCount=1u)</td></tr>
<tr class="memdesc:a145b815bfacb166db9d9b1e2294a0053 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a color attachment. NOTE: This clear operation must be called inside the render pass <a href="#a145b815bfacb166db9d9b1e2294a0053">More...</a><br/></td></tr>
<tr class="separator:a145b815bfacb166db9d9b1e2294a0053 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17338a8346b0a574532e6a7b5bab9400 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a17338a8346b0a574532e6a7b5bab9400">clearColorAttachment</a> (api::Fbo fbo, glm::vec4 clearColor)</td></tr>
<tr class="memdesc:a17338a8346b0a574532e6a7b5bab9400 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all attachment for a single fbo with a single clear color. NOTE: This clear operation must be called inside the render pass <a href="#a17338a8346b0a574532e6a7b5bab9400">More...</a><br/></td></tr>
<tr class="separator:a17338a8346b0a574532e6a7b5bab9400 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a4fc7aec52d357cc5b45f57d146418 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a82a4fc7aec52d357cc5b45f57d146418">clearColorImage</a> (api::TextureView &amp;image, glm::vec4 clearColor, const uint32 baseMipLevel=0u, const uint32 levelCount=1u, const uint32 baseArrayLayer=0u, const uint32 layerCount=1u, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:a82a4fc7aec52d357cc5b45f57d146418 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified color image using the clear color specified. NOTE: This clear operation must be called outside the render pass <a href="#a82a4fc7aec52d357cc5b45f57d146418">More...</a><br/></td></tr>
<tr class="separator:a82a4fc7aec52d357cc5b45f57d146418 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c882100d42cc4b9cdc83c6d73fa3e3d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3c882100d42cc4b9cdc83c6d73fa3e3d">clearColorImage</a> (api::TextureView &amp;image, glm::vec4 clearColor, const uint32 *baseMipLevel, const uint32 *levelCount, const uint32 *baseArrayLayers, const uint32 *layerCount, uint32 rangeCount, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:a3c882100d42cc4b9cdc83c6d73fa3e3d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears rangeCount sub resource ranges of the specified color image using the clear color specified. NOTE: This clear operation must be called outside the render pass <a href="#a3c882100d42cc4b9cdc83c6d73fa3e3d">More...</a><br/></td></tr>
<tr class="separator:a3c882100d42cc4b9cdc83c6d73fa3e3d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ba43f43ffa0b49b9f6bf2321d3d1c4 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa0ba43f43ffa0b49b9f6bf2321d3d1c4">clearDepthAttachment</a> (const Rectanglei &amp;clearRect, float32 depth=1.f)</td></tr>
<tr class="memdesc:aa0ba43f43ffa0b49b9f6bf2321d3d1c4 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the depth attachment of an fbo. NOTE: This clear operation must be called inside the render pass  <a href="#aa0ba43f43ffa0b49b9f6bf2321d3d1c4">More...</a><br/></td></tr>
<tr class="separator:aa0ba43f43ffa0b49b9f6bf2321d3d1c4 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34af62437abb4ec58407b0cdf66e236 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ac34af62437abb4ec58407b0cdf66e236">clearDepthImage</a> (api::TextureView &amp;image, float clearDepth, const uint32 baseMipLevel=0u, const uint32 levelCount=1u, const uint32 baseArrayLayer=0u, const uint32 layerCount=1u, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:ac34af62437abb4ec58407b0cdf66e236 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified depth image using the clear depth color specified. NOTE: This clear operation must be called outside the render pass <a href="#ac34af62437abb4ec58407b0cdf66e236">More...</a><br/></td></tr>
<tr class="separator:ac34af62437abb4ec58407b0cdf66e236 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94096a45591eed976e3c189e4fa16c8 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#af94096a45591eed976e3c189e4fa16c8">clearDepthImage</a> (api::TextureView &amp;image, float clearDepth, const uint32 *baseMipLevel, const uint32 *levelCount, const uint32 *baseArrayLayers, const uint32 *layerCount, uint32 rangeCount, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:af94096a45591eed976e3c189e4fa16c8 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears rangeCount sub resource ranges of the specified depth image using the clear depth color specified. NOTE This clear operation must be called outside the render pass <a href="#af94096a45591eed976e3c189e4fa16c8">More...</a><br/></td></tr>
<tr class="separator:af94096a45591eed976e3c189e4fa16c8 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4cab34eba3d7df92ada9bf8ab2e5df inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a6a4cab34eba3d7df92ada9bf8ab2e5df">clearDepthStencilAttachment</a> (const Rectanglei &amp;clearRect, float32 depth=1.f, int32 stencil=0)</td></tr>
<tr class="memdesc:a6a4cab34eba3d7df92ada9bf8ab2e5df inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the depth stencil attachment <a href="#a6a4cab34eba3d7df92ada9bf8ab2e5df">More...</a><br/></td></tr>
<tr class="separator:a6a4cab34eba3d7df92ada9bf8ab2e5df inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c27570a5619317f93d8dde85c1dad5 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ae2c27570a5619317f93d8dde85c1dad5">clearDepthStencilImage</a> (api::TextureView &amp;image, float clearDepth, uint32 clearStencil, const uint32 baseMipLevel=0u, const uint32 levelCount=1u, const uint32 baseArrayLayers=0u, const uint32 layerCount=1u, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:ae2c27570a5619317f93d8dde85c1dad5 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified depth stencil image using the clear depth and stencil color specified. NOTE: This clear operation must be called outside the render pass <a href="#ae2c27570a5619317f93d8dde85c1dad5">More...</a><br/></td></tr>
<tr class="separator:ae2c27570a5619317f93d8dde85c1dad5 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840fc7fdea26889bab025876e876a6b2 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a840fc7fdea26889bab025876e876a6b2">clearDepthStencilImage</a> (api::TextureView &amp;image, float clearDepth, uint32 clearStencil, const uint32 *baseMipLevel, const uint32 *levelCount, const uint32 *baseArrayLayers, const uint32 *layerCount, uint32 rangeCount, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:a840fc7fdea26889bab025876e876a6b2 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears rangeCount sub resource ranges of the specified depth stencil image using the clear depth and stencil color specified. NOTE: This clear operation must be called outside the render pass <a href="#a840fc7fdea26889bab025876e876a6b2">More...</a><br/></td></tr>
<tr class="separator:a840fc7fdea26889bab025876e876a6b2 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ada2b65ca439623e7a48a68d1291dce inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a4ada2b65ca439623e7a48a68d1291dce">clearStencilAttachment</a> (const Rectanglei &amp;clearRect, int32 stencil=0)</td></tr>
<tr class="memdesc:a4ada2b65ca439623e7a48a68d1291dce inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stencil attachment of an fbo. NOTE: This clear operation must be called inside the render pass <a href="#a4ada2b65ca439623e7a48a68d1291dce">More...</a><br/></td></tr>
<tr class="separator:a4ada2b65ca439623e7a48a68d1291dce inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c67e5c58a68ec6753b55aaa6fd757d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a59c67e5c58a68ec6753b55aaa6fd757d">clearStencilImage</a> (api::TextureView &amp;image, uint32 clearStencil, const uint32 baseMipLevel=0u, const uint32 levelCount=1u, const uint32 baseArrayLayers=0u, const uint32 layerCount=1u, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:a59c67e5c58a68ec6753b55aaa6fd757d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified stencil image using the clear stencil color specified. NOTE This clear operation must be called outside the render pass <a href="#a59c67e5c58a68ec6753b55aaa6fd757d">More...</a><br/></td></tr>
<tr class="separator:a59c67e5c58a68ec6753b55aaa6fd757d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c80f839ba5eff8143dc8b284aaa9557 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a7c80f839ba5eff8143dc8b284aaa9557">clearStencilImage</a> (api::TextureView &amp;image, uint32 clearStencil, const uint32 *baseMipLevel, const uint32 *levelCount, const uint32 *baseArrayLayers, const uint32 *layerCount, uint32 rangeCount, types::ImageLayout layout=types::ImageLayout::General)</td></tr>
<tr class="memdesc:a7c80f839ba5eff8143dc8b284aaa9557 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears rangeCount sub resource ranges of the specified stencil image using the clear stencil color specified. NOTE: This clear operation must be called outside the render pass <a href="#a7c80f839ba5eff8143dc8b284aaa9557">More...</a><br/></td></tr>
<tr class="separator:a7c80f839ba5eff8143dc8b284aaa9557 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f74e975c767fa54c80ede3e2bd20ee inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a20f74e975c767fa54c80ede3e2bd20ee">copyBuffer</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> src, <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> dest, uint32 srcOffset, uint32 destOffset, uint32 sizeInBytes)</td></tr>
<tr class="memdesc:a20f74e975c767fa54c80ede3e2bd20ee inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffer <a href="#a20f74e975c767fa54c80ede3e2bd20ee">More...</a><br/></td></tr>
<tr class="separator:a20f74e975c767fa54c80ede3e2bd20ee inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce1c73dd20392b3e8e28d16548f2041 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a7ce1c73dd20392b3e8e28d16548f2041">copyImageToBuffer</a> (api::TextureStore &amp;srcImage, types::ImageLayout srcImageLayout, <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;dstBuffer, types::BufferImageCopy *regions, uint32 numRegions)</td></tr>
<tr class="memdesc:a7ce1c73dd20392b3e8e28d16548f2041 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image to a buffer <a href="#a7ce1c73dd20392b3e8e28d16548f2041">More...</a><br/></td></tr>
<tr class="separator:a7ce1c73dd20392b3e8e28d16548f2041 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd746bf34236572a51b9a961238f06fe inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#afd746bf34236572a51b9a961238f06fe">dispatchCompute</a> (uint32 numGroupsX, uint32 numGroupsY=1, uint32 numGroupsZ=1)</td></tr>
<tr class="memdesc:afd746bf34236572a51b9a961238f06fe inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a ComputeShader execution using the ComputeShader that is in the currently bound ComputePipeline.  <a href="#afd746bf34236572a51b9a961238f06fe">More...</a><br/></td></tr>
<tr class="separator:afd746bf34236572a51b9a961238f06fe inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2579355a81b3bc07666f46b2bbe32d89 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a2579355a81b3bc07666f46b2bbe32d89">dispatchRays</a> (pvr::uint32 xOffset, pvr::uint32 yOffset, pvr::uint32 frameWidth, pvr::uint32 frameHeight)</td></tr>
<tr class="memdesc:a2579355a81b3bc07666f46b2bbe32d89 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a frame shader for each pixel in the box [x, y, x+width, y+height]. <a href="#a2579355a81b3bc07666f46b2bbe32d89">More...</a><br/></td></tr>
<tr class="separator:a2579355a81b3bc07666f46b2bbe32d89 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d3e332d34f8c1838f929f9dfbcf5cf inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a80d3e332d34f8c1838f929f9dfbcf5cf">drawArrays</a> (uint32 firstVertex, uint32 vertexCount, uint32 firstInstance=0, uint32 instanceCount=1)</td></tr>
<tr class="memdesc:a80d3e332d34f8c1838f929f9dfbcf5cf inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Does not use an IndexBuffer. <a href="#a80d3e332d34f8c1838f929f9dfbcf5cf">More...</a><br/></td></tr>
<tr class="separator:a80d3e332d34f8c1838f929f9dfbcf5cf inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0578ef087e598e0222fb15c7e86ee3b2 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a0578ef087e598e0222fb15c7e86ee3b2">drawArraysIndirect</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;buffer, uint32 offset, uint32 drawCount, uint32 stride)</td></tr>
<tr class="memdesc:a0578ef087e598e0222fb15c7e86ee3b2 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">drawArraysIndirect <a href="#a0578ef087e598e0222fb15c7e86ee3b2">More...</a><br/></td></tr>
<tr class="separator:a0578ef087e598e0222fb15c7e86ee3b2 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa3b2218d55301095a4664d7d56586c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3fa3b2218d55301095a4664d7d56586c">drawIndexed</a> (uint32 firstIndex, uint32 indexCount, uint32 vertexOffset=0, uint32 firstInstance=0, uint32 instanceCount=1)</td></tr>
<tr class="memdesc:a3fa3b2218d55301095a4664d7d56586c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Uses the currently bound IndexBuffer for indexes into the currently bound VBOs.  <a href="#a3fa3b2218d55301095a4664d7d56586c">More...</a><br/></td></tr>
<tr class="separator:a3fa3b2218d55301095a4664d7d56586c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49007f7233b526cf8e240d6649eac83f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a49007f7233b526cf8e240d6649eac83f">drawIndexedIndirect</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer)</td></tr>
<tr class="memdesc:a49007f7233b526cf8e240d6649eac83f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirect Draw command. Use buffer to obtain the draw call parameters. <a href="#a49007f7233b526cf8e240d6649eac83f">More...</a><br/></td></tr>
<tr class="separator:a49007f7233b526cf8e240d6649eac83f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba30e81cac9351a93f2cae4e26b85d3d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aba30e81cac9351a93f2cae4e26b85d3d">drawIndirect</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer, uint32 offset, uint32 count, uint32 stride)</td></tr>
<tr class="memdesc:aba30e81cac9351a93f2cae4e26b85d3d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This draw command behaves similarly to drawArray except that the parameters are read by the device from a buffer during execution. <a href="#aba30e81cac9351a93f2cae4e26b85d3d">More...</a><br/></td></tr>
<tr class="separator:aba30e81cac9351a93f2cae4e26b85d3d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b0f42c3c3fc27de7401436383b1e97 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a33b0f42c3c3fc27de7401436383b1e97">endRecording</a> ()</td></tr>
<tr class="memdesc:a33b0f42c3c3fc27de7401436383b1e97 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you are done recording commands. BeginRecording must be called first.  <a href="#a33b0f42c3c3fc27de7401436383b1e97">More...</a><br/></td></tr>
<tr class="separator:a33b0f42c3c3fc27de7401436383b1e97 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c6e34e5bf7ecabe44d49b267c4da2 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa99c6e34e5bf7ecabe44d49b267c4da2">endSceneHierarchy</a> ()</td></tr>
<tr class="memdesc:aa99c6e34e5bf7ecabe44d49b267c4da2 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the recording of scene hierarchy generation commands. <a href="#aa99c6e34e5bf7ecabe44d49b267c4da2">More...</a><br/></td></tr>
<tr class="separator:aa99c6e34e5bf7ecabe44d49b267c4da2 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda7dfc8e8c31b9508daac194f48a557 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">GraphicsContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adda7dfc8e8c31b9508daac194f48a557">getContext</a> ()</td></tr>
<tr class="memdesc:adda7dfc8e8c31b9508daac194f48a557 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the context used by this CommandBuffer. <a href="#adda7dfc8e8c31b9508daac194f48a557">More...</a><br/></td></tr>
<tr class="separator:adda7dfc8e8c31b9508daac194f48a557 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ab01539119a2d4c9d629e46aec6e03 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a81ab01539119a2d4c9d629e46aec6e03">isRecording</a> ()</td></tr>
<tr class="memdesc:a81ab01539119a2d4c9d629e46aec6e03 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if a command buffer is in the recording state <a href="#a81ab01539119a2d4c9d629e46aec6e03">More...</a><br/></td></tr>
<tr class="separator:a81ab01539119a2d4c9d629e46aec6e03 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0c00c0a250dbe0c8aa0b9482d01549 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a6d0c00c0a250dbe0c8aa0b9482d01549">mergeSceneHierarchies</a> (const SceneHierarchy &amp;destinationSceneHierarchy, pvr::math::AxisAlignedBox &amp;extents, const SceneHierarchy *sourceSceneHierarchies, const pvr::uint32 numberOfSourceSceneHierarchies, const pvr::uint32 mergeQuality)</td></tr>
<tr class="memdesc:a6d0c00c0a250dbe0c8aa0b9482d01549 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges a number of scene hierarchies into a single merged hierarchy. <a href="#a6d0c00c0a250dbe0c8aa0b9482d01549">More...</a><br/></td></tr>
<tr class="separator:a6d0c00c0a250dbe0c8aa0b9482d01549 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5506e55f62155f1d81a8dc436ace5d84 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a5506e55f62155f1d81a8dc436ace5d84">pipelineBarrier</a> (types::PipelineStageFlags srcStage, types::PipelineStageFlags dstStage, const <a class="el" href="classpvr_1_1api_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers, bool dependencyByRegion=true)</td></tr>
<tr class="memdesc:a5506e55f62155f1d81a8dc436ace5d84 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed. <a href="#a5506e55f62155f1d81a8dc436ace5d84">More...</a><br/></td></tr>
<tr class="separator:a5506e55f62155f1d81a8dc436ace5d84 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9aabed41319304de1f36ad4b5b7026 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3c9aabed41319304de1f36ad4b5b7026">popPipeline</a> ()</td></tr>
<tr class="memdesc:a3c9aabed41319304de1f36ad4b5b7026 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the previously pushed pipeline (See pushGraphicsPipeline) <a href="#a3c9aabed41319304de1f36ad4b5b7026">More...</a><br/></td></tr>
<tr class="separator:a3c9aabed41319304de1f36ad4b5b7026 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fada6bcf071b51e17f17d525bc9ba5 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a82fada6bcf071b51e17f17d525bc9ba5">pushPipeline</a> ()</td></tr>
<tr class="memdesc:a82fada6bcf071b51e17f17d525bc9ba5 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store which pipeline is currently bound, so that it can later be retrieved and bound with a popPipeline command. <a href="#a82fada6bcf071b51e17f17d525bc9ba5">More...</a><br/></td></tr>
<tr class="separator:a82fada6bcf071b51e17f17d525bc9ba5 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a759341fd752a954ca56ca3aa35266 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa0a759341fd752a954ca56ca3aa35266">pushSharedRayConstants</a> (uint32 offset, uint32 size, const void *pValues)</td></tr>
<tr class="memdesc:aa0a759341fd752a954ca56ca3aa35266 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push shared ray constant data. <a href="#aa0a759341fd752a954ca56ca3aa35266">More...</a><br/></td></tr>
<tr class="separator:aa0a759341fd752a954ca56ca3aa35266 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09862df3dc41a6813b8c8841694221d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ab09862df3dc41a6813b8c8841694221d">resetPipeline</a> ()</td></tr>
<tr class="memdesc:ab09862df3dc41a6813b8c8841694221d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERNAL. reset the currently bound pipeline. <a href="#ab09862df3dc41a6813b8c8841694221d">More...</a><br/></td></tr>
<tr class="separator:ab09862df3dc41a6813b8c8841694221d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43fb0991e490a512bd4968ca267616c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad43fb0991e490a512bd4968ca267616c">sceneHierarchyAppend</a> (pvr::uint32 vertexCount, pvr::uint32 instanceCount, pvr::uint32 firstVertex, pvr::uint32 firstInstance)</td></tr>
<tr class="memdesc:ad43fb0991e490a512bd4968ca267616c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends geometry for use in scene hierarchy building. <a href="#ad43fb0991e490a512bd4968ca267616c">More...</a><br/></td></tr>
<tr class="separator:ad43fb0991e490a512bd4968ca267616c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8739f9eba083eff664bb47968efd84f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad8739f9eba083eff664bb47968efd84f">sceneHierarchyAppendIndexed</a> (pvr::uint32 indexCount, pvr::uint32 instanceCount, pvr::uint32 firstIndex, pvr::uint32 vertexOffset, pvr::uint32 firstInstance)</td></tr>
<tr class="memdesc:ad8739f9eba083eff664bb47968efd84f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends indexed geometry for use in scene hierarchy building. <a href="#ad8739f9eba083eff664bb47968efd84f">More...</a><br/></td></tr>
<tr class="separator:ad8739f9eba083eff664bb47968efd84f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ba580bbf18f9f8e56276fa5d417c74 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a25ba580bbf18f9f8e56276fa5d417c74">sceneHierarchyAppendIndexedIndirect</a> (pvr::api::BufferView &amp;indirectBuffer, pvr::uint32 offset, pvr::uint32 drawCount, pvr::uint32 stride)</td></tr>
<tr class="memdesc:a25ba580bbf18f9f8e56276fa5d417c74 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirectly appends indexed geometry for use in scene hierarchy building. <a href="#a25ba580bbf18f9f8e56276fa5d417c74">More...</a><br/></td></tr>
<tr class="separator:a25ba580bbf18f9f8e56276fa5d417c74 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815271c5a31617cb98872bf10b855442 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a815271c5a31617cb98872bf10b855442">sceneHierarchyAppendIndirect</a> (pvr::api::BufferView &amp;indirectBuffer, pvr::uint32 offset, pvr::uint32 drawCount, pvr::uint32 stride)</td></tr>
<tr class="memdesc:a815271c5a31617cb98872bf10b855442 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirectly appends geometry for use in scene hierarchy building. <a href="#a815271c5a31617cb98872bf10b855442">More...</a><br/></td></tr>
<tr class="separator:a815271c5a31617cb98872bf10b855442 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfefa9d65cd7b481c628517cbbb5f6c4 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#abfefa9d65cd7b481c628517cbbb5f6c4">setBlendConstants</a> (glm::vec4 rgba)</td></tr>
<tr class="memdesc:abfefa9d65cd7b481c628517cbbb5f6c4 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set blend constants for blend operation using constant colors <a href="#abfefa9d65cd7b481c628517cbbb5f6c4">More...</a><br/></td></tr>
<tr class="separator:abfefa9d65cd7b481c628517cbbb5f6c4 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafcdc7cdcdbce966593ff8b9f4f5a27 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aaafcdc7cdcdbce966593ff8b9f4f5a27">setDepthBias</a> (float32 depthBiasConstantFactor, float32 depthBiasClamp, float32 depthBiasSlopeFactor)</td></tr>
<tr class="memdesc:aaafcdc7cdcdbce966593ff8b9f4f5a27 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a dynamic command which controll the offset of depth values of all fragments generated by the rasterization of a polygon. NOTE: If depthBiasEnable is set to false in <a class="el" href="structpvr_1_1api_1_1pipeline_creation_1_1_raster_state_create_param.html" title="Pipeline Rasterisation, clipping and culling state configuration. Culling, winding order...">pipelineCreation::RasterStateCreateParam</a> then no depth bias is applied and the fragment's depth values are unchanged. <a href="#aaafcdc7cdcdbce966593ff8b9f4f5a27">More...</a><br/></td></tr>
<tr class="separator:aaafcdc7cdcdbce966593ff8b9f4f5a27 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dcda0cde4b373682c2a908649cd1a5 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a98dcda0cde4b373682c2a908649cd1a5">setDepthBound</a> (float32 min=0.0f, float32 max=1)</td></tr>
<tr class="memdesc:a98dcda0cde4b373682c2a908649cd1a5 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set minimum and maximum depth <a href="#a98dcda0cde4b373682c2a908649cd1a5">More...</a><br/></td></tr>
<tr class="separator:a98dcda0cde4b373682c2a908649cd1a5 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5486b945bb413470d37961d19b6c2732 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a5486b945bb413470d37961d19b6c2732">setLineWidth</a> (float32 lineWidth)</td></tr>
<tr class="memdesc:a5486b945bb413470d37961d19b6c2732 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the line width <a href="#a5486b945bb413470d37961d19b6c2732">More...</a><br/></td></tr>
<tr class="separator:a5486b945bb413470d37961d19b6c2732 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4c107d37232266c3e3e7744c5250bd inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aff4c107d37232266c3e3e7744c5250bd">setRayBounceLimit</a> (uint32 limit)</td></tr>
<tr class="memdesc:aff4c107d37232266c3e3e7744c5250bd inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ray bounce limit. <a href="#aff4c107d37232266c3e3e7744c5250bd">More...</a><br/></td></tr>
<tr class="separator:aff4c107d37232266c3e3e7744c5250bd inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36750f46eb10f52389aab772a97c7f6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa36750f46eb10f52389aab772a97c7f6">setRaySizes</a> (uint32 raySizeCount, const uint32 *pRaySizes)</td></tr>
<tr class="memdesc:aa36750f46eb10f52389aab772a97c7f6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sizes of rays used in a renderpass. <a href="#aa36750f46eb10f52389aab772a97c7f6">More...</a><br/></td></tr>
<tr class="separator:aa36750f46eb10f52389aab772a97c7f6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfde75092656782a733986836aa14c35 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adfde75092656782a733986836aa14c35">setScissor</a> (const Rectanglei &amp;scissor)</td></tr>
<tr class="memdesc:adfde75092656782a733986836aa14c35 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scissor rectangle <a href="#adfde75092656782a733986836aa14c35">More...</a><br/></td></tr>
<tr class="separator:adfde75092656782a733986836aa14c35 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2f968a5744aa0b91918c92fc49e763 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3c2f968a5744aa0b91918c92fc49e763">setStencilCompareMask</a> (types::StencilFace face, uint32 compareMask)</td></tr>
<tr class="memdesc:a3c2f968a5744aa0b91918c92fc49e763 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stencil comparison mask <a href="#a3c2f968a5744aa0b91918c92fc49e763">More...</a><br/></td></tr>
<tr class="separator:a3c2f968a5744aa0b91918c92fc49e763 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f204d1a61924a5559c0cbdec039af3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa7f204d1a61924a5559c0cbdec039af3">setStencilReference</a> (types::StencilFace face, uint32 ref)</td></tr>
<tr class="memdesc:aa7f204d1a61924a5559c0cbdec039af3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stencil reference value <a href="#aa7f204d1a61924a5559c0cbdec039af3">More...</a><br/></td></tr>
<tr class="separator:aa7f204d1a61924a5559c0cbdec039af3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ceab439157fc658f32552f50963bd7 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a52ceab439157fc658f32552f50963bd7">setStencilWriteMask</a> (types::StencilFace face, uint32 writeMask)</td></tr>
<tr class="memdesc:a52ceab439157fc658f32552f50963bd7 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stencil write mask <a href="#a52ceab439157fc658f32552f50963bd7">More...</a><br/></td></tr>
<tr class="separator:a52ceab439157fc658f32552f50963bd7 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b02946cb8a720619381e395fdb20aa6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a1b02946cb8a720619381e395fdb20aa6">setUniform</a> (int32 location, const uint32 &amp;val)</td></tr>
<tr class="memdesc:a1b02946cb8a720619381e395fdb20aa6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a1b02946cb8a720619381e395fdb20aa6">More...</a><br/></td></tr>
<tr class="separator:a1b02946cb8a720619381e395fdb20aa6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac909e5e03cdcfc6100c4fdf02a48d5cd inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ac909e5e03cdcfc6100c4fdf02a48d5cd">setUniform</a> (int32 location, const int32 &amp;val)</td></tr>
<tr class="memdesc:ac909e5e03cdcfc6100c4fdf02a48d5cd inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#ac909e5e03cdcfc6100c4fdf02a48d5cd">More...</a><br/></td></tr>
<tr class="separator:ac909e5e03cdcfc6100c4fdf02a48d5cd inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8aec90c4019deeb6d8db43a37c5579c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad8aec90c4019deeb6d8db43a37c5579c">setUniform</a> (int32 location, const float32 &amp;val)</td></tr>
<tr class="memdesc:ad8aec90c4019deeb6d8db43a37c5579c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#ad8aec90c4019deeb6d8db43a37c5579c">More...</a><br/></td></tr>
<tr class="separator:ad8aec90c4019deeb6d8db43a37c5579c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4c093621d382784f8e2406731e84ce inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a6b4c093621d382784f8e2406731e84ce">setUniform</a> (int32 location, const glm::vec2 &amp;val)</td></tr>
<tr class="memdesc:a6b4c093621d382784f8e2406731e84ce inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a6b4c093621d382784f8e2406731e84ce">More...</a><br/></td></tr>
<tr class="separator:a6b4c093621d382784f8e2406731e84ce inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3285ce1e6df5eabe0984c0cc0d0aeb6a inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3285ce1e6df5eabe0984c0cc0d0aeb6a">setUniform</a> (int32 location, const glm::ivec2 &amp;val)</td></tr>
<tr class="memdesc:a3285ce1e6df5eabe0984c0cc0d0aeb6a inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a3285ce1e6df5eabe0984c0cc0d0aeb6a">More...</a><br/></td></tr>
<tr class="separator:a3285ce1e6df5eabe0984c0cc0d0aeb6a inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af551b190c46874c6b68639ebf4cb462f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#af551b190c46874c6b68639ebf4cb462f">setUniform</a> (int32 location, const glm::uvec2 &amp;val)</td></tr>
<tr class="memdesc:af551b190c46874c6b68639ebf4cb462f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#af551b190c46874c6b68639ebf4cb462f">More...</a><br/></td></tr>
<tr class="separator:af551b190c46874c6b68639ebf4cb462f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991c4e11cae022d3ff9cb6bcca54bef8 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a991c4e11cae022d3ff9cb6bcca54bef8">setUniform</a> (int32 location, const glm::vec3 &amp;val)</td></tr>
<tr class="memdesc:a991c4e11cae022d3ff9cb6bcca54bef8 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a991c4e11cae022d3ff9cb6bcca54bef8">More...</a><br/></td></tr>
<tr class="separator:a991c4e11cae022d3ff9cb6bcca54bef8 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162d0a010bdb15d09c383d12b551601c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a162d0a010bdb15d09c383d12b551601c">setUniform</a> (int32 location, const glm::ivec3 &amp;val)</td></tr>
<tr class="memdesc:a162d0a010bdb15d09c383d12b551601c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a162d0a010bdb15d09c383d12b551601c">More...</a><br/></td></tr>
<tr class="separator:a162d0a010bdb15d09c383d12b551601c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee6239a34140b5daa677b2eef9aebc6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a9ee6239a34140b5daa677b2eef9aebc6">setUniform</a> (int32 location, const glm::uvec3 &amp;val)</td></tr>
<tr class="memdesc:a9ee6239a34140b5daa677b2eef9aebc6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a9ee6239a34140b5daa677b2eef9aebc6">More...</a><br/></td></tr>
<tr class="separator:a9ee6239a34140b5daa677b2eef9aebc6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea93b97c839ff1826737ee39e849a892 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aea93b97c839ff1826737ee39e849a892">setUniform</a> (int32 location, const glm::vec4 &amp;val)</td></tr>
<tr class="memdesc:aea93b97c839ff1826737ee39e849a892 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#aea93b97c839ff1826737ee39e849a892">More...</a><br/></td></tr>
<tr class="separator:aea93b97c839ff1826737ee39e849a892 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cece054dcbe7348a35aa1ac7478c1d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a28cece054dcbe7348a35aa1ac7478c1d">setUniform</a> (int32 location, const glm::ivec4 &amp;val)</td></tr>
<tr class="memdesc:a28cece054dcbe7348a35aa1ac7478c1d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a28cece054dcbe7348a35aa1ac7478c1d">More...</a><br/></td></tr>
<tr class="separator:a28cece054dcbe7348a35aa1ac7478c1d inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52de50d45c0d4b288dab63b793a9cbb3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a52de50d45c0d4b288dab63b793a9cbb3">setUniform</a> (int32 location, const glm::uvec4 &amp;val)</td></tr>
<tr class="memdesc:a52de50d45c0d4b288dab63b793a9cbb3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a52de50d45c0d4b288dab63b793a9cbb3">More...</a><br/></td></tr>
<tr class="separator:a52de50d45c0d4b288dab63b793a9cbb3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda906d610351a5f04cf17d3dfe00e63 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#abda906d610351a5f04cf17d3dfe00e63">setUniform</a> (int32 location, const glm::mat2 &amp;val)</td></tr>
<tr class="memdesc:abda906d610351a5f04cf17d3dfe00e63 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#abda906d610351a5f04cf17d3dfe00e63">More...</a><br/></td></tr>
<tr class="separator:abda906d610351a5f04cf17d3dfe00e63 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bb24f25d814b9f41f9afae9bd8a989 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a16bb24f25d814b9f41f9afae9bd8a989">setUniform</a> (int32 location, const glm::mat2x3 &amp;val)</td></tr>
<tr class="memdesc:a16bb24f25d814b9f41f9afae9bd8a989 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a16bb24f25d814b9f41f9afae9bd8a989">More...</a><br/></td></tr>
<tr class="separator:a16bb24f25d814b9f41f9afae9bd8a989 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f2cc5275071ab09813c331c7f741de inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a59f2cc5275071ab09813c331c7f741de">setUniform</a> (int32 location, const glm::mat2x4 &amp;val)</td></tr>
<tr class="memdesc:a59f2cc5275071ab09813c331c7f741de inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a59f2cc5275071ab09813c331c7f741de">More...</a><br/></td></tr>
<tr class="separator:a59f2cc5275071ab09813c331c7f741de inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa548a85f2cb7bafec11ecddd91204f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a8fa548a85f2cb7bafec11ecddd91204f">setUniform</a> (int32 location, const glm::mat3x2 &amp;val)</td></tr>
<tr class="memdesc:a8fa548a85f2cb7bafec11ecddd91204f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a8fa548a85f2cb7bafec11ecddd91204f">More...</a><br/></td></tr>
<tr class="separator:a8fa548a85f2cb7bafec11ecddd91204f inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3470ff11bcf88d07724f67de6f0e6a inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a9d3470ff11bcf88d07724f67de6f0e6a">setUniform</a> (int32 location, const glm::mat3 &amp;val)</td></tr>
<tr class="memdesc:a9d3470ff11bcf88d07724f67de6f0e6a inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a9d3470ff11bcf88d07724f67de6f0e6a">More...</a><br/></td></tr>
<tr class="separator:a9d3470ff11bcf88d07724f67de6f0e6a inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d43dff8b5653d7980f8d520fe92e93 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ae8d43dff8b5653d7980f8d520fe92e93">setUniform</a> (int32 location, const glm::mat3x4 &amp;val)</td></tr>
<tr class="memdesc:ae8d43dff8b5653d7980f8d520fe92e93 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#ae8d43dff8b5653d7980f8d520fe92e93">More...</a><br/></td></tr>
<tr class="separator:ae8d43dff8b5653d7980f8d520fe92e93 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac046512c225f69b60db50e6ae30d7d64 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ac046512c225f69b60db50e6ae30d7d64">setUniform</a> (int32 location, const glm::mat4x2 &amp;val)</td></tr>
<tr class="memdesc:ac046512c225f69b60db50e6ae30d7d64 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#ac046512c225f69b60db50e6ae30d7d64">More...</a><br/></td></tr>
<tr class="separator:ac046512c225f69b60db50e6ae30d7d64 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b7a7a69ad282b8b5ca750d41800635 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a73b7a7a69ad282b8b5ca750d41800635">setUniform</a> (int32 location, const glm::mat4x3 &amp;val)</td></tr>
<tr class="memdesc:a73b7a7a69ad282b8b5ca750d41800635 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a73b7a7a69ad282b8b5ca750d41800635">More...</a><br/></td></tr>
<tr class="separator:a73b7a7a69ad282b8b5ca750d41800635 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760f42bdb4a38ca6c9de0e02d9344117 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a760f42bdb4a38ca6c9de0e02d9344117">setUniform</a> (int32 location, const glm::mat4x4 &amp;val)</td></tr>
<tr class="memdesc:a760f42bdb4a38ca6c9de0e02d9344117 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. <a href="#a760f42bdb4a38ca6c9de0e02d9344117">More...</a><br/></td></tr>
<tr class="separator:a760f42bdb4a38ca6c9de0e02d9344117 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22aadd54bea402313ed21e3260328d40 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a22aadd54bea402313ed21e3260328d40">setUniformPtr</a> (int32 location, uint32 count, const uint32 *ptr)</td></tr>
<tr class="memdesc:a22aadd54bea402313ed21e3260328d40 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a22aadd54bea402313ed21e3260328d40">More...</a><br/></td></tr>
<tr class="separator:a22aadd54bea402313ed21e3260328d40 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7062b2d4a6ca4973bd7b054a112f58 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a9f7062b2d4a6ca4973bd7b054a112f58">setUniformPtr</a> (int32 location, uint32 count, const int32 *ptr)</td></tr>
<tr class="memdesc:a9f7062b2d4a6ca4973bd7b054a112f58 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a9f7062b2d4a6ca4973bd7b054a112f58">More...</a><br/></td></tr>
<tr class="separator:a9f7062b2d4a6ca4973bd7b054a112f58 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d54db440cf087f040bbda86e5e95a3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a54d54db440cf087f040bbda86e5e95a3">setUniformPtr</a> (int32 location, uint32 count, const float32 *ptr)</td></tr>
<tr class="memdesc:a54d54db440cf087f040bbda86e5e95a3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a54d54db440cf087f040bbda86e5e95a3">More...</a><br/></td></tr>
<tr class="separator:a54d54db440cf087f040bbda86e5e95a3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baa3038d44b3a7e3e870f3a10fbae71 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a6baa3038d44b3a7e3e870f3a10fbae71">setUniformPtr</a> (int32 location, uint32 count, const glm::vec2 *ptr)</td></tr>
<tr class="memdesc:a6baa3038d44b3a7e3e870f3a10fbae71 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a6baa3038d44b3a7e3e870f3a10fbae71">More...</a><br/></td></tr>
<tr class="separator:a6baa3038d44b3a7e3e870f3a10fbae71 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82486522419a41265f9f8df4789bb0c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#af82486522419a41265f9f8df4789bb0c">setUniformPtr</a> (int32 location, uint32 count, const glm::ivec2 *ptr)</td></tr>
<tr class="memdesc:af82486522419a41265f9f8df4789bb0c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#af82486522419a41265f9f8df4789bb0c">More...</a><br/></td></tr>
<tr class="separator:af82486522419a41265f9f8df4789bb0c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3dcb29504db57df1b5c6b256414cb4 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a1e3dcb29504db57df1b5c6b256414cb4">setUniformPtr</a> (int32 location, uint32 count, const glm::uvec2 *ptr)</td></tr>
<tr class="memdesc:a1e3dcb29504db57df1b5c6b256414cb4 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a1e3dcb29504db57df1b5c6b256414cb4">More...</a><br/></td></tr>
<tr class="separator:a1e3dcb29504db57df1b5c6b256414cb4 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050b1a9a98049382acca50937c758bce inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a050b1a9a98049382acca50937c758bce">setUniformPtr</a> (int32 location, uint32 count, const glm::vec3 *ptr)</td></tr>
<tr class="memdesc:a050b1a9a98049382acca50937c758bce inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a050b1a9a98049382acca50937c758bce">More...</a><br/></td></tr>
<tr class="separator:a050b1a9a98049382acca50937c758bce inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73da778d67c9a32f44a9bf0e119e4b8c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a73da778d67c9a32f44a9bf0e119e4b8c">setUniformPtr</a> (int32 location, uint32 count, const glm::ivec3 *ptr)</td></tr>
<tr class="memdesc:a73da778d67c9a32f44a9bf0e119e4b8c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a73da778d67c9a32f44a9bf0e119e4b8c">More...</a><br/></td></tr>
<tr class="separator:a73da778d67c9a32f44a9bf0e119e4b8c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9ddd0b0a8a6acc46c071ede9ecac97 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a8d9ddd0b0a8a6acc46c071ede9ecac97">setUniformPtr</a> (int32 location, uint32 count, const glm::uvec3 *ptr)</td></tr>
<tr class="memdesc:a8d9ddd0b0a8a6acc46c071ede9ecac97 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a8d9ddd0b0a8a6acc46c071ede9ecac97">More...</a><br/></td></tr>
<tr class="separator:a8d9ddd0b0a8a6acc46c071ede9ecac97 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b085146682c8f9c18e5030dfebb892 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad4b085146682c8f9c18e5030dfebb892">setUniformPtr</a> (int32 location, uint32 count, const glm::vec4 *ptr)</td></tr>
<tr class="memdesc:ad4b085146682c8f9c18e5030dfebb892 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#ad4b085146682c8f9c18e5030dfebb892">More...</a><br/></td></tr>
<tr class="separator:ad4b085146682c8f9c18e5030dfebb892 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10b47337b55eeb12c3de0d914404de6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad10b47337b55eeb12c3de0d914404de6">setUniformPtr</a> (int32 location, uint32 count, const glm::ivec4 *ptr)</td></tr>
<tr class="memdesc:ad10b47337b55eeb12c3de0d914404de6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#ad10b47337b55eeb12c3de0d914404de6">More...</a><br/></td></tr>
<tr class="separator:ad10b47337b55eeb12c3de0d914404de6 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f47a63f71756adbbf4f0adb6d1bd701 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a6f47a63f71756adbbf4f0adb6d1bd701">setUniformPtr</a> (int32 location, uint32 count, const glm::uvec4 *ptr)</td></tr>
<tr class="memdesc:a6f47a63f71756adbbf4f0adb6d1bd701 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a6f47a63f71756adbbf4f0adb6d1bd701">More...</a><br/></td></tr>
<tr class="separator:a6f47a63f71756adbbf4f0adb6d1bd701 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f40c7c2c51ca3f5413a3e58f9386ae inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a81f40c7c2c51ca3f5413a3e58f9386ae">setUniformPtr</a> (int32 location, uint32 count, const glm::mat2 *ptr)</td></tr>
<tr class="memdesc:a81f40c7c2c51ca3f5413a3e58f9386ae inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a81f40c7c2c51ca3f5413a3e58f9386ae">More...</a><br/></td></tr>
<tr class="separator:a81f40c7c2c51ca3f5413a3e58f9386ae inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10591384fe73401fba7c6f70c5290802 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a10591384fe73401fba7c6f70c5290802">setUniformPtr</a> (int32 location, uint32 count, const glm::mat2x3 *ptr)</td></tr>
<tr class="memdesc:a10591384fe73401fba7c6f70c5290802 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a10591384fe73401fba7c6f70c5290802">More...</a><br/></td></tr>
<tr class="separator:a10591384fe73401fba7c6f70c5290802 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603d52631827f45e4acf442296ee4fcc inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a603d52631827f45e4acf442296ee4fcc">setUniformPtr</a> (int32 location, uint32 count, const glm::mat2x4 *ptr)</td></tr>
<tr class="memdesc:a603d52631827f45e4acf442296ee4fcc inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a603d52631827f45e4acf442296ee4fcc">More...</a><br/></td></tr>
<tr class="separator:a603d52631827f45e4acf442296ee4fcc inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea89274467964db30e970b35249c505 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a8ea89274467964db30e970b35249c505">setUniformPtr</a> (int32 location, uint32 count, const glm::mat3x2 *ptr)</td></tr>
<tr class="memdesc:a8ea89274467964db30e970b35249c505 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a8ea89274467964db30e970b35249c505">More...</a><br/></td></tr>
<tr class="separator:a8ea89274467964db30e970b35249c505 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f13dd6a2743bc17aeb6a93a4e6c6ba inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ab4f13dd6a2743bc17aeb6a93a4e6c6ba">setUniformPtr</a> (int32 location, uint32 count, const glm::mat3 *ptr)</td></tr>
<tr class="memdesc:ab4f13dd6a2743bc17aeb6a93a4e6c6ba inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#ab4f13dd6a2743bc17aeb6a93a4e6c6ba">More...</a><br/></td></tr>
<tr class="separator:ab4f13dd6a2743bc17aeb6a93a4e6c6ba inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb30f6a0f833293f9025a9c6f22c15c1 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adb30f6a0f833293f9025a9c6f22c15c1">setUniformPtr</a> (int32 location, uint32 count, const glm::mat3x4 *ptr)</td></tr>
<tr class="memdesc:adb30f6a0f833293f9025a9c6f22c15c1 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#adb30f6a0f833293f9025a9c6f22c15c1">More...</a><br/></td></tr>
<tr class="separator:adb30f6a0f833293f9025a9c6f22c15c1 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0b2a199cf6bc391b4451817a68b648 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ace0b2a199cf6bc391b4451817a68b648">setUniformPtr</a> (int32 location, uint32 count, const glm::mat4x2 *ptr)</td></tr>
<tr class="memdesc:ace0b2a199cf6bc391b4451817a68b648 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#ace0b2a199cf6bc391b4451817a68b648">More...</a><br/></td></tr>
<tr class="separator:ace0b2a199cf6bc391b4451817a68b648 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ac7522a204fedebac5530c4788dba0 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad0ac7522a204fedebac5530c4788dba0">setUniformPtr</a> (int32 location, uint32 count, const glm::mat4x3 *ptr)</td></tr>
<tr class="memdesc:ad0ac7522a204fedebac5530c4788dba0 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#ad0ac7522a204fedebac5530c4788dba0">More...</a><br/></td></tr>
<tr class="separator:ad0ac7522a204fedebac5530c4788dba0 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941bcb3e189792e13fe4bca6eddb41f3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a941bcb3e189792e13fe4bca6eddb41f3">setUniformPtr</a> (int32 location, uint32 count, const glm::mat4x4 *ptr)</td></tr>
<tr class="memdesc:a941bcb3e189792e13fe4bca6eddb41f3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a941bcb3e189792e13fe4bca6eddb41f3">More...</a><br/></td></tr>
<tr class="separator:a941bcb3e189792e13fe4bca6eddb41f3 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf768f84801a0915feef75a926f12e3c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adf768f84801a0915feef75a926f12e3c">setViewport</a> (const Rectanglei &amp;viewport)</td></tr>
<tr class="memdesc:adf768f84801a0915feef75a926f12e3c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the viewport rectangle <a href="#adf768f84801a0915feef75a926f12e3c">More...</a><br/></td></tr>
<tr class="separator:adf768f84801a0915feef75a926f12e3c inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d3a922739e0a25c2118766f40d9842 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa4d3a922739e0a25c2118766f40d9842">updateBuffer</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer, const void *data, uint32 offset, uint32 length)</td></tr>
<tr class="memdesc:aa4d3a922739e0a25c2118766f40d9842 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the buffer. <a href="#aa4d3a922739e0a25c2118766f40d9842">More...</a><br/></td></tr>
<tr class="separator:aa4d3a922739e0a25c2118766f40d9842 inherit pub_methods_classpvr_1_1api_1_1impl_1_1_command_buffer_base__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. </p>
<p>Primary command buffers can contain RenderPasses, and can be submitted to the GPU. SecondaryCommandBuffers can be submitted to the primaryCommandBuffer -It is invalid to submit commands to a command buffer while it is not being recorded. -It is invalid to reset a command buffer while it is being recorded. -It is invalid to submit a command buffer more than once if it is one time submit command buffer -Draw commands must be between a BeginRenderpass and an EndRenderpass command</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1cedcb377db3dce30f5527c1d7b083ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::beginRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands.</p>

</div>
</div>
<a class="anchor" id="a34a05b346e2fdf90c782d92000666ed4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::beginRenderPass </td>
          <td>(</td>
          <td class="paramtype">api::Fbo &amp;&#160;</td>
          <td class="paramname"><em>fbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>renderArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inlineFirstSubpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em> = <code>glm::vec4(0.0f,&#160;0.0f,&#160;0.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>clearDepth</em> = <code>1.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>clearStencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin a RenderPass, i.e. binding an FBO and preparing to draw into it. Executes the LoadOp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbo</td><td>The FramebufferObject to draw to. All draw commands will write into this FBO.</td></tr>
    <tr><td class="paramname">renderArea</td><td>The area of the FBO to write to</td></tr>
    <tr><td class="paramname">inlineFirstSubpass</td><td>Set to 'true' if the commands of the first subpass will be provided Inline. Set to 'false' if the commands of the first subpass will be submitted through a SecondaryCommandBuffer </td></tr>
    <tr><td class="paramname">clearColor</td><td>If the Color attachment LoadOp is Clear, the color to clear to</td></tr>
    <tr><td class="paramname">clearDepth</td><td>If the Depth attachment LoadOp is Clear, the depth value to clear to</td></tr>
    <tr><td class="paramname">clearStencil</td><td>If the Stencil attachment LoadOp is Clear, the stencil value to clear to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a466d4e39dfedb9a7c0b546fdd822ca96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::beginRenderPass </td>
          <td>(</td>
          <td class="paramtype">api::Fbo &amp;&#160;</td>
          <td class="paramname"><em>fbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>renderArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inlineFirstSubpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 *&#160;</td>
          <td class="paramname"><em>clearColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numClearColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>clearDepth</em> = <code>1.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>clearStencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin a RenderPass, i.e. binding an FBO and preparing to draw into it. Executes the LoadOp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbo</td><td>The FramebufferObject to draw to. All draw commands will write into this FBO.</td></tr>
    <tr><td class="paramname">renderArea</td><td>The area of the FBO to write to</td></tr>
    <tr><td class="paramname">inlineFirstSubpass</td><td>Set to 'true' if the commands of the first subpass will be provided Inline. Set to 'false' if the commands of the first subpass will be submitted through a SecondaryCommandBuffer </td></tr>
    <tr><td class="paramname">clearColors</td><td>If the Color attachment LoadOp is Clear, the color to clear to each attachment </td></tr>
    <tr><td class="paramname">numClearColors</td><td>Number of colour attachments</td></tr>
    <tr><td class="paramname">clearDepth</td><td>If the Depth attachment LoadOp is Clear, the depth value to clear to</td></tr>
    <tr><td class="paramname">clearStencil</td><td>If the Stencil attachment LoadOp is Clear, the stencil value to clear to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acaa7a78c3f3953897780e1edbebfe8df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::beginRenderPass </td>
          <td>(</td>
          <td class="paramtype">api::Fbo &amp;&#160;</td>
          <td class="paramname"><em>fbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inlineFirstSubpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em> = <code>glm::vec4(0.0f,&#160;0.0f,&#160;0.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>clearDepth</em> = <code>1.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>clearStencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin a renderPass i.e. binding an FBO and preparing to draw into it. Executes the LoadOp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbo</td><td>The FramebufferObject to draw to. All draw commands will write into this FBO.</td></tr>
    <tr><td class="paramname">inlineFirstSubpass</td><td>Begin the first subpass commands inline in this commandbuffer if true.</td></tr>
    <tr><td class="paramname">clearColor</td><td>If the Color attachment LoadOp is Clear, the color to clear to each attachment </td></tr>
    <tr><td class="paramname">clearDepth</td><td>If the Depth attachment LoadOp is Clear, the depth value to clear to</td></tr>
    <tr><td class="paramname">clearStencil</td><td>If the Stencil attachment LoadOp is Clear, the stencil value to clear to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6fe825910dfb23e466cb30767a78a82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::beginRenderPass </td>
          <td>(</td>
          <td class="paramtype">api::Fbo &amp;&#160;</td>
          <td class="paramname"><em>fbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RenderPass &amp;&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>renderArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inlineFirstSubpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em> = <code>glm::vec4(0.0f,&#160;0.0f,&#160;0.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>clearDepth</em> = <code>1.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>clearStencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin a renderPass i.e. binding an FBO and preparing to draw into it. Executes the LoadOp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbo</td><td>The FramebufferObject to draw to. All draw commands will write into this FBO.</td></tr>
    <tr><td class="paramname">renderPass</td><td>The render pass object. Renderpass must be compatible with the one the fbo created with</td></tr>
    <tr><td class="paramname">renderArea</td><td>The area of the FBO to write to</td></tr>
    <tr><td class="paramname">inlineFirstSubpass</td><td>True if the first supass commands will be in this commandbuffer, false if the commands will be in the secondary commandbuffer</td></tr>
    <tr><td class="paramname">clearColor</td><td>Color initial clear values. Takes effect only if the renderpass's color load op is clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Depth intial clear value. Takes effect only if the renderpass's depth load op is clear </td></tr>
    <tr><td class="paramname">clearStencil</td><td>Stencil intial clear value. Takes effect only if the renderpass's stencil load op is clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2182275cd1ff938b675925e72601de55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::beginRenderPass </td>
          <td>(</td>
          <td class="paramtype">api::Fbo &amp;&#160;</td>
          <td class="paramname"><em>fbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const api::RenderPass &amp;&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>renderArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inlineFirstSubpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 *&#160;</td>
          <td class="paramname"><em>clearColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numClearColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32 *&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numClearDepthStencil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin a renderPass i.e. binding an FBO and preparing to draw into it. Executes the LoadOp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbo</td><td>The FramebufferObject to draw to. All draw commands will write into this FBO.</td></tr>
    <tr><td class="paramname">renderPass</td><td>The render pass object. Renderpass must be compatible with the one the fbo created with</td></tr>
    <tr><td class="paramname">renderArea</td><td>The area of the FBO to write to</td></tr>
    <tr><td class="paramname">inlineFirstSubpass</td><td>True if the first supass commands will be in this commandbuffer, false if the commands will be in the secondary commandbuffer</td></tr>
    <tr><td class="paramname">clearColors</td><td>If the Color attachment LoadOp is Clear, the color to clear to each attachment </td></tr>
    <tr><td class="paramname">numClearColors</td><td>Number of colour attachments</td></tr>
    <tr><td class="paramname">numClearDepthStencil</td><td>Number of depth/stencil attachments</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Depth intial clear value. Takes effect only if the renderpass's depth load op is clear </td></tr>
    <tr><td class="paramname">clearStencil</td><td>Stencil intial clear value. Takes effect only if the renderpass's stencil load op is clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee35971cf7681a41986c21edfe9792c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::beginRenderPass </td>
          <td>(</td>
          <td class="paramtype">api::Fbo &amp;&#160;</td>
          <td class="paramname"><em>fbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const api::RenderPass &amp;&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inlineFirstSubpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em> = <code>glm::vec4(0.0f,&#160;0.0f,&#160;0.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>clearDepth</em> = <code>1.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>clearStencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin a renderPass i.e. binding an FBO and preparing to draw into it. Executes the LoadOp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbo</td><td>The FramebufferObject to draw to. All draw commands will write into this FBO.</td></tr>
    <tr><td class="paramname">renderPass</td><td>The render pass object. Renderpass must be compatible with the one the fbo created with</td></tr>
    <tr><td class="paramname">inlineFirstSubpass</td><td>True if the first supass commands will be in this commandbuffer, false if the commands will be in the secondary commandbuffer</td></tr>
    <tr><td class="paramname">clearColor</td><td>Color initial clear values. Takes effect only if the renderpass's color load op is clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Depth intial clear value. Takes effect only if the renderpass's depth load op is clear </td></tr>
    <tr><td class="paramname">clearStencil</td><td>Stencil intial clear value. Takes effect only if the renderpass's stencil load op is clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa76aaf2b2e03afa5529120210c27ab63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::endRenderPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish the a renderpass (executes the StoreOp).</p>

</div>
</div>
<a class="anchor" id="a9e91bbcad5923769b728a3dada16569c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::enqueueSecondaryCmds </td>
          <td>(</td>
          <td class="paramtype">SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>secondaryCmdBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record commands from the secondary command buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondaryCmdBuffer</td><td>Record all commands from a secondary command buffer</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58179c8c6af004fe1f1914fb15949a52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::enqueueSecondaryCmds </td>
          <td>(</td>
          <td class="paramtype">SecondaryCommandBuffer *&#160;</td>
          <td class="paramname"><em>secondaryCmdBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numCmdBuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record commands from an array of secondary command buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondaryCmdBuffers</td><td>A c-style array of SecondaryCommandBuffers</td></tr>
    <tr><td class="paramname">numCmdBuffers</td><td>The number of SecondaryCommandBuffers in secondaryCmdBuffers</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc500578fe832db59d2218e4202221d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::enqueueSecondaryCmds_BeginMultiple </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>expectedMax</em> = <code>255</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record commands from an secondary command buffer. Multiple enqueueing mode. This is an optimized version where the user is expected to be enqueueing multiple secondary command buffers, but does not necessarily immediately have them available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expectedMax</td><td>The number of command buffers that are expected to be enqueued. This number is only a hint and can be overrun.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2598b34fd3ae7c8ea0b7c391b6880c8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::enqueueSecondaryCmds_EnqueueMultiple </td>
          <td>(</td>
          <td class="paramtype">SecondaryCommandBuffer *&#160;</td>
          <td class="paramname"><em>secondaryCmdBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numCmdBuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect commands for the multiple enqueueing mode. Must be called after enqueueSecondaryCmds_BeginMultiple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondaryCmdBuffers</td><td>A c-style array of secondaryCmdBuffer</td></tr>
    <tr><td class="paramname">numCmdBuffers</td><td>The number of command buffers</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf4b4806a8865bc921a048a1fad2d5dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::enqueueSecondaryCmds_SubmitMultiple </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepAllocated</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit the commands collected in multiple enqueueing mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepAllocated</td><td>Attempt to keep any allocated memory for the next enqueueMultiple call.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb7f186ed42ca969457fa56ea6182785"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::nextSubPassInline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin recording commands for the next surpass in this render pass.</p>

</div>
</div>
<a class="anchor" id="a74bff4073bfe107dfcb89a9bc99ee7f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::nextSubPassSecondaryCmds </td>
          <td>(</td>
          <td class="paramtype">SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>cmdBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record next sub pass commands from a secondary-commandbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdBuffer</td><td>The commands in this will be used to record the next subPass.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63d103ff34e335e312c25680cb2f7562"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::submit </td>
          <td>(</td>
          <td class="paramtype">const Semaphore &amp;&#160;</td>
          <td class="paramname"><em>waitSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Semaphore &amp;&#160;</td>
          <td class="paramname"><em>signalSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Fence &amp;&#160;</td>
          <td class="paramname"><em>fence</em> = <code>Fence()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit this command buffer to the GPU</p>

</div>
</div>
<a class="anchor" id="ac9d352142dca558ea5c25d90775f2055"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::submit </td>
          <td>(</td>
          <td class="paramtype">SemaphoreSet &amp;&#160;</td>
          <td class="paramname"><em>waitSemaphores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SemaphoreSet &amp;&#160;</td>
          <td class="paramname"><em>signalSemaphores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Fence &amp;&#160;</td>
          <td class="paramname"><em>fence</em> = <code>Fence()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit this command buffer to the GPU</p>

</div>
</div>
<a class="anchor" id="a41eaf80ca9434f765c3fbb4b6d3c3b99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::submit </td>
          <td>(</td>
          <td class="paramtype">Fence &amp;&#160;</td>
          <td class="paramname"><em>fence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit this command buffer to the GPU</p>

</div>
</div>
<a class="anchor" id="a8eb83b1103f00b5921bea30a8e53505c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::submit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit this command buffer to the GPU</p>

</div>
</div>
<a class="anchor" id="a2eae86fac3f5635df4539b5e7684e5e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::submitEndOfFrame </td>
          <td>(</td>
          <td class="paramtype">Semaphore &amp;&#160;</td>
          <td class="paramname"><em>waitSemaphore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit this command buffer to the GPU</p>

</div>
</div>
<a class="anchor" id="ac1f6ea0f6660de080ef2299e21528984"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBuffer_::submitStartOfFrame </td>
          <td>(</td>
          <td class="paramtype">Semaphore &amp;&#160;</td>
          <td class="paramname"><em>signalSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Fence &amp;&#160;</td>
          <td class="paramname"><em>fence</em> = <code>Fence()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit this command buffer to the GPU</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRApi/ApiObjects/<a class="el" href="_command_buffer_8h_source.html">CommandBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
