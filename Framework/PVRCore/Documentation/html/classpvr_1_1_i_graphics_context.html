<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRCore: pvr::IGraphicsContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="classpvr_1_1_i_graphics_context.html">IGraphicsContext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classpvr_1_1_i_graphics_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::IGraphicsContext Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for Graphics context. This interface will be used all over in user code to pass GraphicsContext objects wherever required. It represents a specific GPU configuration. 
 <a href="classpvr_1_1_i_graphics_context.html#details">More...</a></p>

<p>Inherits pvr::PipelineContainer.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af41db73b461b76b3a0d3e7dbae32f110"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#af41db73b461b76b3a0d3e7dbae32f110">ImageFormat</a> </td></tr>
<tr class="memdesc:af41db73b461b76b3a0d3e7dbae32f110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image Format. <a href="classpvr_1_1_i_graphics_context.html#af41db73b461b76b3a0d3e7dbae32f110">More...</a><br/></td></tr>
<tr class="separator:af41db73b461b76b3a0d3e7dbae32f110"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa23111bbf08d4d113b66d52f0e46be72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#aa23111bbf08d4d113b66d52f0e46be72">IGraphicsContext</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> apiType=Api::Unspecified)</td></tr>
<tr class="memdesc:aa23111bbf08d4d113b66d52f0e46be72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Note: Object is uninitialized and unusable until <a class="el" href="classpvr_1_1_i_graphics_context.html#ac1e2f69c1ee53d2b0c9489e85f6b12cc" title="Call this function to initialize the Context using the information of a specific OSManager (usually...">init()</a> is called. <a href="#aa23111bbf08d4d113b66d52f0e46be72">More...</a><br/></td></tr>
<tr class="separator:aa23111bbf08d4d113b66d52f0e46be72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca73f24d5aeca36e4b15d0e65fdd539"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a84ba9b7b7a7f3ae2ff0eca7e715ec90c">api::Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a7ca73f24d5aeca36e4b15d0e65fdd539">createBuffer</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> size, types::BufferBindingUse bufferUsage, bool isMappable=false)=0</td></tr>
<tr class="memdesc:a7ca73f24d5aeca36e4b15d0e65fdd539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer object, which can then be bound as a VBO/IBO and/or shared with BufferView objects (SSBOView, VBOView) <a href="#a7ca73f24d5aeca36e4b15d0e65fdd539">More...</a><br/></td></tr>
<tr class="separator:a7ca73f24d5aeca36e4b15d0e65fdd539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9f066af40417d0a30e494e4c30b835"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a3e2d4659e33a054677ac12c19da5f47c">api::BufferView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a7b9f066af40417d0a30e494e4c30b835">createBufferAndView</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> size, types::BufferBindingUse bufferUsage, bool isMappable=false)=0</td></tr>
<tr class="memdesc:a7b9f066af40417d0a30e494e4c30b835"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-step create a new Buffer with a corresponding BufferView to the entire range of the buffer. <a href="#a7b9f066af40417d0a30e494e4c30b835">More...</a><br/></td></tr>
<tr class="separator:a7b9f066af40417d0a30e494e4c30b835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ee59bbe19be7416d1240416eeda169"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a3e2d4659e33a054677ac12c19da5f47c">api::BufferView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a10ee59bbe19be7416d1240416eeda169">createBufferView</a> (const <a class="el" href="namespacepvr_1_1api.html#a84ba9b7b7a7f3ae2ff0eca7e715ec90c">api::Buffer</a> &amp;buffer, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> offset=0, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> range=0xFFFFFFFFu)=0</td></tr>
<tr class="memdesc:a10ee59bbe19be7416d1240416eeda169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Shader-Accessible view to Buffer Object (Can be used as UBO/SSBO etc), with an existing backing buffer. BufferViews allow Buffers to be added to DescriptorSets. <a href="#a10ee59bbe19be7416d1240416eeda169">More...</a><br/></td></tr>
<tr class="separator:a10ee59bbe19be7416d1240416eeda169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526cb65d274f477e80ce29df46aea43c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#acc8893ac955643c641d731204f06d8fa">api::CommandBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a526cb65d274f477e80ce29df46aea43c">createCommandBufferOnDefaultPool</a> ()=0</td></tr>
<tr class="memdesc:a526cb65d274f477e80ce29df46aea43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new primary CommandBuffer on the default CommandPool <a href="#a526cb65d274f477e80ce29df46aea43c">More...</a><br/></td></tr>
<tr class="separator:a526cb65d274f477e80ce29df46aea43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff942ea5acfff4825542cf5bd302dd22"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a7885487134a0e2a4b8e86d11c820a2c2">api::CommandPool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#aff942ea5acfff4825542cf5bd302dd22">createCommandPool</a> ()=0</td></tr>
<tr class="memdesc:aff942ea5acfff4825542cf5bd302dd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new CommandPool. <a href="#aff942ea5acfff4825542cf5bd302dd22">More...</a><br/></td></tr>
<tr class="separator:aff942ea5acfff4825542cf5bd302dd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad4a6b57395e2ca5d546beca0d7e2d8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a608e558cf465b3183dc23fdb27b2ce03">api::ComputePipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a5ad4a6b57395e2ca5d546beca0d7e2d8">createComputePipeline</a> (const api::ComputePipelineCreateParam &amp;createParam)=0</td></tr>
<tr class="memdesc:a5ad4a6b57395e2ca5d546beca0d7e2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new ComputePipeline object. <a href="#a5ad4a6b57395e2ca5d546beca0d7e2d8">More...</a><br/></td></tr>
<tr class="separator:a5ad4a6b57395e2ca5d546beca0d7e2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fc100505fca0371775185ce30b8bcb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a637551c1f687221f14122e0beeee2730">api::DescriptorPool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ac0fc100505fca0371775185ce30b8bcb">createDescriptorPool</a> (const api::DescriptorPoolCreateParam &amp;createParam)=0</td></tr>
<tr class="memdesc:ac0fc100505fca0371775185ce30b8bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new DescriptorPool (descriptor set allocation pool). <a href="#ac0fc100505fca0371775185ce30b8bcb">More...</a><br/></td></tr>
<tr class="separator:ac0fc100505fca0371775185ce30b8bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd1c728578ce4139211383ef44d7eeb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a51521c1bf928b30d4cb74cbdafda3710">api::DescriptorSetLayout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a6dd1c728578ce4139211383ef44d7eeb">createDescriptorSetLayout</a> (const api::DescriptorSetLayoutCreateParam &amp;createParam)=0</td></tr>
<tr class="memdesc:a6dd1c728578ce4139211383ef44d7eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new DescriptorSetLayout. <a href="#a6dd1c728578ce4139211383ef44d7eeb">More...</a><br/></td></tr>
<tr class="separator:a6dd1c728578ce4139211383ef44d7eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa805fd871238223f769f9aff84e43cb4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#adcc0a391e3ad0455b28b9ac4a1b2ec1a">api::DescriptorSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#aa805fd871238223f769f9aff84e43cb4">createDescriptorSetOnDefaultPool</a> (const <a class="el" href="namespacepvr_1_1api.html#a51521c1bf928b30d4cb74cbdafda3710">api::DescriptorSetLayout</a> &amp;layout)=0</td></tr>
<tr class="memdesc:aa805fd871238223f769f9aff84e43cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new DescriptorSet on the PVRApi default allocation pool. <a href="#aa805fd871238223f769f9aff84e43cb4">More...</a><br/></td></tr>
<tr class="separator:aa805fd871238223f769f9aff84e43cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc591d393bfc0e648429512eb7534794"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a27b9833ef0620323502da3c3bbc9137e">api::Fbo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#afc591d393bfc0e648429512eb7534794">createFbo</a> (const api::FboCreateParam &amp;createParam)=0</td></tr>
<tr class="memdesc:afc591d393bfc0e648429512eb7534794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Framebuffer Object with specified parameters and backing image. Not for on-screen rendering.  <a href="#afc591d393bfc0e648429512eb7534794">More...</a><br/></td></tr>
<tr class="separator:afc591d393bfc0e648429512eb7534794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd43e7d29090ce656256d23d2fa6dc48"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a5e08f2cd496ce0f091ab6df00774510a">api::FboSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#abd43e7d29090ce656256d23d2fa6dc48">createFboSet</a> (const <a class="el" href="classpvr_1_1_multi.html">Multi</a>&lt; api::FboCreateParam &gt; &amp;createParams)=0</td></tr>
<tr class="memdesc:abd43e7d29090ce656256d23d2fa6dc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Framebuffer Object with specified parameters and backing image. Not for on-screen rendering.  <a href="#abd43e7d29090ce656256d23d2fa6dc48">More...</a><br/></td></tr>
<tr class="separator:abd43e7d29090ce656256d23d2fa6dc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2362659aef25c2142409383746c52490"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a026dbaa18337b444ba682d97038bbd19">api::Fence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a2362659aef25c2142409383746c52490">createFence</a> (bool createSignaled=true)=0</td></tr>
<tr class="memdesc:a2362659aef25c2142409383746c52490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Fence <a href="#a2362659aef25c2142409383746c52490">More...</a><br/></td></tr>
<tr class="separator:a2362659aef25c2142409383746c52490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0b35831c0f1d935732f7b643753a8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#ab07c0f5188f9b6484e4b19ad4fd2926c">api::GraphicsPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a8a0b35831c0f1d935732f7b643753a8d">createGraphicsPipeline</a> (const api::GraphicsPipelineCreateParam &amp;createParam)=0</td></tr>
<tr class="memdesc:a8a0b35831c0f1d935732f7b643753a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a GraphicsPipeline object associated with this context. <a href="#a8a0b35831c0f1d935732f7b643753a8d">More...</a><br/></td></tr>
<tr class="separator:a8a0b35831c0f1d935732f7b643753a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e71e481b648d2529c8f32c287550cd5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#ab07c0f5188f9b6484e4b19ad4fd2926c">api::GraphicsPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a7e71e481b648d2529c8f32c287550cd5">createGraphicsPipeline</a> (const api::GraphicsPipelineCreateParam &amp;createParam, <a class="el" href="namespacepvr_1_1api.html#a29852cbd107e34395d2b61d8b12d23fd">api::ParentableGraphicsPipeline</a> parent)=0</td></tr>
<tr class="memdesc:a7e71e481b648d2529c8f32c287550cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create GraphicsPipeline as a child of another provided GraphicsPipeline. <a href="#a7e71e481b648d2529c8f32c287550cd5">More...</a><br/></td></tr>
<tr class="separator:a7e71e481b648d2529c8f32c287550cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ec82d454049fc629b18307f3b96f07"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a527a8dcbcc1b10d0a68aed030faa0e11">api::IndirectRayPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a78ec82d454049fc629b18307f3b96f07">createIndirectRayPipeline</a> (const api::IndirectRayPipelineCreateParam &amp;desc)=0</td></tr>
<tr class="memdesc:a78ec82d454049fc629b18307f3b96f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new IndirectRayPipeline.  <a href="#a78ec82d454049fc629b18307f3b96f07">More...</a><br/></td></tr>
<tr class="separator:a78ec82d454049fc629b18307f3b96f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be54d951c78a310fb2cf05fe5907c22"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a27b9833ef0620323502da3c3bbc9137e">api::Fbo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a9be54d951c78a310fb2cf05fe5907c22">createOnScreenFbo</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> swapIndex, types::LoadOp colorLoadOp=types::LoadOp::Clear, types::StoreOp colorStoreOp=types::StoreOp::Store, types::LoadOp depthLoadOp=types::LoadOp::Clear, types::StoreOp depthStoreOp=types::StoreOp::Ignore, types::LoadOp stencilLoadOp=types::LoadOp::Clear, types::StoreOp stencilStoreOp=types::StoreOp::Ignore)=0</td></tr>
<tr class="memdesc:a9be54d951c78a310fb2cf05fe5907c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an FBO that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the most common parameters. <a href="#a9be54d951c78a310fb2cf05fe5907c22">More...</a><br/></td></tr>
<tr class="separator:a9be54d951c78a310fb2cf05fe5907c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a6d9766db605ebc2ef819b372f02f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a5e08f2cd496ce0f091ab6df00774510a">api::FboSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a71a6d9766db605ebc2ef819b372f02f2">createOnScreenFboSet</a> (types::LoadOp colorLoadOp=types::LoadOp::Clear, types::StoreOp colorStoreOp=types::StoreOp::Store, types::LoadOp depthLoadOp=types::LoadOp::Clear, types::StoreOp depthStoreOp=types::StoreOp::Ignore, types::LoadOp stencilLoadOp=types::LoadOp::Clear, types::StoreOp stencilStoreOp=types::StoreOp::Ignore)=0</td></tr>
<tr class="memdesc:a71a6d9766db605ebc2ef819b372f02f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an FBO that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the most common parameters. <a href="#a71a6d9766db605ebc2ef819b372f02f2">More...</a><br/></td></tr>
<tr class="separator:a71a6d9766db605ebc2ef819b372f02f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1917dc0b5433c276851e0cdc7c5e594d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a5e08f2cd496ce0f091ab6df00774510a">api::FboSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a1917dc0b5433c276851e0cdc7c5e594d">createOnScreenFboSetWithRenderPass</a> (const <a class="el" href="namespacepvr_1_1api.html#aee83fa35189bd63f8782d17405b68916">api::RenderPass</a> &amp;renderPass)=0</td></tr>
<tr class="memdesc:a1917dc0b5433c276851e0cdc7c5e594d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create aset of FBOs (one per backbuffer image) that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the RenderPass to use for it. compatible with the actual BackBuffer format and options - this is the user's responsibility. <a href="#a1917dc0b5433c276851e0cdc7c5e594d">More...</a><br/></td></tr>
<tr class="separator:a1917dc0b5433c276851e0cdc7c5e594d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4109f2b855df6bcfd7f92cb50b1bc6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a5e08f2cd496ce0f091ab6df00774510a">api::FboSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ad4109f2b855df6bcfd7f92cb50b1bc6d">createOnScreenFboSetWithRenderPass</a> (const <a class="el" href="namespacepvr_1_1api.html#aee83fa35189bd63f8782d17405b68916">api::RenderPass</a> &amp;renderPass, const <a class="el" href="classpvr_1_1_multi.html">api::OnScreenFboCreateParamSet</a> &amp;onScreenFboCreateParams)=0</td></tr>
<tr class="memdesc:ad4109f2b855df6bcfd7f92cb50b1bc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an FBO that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the RenderPass to use for it. compatible with the actual BackBuffer format and options - this is the user's responsibility. <a href="#ad4109f2b855df6bcfd7f92cb50b1bc6d">More...</a><br/></td></tr>
<tr class="separator:ad4109f2b855df6bcfd7f92cb50b1bc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4359f34dcfd9de4d48ed5963fab26b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a27b9833ef0620323502da3c3bbc9137e">api::Fbo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#aac4359f34dcfd9de4d48ed5963fab26b">createOnScreenFboWithRenderPass</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> swapIndex, const <a class="el" href="namespacepvr_1_1api.html#aee83fa35189bd63f8782d17405b68916">api::RenderPass</a> &amp;renderPass, const api::OnScreenFboCreateParam &amp;onScreenFboCreateParam)=0</td></tr>
<tr class="memdesc:aac4359f34dcfd9de4d48ed5963fab26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an FBO that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the RenderPass to use for it. compatible with the actual BackBuffer format and options - this is the user's responsibility. Allows the user to specify additional color view attachments for the FBO to use.  <a href="#aac4359f34dcfd9de4d48ed5963fab26b">More...</a><br/></td></tr>
<tr class="separator:aac4359f34dcfd9de4d48ed5963fab26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9445be6aaadc785e04cf2e8a3b7d80"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a27b9833ef0620323502da3c3bbc9137e">api::Fbo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#aac9445be6aaadc785e04cf2e8a3b7d80">createOnScreenFboWithRenderPass</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> swapIndex, const <a class="el" href="namespacepvr_1_1api.html#aee83fa35189bd63f8782d17405b68916">api::RenderPass</a> &amp;renderPass)=0</td></tr>
<tr class="memdesc:aac9445be6aaadc785e04cf2e8a3b7d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an FBO that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the RenderPass to use for it. compatible with the actual BackBuffer format and options - this is the user's responsibility. <a href="#aac9445be6aaadc785e04cf2e8a3b7d80">More...</a><br/></td></tr>
<tr class="separator:aac9445be6aaadc785e04cf2e8a3b7d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1978e7a7c9965fe7bc4e30d73f0321b"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="namespacepvr_1_1api.html#a29852cbd107e34395d2b61d8b12d23fd">api::ParentableGraphicsPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ae1978e7a7c9965fe7bc4e30d73f0321b">createParentableGraphicsPipeline</a> (const api::GraphicsPipelineCreateParam &amp;createParam)=0</td></tr>
<tr class="memdesc:ae1978e7a7c9965fe7bc4e30d73f0321b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new parentable GraphicsPipeline object. <a href="#ae1978e7a7c9965fe7bc4e30d73f0321b">More...</a><br/></td></tr>
<tr class="separator:ae1978e7a7c9965fe7bc4e30d73f0321b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea8bd758024fcc24260cd04ca0c33a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a34c808c2dcb00eb1fb273517d935c500">api::PipelineLayout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a0ea8bd758024fcc24260cd04ca0c33a8">createPipelineLayout</a> (const api::PipelineLayoutCreateParam &amp;createParam)=0</td></tr>
<tr class="memdesc:a0ea8bd758024fcc24260cd04ca0c33a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new PipelineLayout. <a href="#a0ea8bd758024fcc24260cd04ca0c33a8">More...</a><br/></td></tr>
<tr class="separator:a0ea8bd758024fcc24260cd04ca0c33a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a1a5672f52df3229cb63e35db1753b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#aee83fa35189bd63f8782d17405b68916">api::RenderPass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ad5a1a5672f52df3229cb63e35db1753b">createRenderPass</a> (const api::RenderPassCreateParam &amp;renderPassDesc)=0</td></tr>
<tr class="memdesc:ad5a1a5672f52df3229cb63e35db1753b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new render pass. <a href="#ad5a1a5672f52df3229cb63e35db1753b">More...</a><br/></td></tr>
<tr class="separator:ad5a1a5672f52df3229cb63e35db1753b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1d4c9d855611b4db67f63b9f4b85c0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a2cd1fd0d95a3694ae3e9c84b693f2626">api::Sampler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a9b1d4c9d855611b4db67f63b9f4b85c0">createSampler</a> (const <a class="el" href="structpvr_1_1types_1_1_sampler_create_param.html">api::SamplerCreateParam</a> &amp;createParam)=0</td></tr>
<tr class="memdesc:a9b1d4c9d855611b4db67f63b9f4b85c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Sampler object. <a href="#a9b1d4c9d855611b4db67f63b9f4b85c0">More...</a><br/></td></tr>
<tr class="separator:a9b1d4c9d855611b4db67f63b9f4b85c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e05bbadcef1b48e88a1838ffb70490"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a353f91024e36e49da60690a24e4a5ef2">api::SceneHierarchy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a23e05bbadcef1b48e88a1838ffb70490">createSceneHierarchy</a> (const api::SceneHierarchyCreateParam &amp;createParam)=0</td></tr>
<tr class="memdesc:a23e05bbadcef1b48e88a1838ffb70490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new SceneHierarchy.  <a href="#a23e05bbadcef1b48e88a1838ffb70490">More...</a><br/></td></tr>
<tr class="separator:a23e05bbadcef1b48e88a1838ffb70490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac52fc12df570c151b76f7aa96d29975"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#acac101df49d6cbde719d4fe15155473d">api::SceneTraversalPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#aac52fc12df570c151b76f7aa96d29975">createSceneTraversalPipeline</a> (const api::SceneTraversalPipelineCreateParam &amp;desc)=0</td></tr>
<tr class="memdesc:aac52fc12df570c151b76f7aa96d29975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new SceneTraversalPipeline.  <a href="#aac52fc12df570c151b76f7aa96d29975">More...</a><br/></td></tr>
<tr class="separator:aac52fc12df570c151b76f7aa96d29975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80a04c710dd53f59510eea0deaecb08"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a34f13eee73526c78f836fb36c30ea54b">api::SecondaryCommandBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ac80a04c710dd53f59510eea0deaecb08">createSecondaryCommandBufferOnDefaultPool</a> ()=0</td></tr>
<tr class="memdesc:ac80a04c710dd53f59510eea0deaecb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new secondary CommandBuffer on the default CommandPool <a href="#ac80a04c710dd53f59510eea0deaecb08">More...</a><br/></td></tr>
<tr class="separator:ac80a04c710dd53f59510eea0deaecb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf845c4fee52eabfcad547e9f0ae3e9d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a99b21d53ebf284d84b30f18bc6cf3ffe">api::Semaphore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#acf845c4fee52eabfcad547e9f0ae3e9d">createSemaphore</a> ()=0</td></tr>
<tr class="memdesc:acf845c4fee52eabfcad547e9f0ae3e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Semaphore <a href="#acf845c4fee52eabfcad547e9f0ae3e9d">More...</a><br/></td></tr>
<tr class="separator:acf845c4fee52eabfcad547e9f0ae3e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949818c3ca19b3f782896cde8c304aab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#ac733c31aec277813c9aea6cdcf3d77e4">api::Shader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a949818c3ca19b3f782896cde8c304aab">createShader</a> (const <a class="el" href="classpvr_1_1_stream.html">Stream</a> &amp;shaderSrc, types::ShaderType shaderType, const char *const *defines=NULL, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> numDefines=0)=0</td></tr>
<tr class="memdesc:a949818c3ca19b3f782896cde8c304aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Shader from source. Accepts an array of custom preprocessor definition directives. <a href="#a949818c3ca19b3f782896cde8c304aab">More...</a><br/></td></tr>
<tr class="separator:a949818c3ca19b3f782896cde8c304aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b4aef45c650017c9d7bd6f078fb37f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#ac733c31aec277813c9aea6cdcf3d77e4">api::Shader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ab9b4aef45c650017c9d7bd6f078fb37f">createShader</a> (<a class="el" href="classpvr_1_1_stream.html">Stream</a> &amp;shaderData, types::ShaderType shaderType, types::ShaderBinaryFormat binaryFormat)=0</td></tr>
<tr class="memdesc:ab9b4aef45c650017c9d7bd6f078fb37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Shader from binary. <a href="#ab9b4aef45c650017c9d7bd6f078fb37f">More...</a><br/></td></tr>
<tr class="separator:ab9b4aef45c650017c9d7bd6f078fb37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af023941ac10078499702daea0684e60a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#aefa9a681992c85b2e2dfad5099c6fe5e">api::TextureStore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#af023941ac10078499702daea0684e60a">createTexture</a> ()=0</td></tr>
<tr class="memdesc:af023941ac10078499702daea0684e60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> object. <a href="#af023941ac10078499702daea0684e60a">More...</a><br/></td></tr>
<tr class="separator:af023941ac10078499702daea0684e60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dfb4c26f13e1aa4a2af34230b81fc1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#af939d9e7a622e7eda49f452643496ac7">api::TextureView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a41dfb4c26f13e1aa4a2af34230b81fc1">createTextureView</a> (const <a class="el" href="namespacepvr_1_1api.html#aefa9a681992c85b2e2dfad5099c6fe5e">api::TextureStore</a> &amp;texture, <a class="el" href="structpvr_1_1types_1_1_image_subresource_range.html">types::ImageSubresourceRange</a> range, <a class="el" href="structpvr_1_1types_1_1_swizzle_channels.html">types::SwizzleChannels</a>=<a class="el" href="structpvr_1_1types_1_1_swizzle_channels.html">types::SwizzleChannels</a>())=0</td></tr>
<tr class="memdesc:a41dfb4c26f13e1aa4a2af34230b81fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> object. <a href="#a41dfb4c26f13e1aa4a2af34230b81fc1">More...</a><br/></td></tr>
<tr class="separator:a41dfb4c26f13e1aa4a2af34230b81fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6b794f985f986a1f5b468b67a3f5d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#af939d9e7a622e7eda49f452643496ac7">api::TextureView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a6c6b794f985f986a1f5b468b67a3f5d9">createTextureView</a> (const <a class="el" href="namespacepvr_1_1api.html#aefa9a681992c85b2e2dfad5099c6fe5e">api::TextureStore</a> &amp;texture, <a class="el" href="structpvr_1_1types_1_1_swizzle_channels.html">types::SwizzleChannels</a>=<a class="el" href="structpvr_1_1types_1_1_swizzle_channels.html">types::SwizzleChannels</a>())=0</td></tr>
<tr class="memdesc:a6c6b794f985f986a1f5b468b67a3f5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> object. <a href="#a6c6b794f985f986a1f5b468b67a3f5d9">More...</a><br/></td></tr>
<tr class="separator:a6c6b794f985f986a1f5b468b67a3f5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3c2b031bba11c6998ad8b70bfebc09"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a6b511b47047d554c6347c41721b49496">api::VertexRayPipeline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#aeb3c2b031bba11c6998ad8b70bfebc09">createVertexRayPipeline</a> (const api::VertexRayPipelineCreateParam &amp;desc)=0</td></tr>
<tr class="memdesc:aeb3c2b031bba11c6998ad8b70bfebc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new VertexRayPipeline.  <a href="#aeb3c2b031bba11c6998ad8b70bfebc09">More...</a><br/></td></tr>
<tr class="separator:aeb3c2b031bba11c6998ad8b70bfebc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35beac0d845f528a9355edebab7c01d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpvr_1_1_api_capabilities.html">ApiCapabilities</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#aa35beac0d845f528a9355edebab7c01d">getApiCapabilities</a> () const </td></tr>
<tr class="memdesc:aa35beac0d845f528a9355edebab7c01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="structpvr_1_1_api_capabilities.html" title="Struct containing the API capabilities of a specified configuration.">ApiCapabilities</a> object representing the capabilities of this GraphicsContext. <a href="#aa35beac0d845f528a9355edebab7c01d">More...</a><br/></td></tr>
<tr class="separator:aa35beac0d845f528a9355edebab7c01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6215d57531f7cb4e423fd5b8431dcc8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a6215d57531f7cb4e423fd5b8431dcc8d">getApiType</a> () const </td></tr>
<tr class="memdesc:a6215d57531f7cb4e423fd5b8431dcc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Api of this GraphicsContext. <a href="#a6215d57531f7cb4e423fd5b8431dcc8d">More...</a><br/></td></tr>
<tr class="separator:a6215d57531f7cb4e423fd5b8431dcc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad358c7d3da010c7c2c6365661b6d743a"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespacepvr_1_1api.html#a7885487134a0e2a4b8e86d11c820a2c2">api::CommandPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ad358c7d3da010c7c2c6365661b6d743a">getDefaultCommandPool</a> () const =0</td></tr>
<tr class="memdesc:ad358c7d3da010c7c2c6365661b6d743a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default, automatically generated CommandPool <a href="#ad358c7d3da010c7c2c6365661b6d743a">More...</a><br/></td></tr>
<tr class="separator:ad358c7d3da010c7c2c6365661b6d743a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad286709a45128448b6a4a2e0a6ac47"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a7885487134a0e2a4b8e86d11c820a2c2">api::CommandPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a0ad286709a45128448b6a4a2e0a6ac47">getDefaultCommandPool</a> ()=0</td></tr>
<tr class="memdesc:a0ad286709a45128448b6a4a2e0a6ac47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default, automatically generated CommandPool <a href="#a0ad286709a45128448b6a4a2e0a6ac47">More...</a><br/></td></tr>
<tr class="separator:a0ad286709a45128448b6a4a2e0a6ac47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0843b41f8cd3b48664586248d162591"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespacepvr_1_1api.html#a637551c1f687221f14122e0beeee2730">api::DescriptorPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ad0843b41f8cd3b48664586248d162591">getDefaultDescriptorPool</a> () const =0</td></tr>
<tr class="memdesc:ad0843b41f8cd3b48664586248d162591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default, automatically generated DescriptorPool. <a href="#ad0843b41f8cd3b48664586248d162591">More...</a><br/></td></tr>
<tr class="separator:ad0843b41f8cd3b48664586248d162591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753c731edcc419ebb96a722aed7c7bed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#a637551c1f687221f14122e0beeee2730">api::DescriptorPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a753c731edcc419ebb96a722aed7c7bed">getDefaultDescriptorPool</a> ()=0</td></tr>
<tr class="memdesc:a753c731edcc419ebb96a722aed7c7bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default, automatically generated DescriptorPool. <a href="#a753c731edcc419ebb96a722aed7c7bed">More...</a><br/></td></tr>
<tr class="separator:a753c731edcc419ebb96a722aed7c7bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8077aa01b3b70595222313381e57af5"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structpvr_1_1_image_data_format.html">ImageDataFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ad8077aa01b3b70595222313381e57af5">getDepthStencilImageFormat</a> () const =0</td></tr>
<tr class="memdesc:ad8077aa01b3b70595222313381e57af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the format of the depth stencil image. <a href="#ad8077aa01b3b70595222313381e57af5">More...</a><br/></td></tr>
<tr class="separator:ad8077aa01b3b70595222313381e57af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214c666c0e03ae6170281b15a7ebb92c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1platform_1_1_display_attributes.html">platform::DisplayAttributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a214c666c0e03ae6170281b15a7ebb92c">getDisplayAttributes</a> () const </td></tr>
<tr class="memdesc:a214c666c0e03ae6170281b15a7ebb92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the DisplayAttributes associated with this GraphicsContext. <a href="#a214c666c0e03ae6170281b15a7ebb92c">More...</a><br/></td></tr>
<tr class="separator:a214c666c0e03ae6170281b15a7ebb92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923200f0bc70d51a0079ee65faaef510"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a923200f0bc70d51a0079ee65faaef510">getInfo</a> () const =0</td></tr>
<tr class="memdesc:a923200f0bc70d51a0079ee65faaef510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print information about this <a class="el" href="classpvr_1_1_i_graphics_context.html" title="Interface for Graphics context. This interface will be used all over in user code to pass GraphicsCon...">IGraphicsContext</a>. <a href="#a923200f0bc70d51a0079ee65faaef510">More...</a><br/></td></tr>
<tr class="separator:a923200f0bc70d51a0079ee65faaef510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19d078d5de4029a8b8e2c001b6021cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ac19d078d5de4029a8b8e2c001b6021cc">getLastSwapChainIndex</a> () const </td></tr>
<tr class="memdesc:ac19d078d5de4029a8b8e2c001b6021cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last swap chain index <a href="#ac19d078d5de4029a8b8e2c001b6021cc">More...</a><br/></td></tr>
<tr class="separator:ac19d078d5de4029a8b8e2c001b6021cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac424337608e18560ba07f1317053d6f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_i_platform_context.html">IPlatformContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ac424337608e18560ba07f1317053d6f8">getPlatformContext</a> () const </td></tr>
<tr class="memdesc:ac424337608e18560ba07f1317053d6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classpvr_1_1_i_platform_context.html" title="Interface for the Platform context. Contains all the operations that the pvr::Shell and StateMachine ...">IPlatformContext</a> object powering this GraphicsContext. <a href="#ac424337608e18560ba07f1317053d6f8">More...</a><br/></td></tr>
<tr class="separator:ac424337608e18560ba07f1317053d6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69e2d4c380556ff193c456c71f17d5e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structpvr_1_1_image_data_format.html">ImageDataFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ab69e2d4c380556ff193c456c71f17d5e">getPresentationImageFormat</a> () const =0</td></tr>
<tr class="memdesc:ab69e2d4c380556ff193c456c71f17d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the format of the presentation image. <a href="#ab69e2d4c380556ff193c456c71f17d5e">More...</a><br/></td></tr>
<tr class="separator:ab69e2d4c380556ff193c456c71f17d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8ff509b1d808cc95bbf9c72edb8e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a0d8ff509b1d808cc95bbf9c72edb8e78">getSwapChainIndex</a> () const </td></tr>
<tr class="memdesc:a0d8ff509b1d808cc95bbf9c72edb8e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current swapchain index <a href="#a0d8ff509b1d808cc95bbf9c72edb8e78">More...</a><br/></td></tr>
<tr class="separator:a0d8ff509b1d808cc95bbf9c72edb8e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9eff125221c7878cc5e5cd87193008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#aea9eff125221c7878cc5e5cd87193008">getSwapChainLength</a> () const </td></tr>
<tr class="memdesc:aea9eff125221c7878cc5e5cd87193008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="classpvr_1_1_multi.html" title="A small statically allocated array This class represents a small array of items. The array is statica...">Multi</a> buffer supported. <a href="#aea9eff125221c7878cc5e5cd87193008">More...</a><br/></td></tr>
<tr class="separator:aea9eff125221c7878cc5e5cd87193008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15994854eb809ceb39451fece16d95c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ab15994854eb809ceb39451fece16d95c">hasApiCapability</a> (<a class="el" href="structpvr_1_1_api_capabilities.html#abb9320fb33b0f72d6a9097abb1c72eb2">ApiCapabilities::Enum</a> capability) const </td></tr>
<tr class="memdesc:ab15994854eb809ceb39451fece16d95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="structpvr_1_1_api_capabilities.html" title="Struct containing the API capabilities of a specified configuration.">ApiCapabilities</a> object representing the capabilities of this GraphicsContext. <a href="#ab15994854eb809ceb39451fece16d95c">More...</a><br/></td></tr>
<tr class="separator:ab15994854eb809ceb39451fece16d95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e098be5379bb1ba747fdcf7a5ba7a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a52e098be5379bb1ba747fdcf7a5ba7a8">hasApiCapabilityExtension</a> (<a class="el" href="structpvr_1_1_api_capabilities.html#abb9320fb33b0f72d6a9097abb1c72eb2">ApiCapabilities::Enum</a> capability) const </td></tr>
<tr class="memdesc:a52e098be5379bb1ba747fdcf7a5ba7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="structpvr_1_1_api_capabilities.html" title="Struct containing the API capabilities of a specified configuration.">ApiCapabilities</a> object representing the capabilities of this GraphicsContext. <a href="#a52e098be5379bb1ba747fdcf7a5ba7a8">More...</a><br/></td></tr>
<tr class="separator:a52e098be5379bb1ba747fdcf7a5ba7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ffdcce60d4ad8706e84c41b986339c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#aa5ffdcce60d4ad8706e84c41b986339c">hasApiCapabilityNatively</a> (<a class="el" href="structpvr_1_1_api_capabilities.html#abb9320fb33b0f72d6a9097abb1c72eb2">ApiCapabilities::Enum</a> capability) const </td></tr>
<tr class="memdesc:aa5ffdcce60d4ad8706e84c41b986339c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="structpvr_1_1_api_capabilities.html" title="Struct containing the API capabilities of a specified configuration.">ApiCapabilities</a> object representing the capabilities of this GraphicsContext. <a href="#aa5ffdcce60d4ad8706e84c41b986339c">More...</a><br/></td></tr>
<tr class="separator:aa5ffdcce60d4ad8706e84c41b986339c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e2f69c1ee53d2b0c9489e85f6b12cc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ac1e2f69c1ee53d2b0c9489e85f6b12cc">init</a> (<a class="el" href="classpvr_1_1_o_s_manager.html">OSManager</a> &amp;osManager)=0</td></tr>
<tr class="memdesc:ac1e2f69c1ee53d2b0c9489e85f6b12cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to initialize the Context using the information of a specific <a class="el" href="classpvr_1_1_o_s_manager.html" title="This interface abstracts the part of the Shell that will provide the Display and the Window so that t...">OSManager</a> (usually, the Shell instance). <a href="#ac1e2f69c1ee53d2b0c9489e85f6b12cc">More...</a><br/></td></tr>
<tr class="separator:ac1e2f69c1ee53d2b0c9489e85f6b12cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe93a0a76e18d5de06876d1b6c9ecc2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#abbe93a0a76e18d5de06876d1b6c9ecc2">isExtensionSupported</a> (const <a class="el" href="namespacepvr.html#ac3509eed37537ef511f3ae29ee9ad3fc">char8</a> *extension) const =0</td></tr>
<tr class="memdesc:abbe93a0a76e18d5de06876d1b6c9ecc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a specific extension is supported. <a href="#abbe93a0a76e18d5de06876d1b6c9ecc2">More...</a><br/></td></tr>
<tr class="separator:abbe93a0a76e18d5de06876d1b6c9ecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06518f303d7f7fe53b10516935fbda87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a06518f303d7f7fe53b10516935fbda87">isQueueSupported</a> (<a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1b">DeviceQueueType</a> queueType)</td></tr>
<tr class="memdesc:a06518f303d7f7fe53b10516935fbda87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a specific DeviceQueue type is supported. <a href="#a06518f303d7f7fe53b10516935fbda87">More...</a><br/></td></tr>
<tr class="separator:a06518f303d7f7fe53b10516935fbda87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aefda4d41bc635950993e85dee5f984"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a0aefda4d41bc635950993e85dee5f984">release</a> ()=0</td></tr>
<tr class="memdesc:a0aefda4d41bc635950993e85dee5f984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the resources held by this context. <a href="#a0aefda4d41bc635950993e85dee5f984">More...</a><br/></td></tr>
<tr class="separator:a0aefda4d41bc635950993e85dee5f984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d032c6f8ca689d6a609cf045363007"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a08d032c6f8ca689d6a609cf045363007">screenCaptureRegion</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> x, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> y, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> w, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> h, <a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a> *buffer, <a class="el" href="classpvr_1_1_i_graphics_context.html#af41db73b461b76b3a0d3e7dbae32f110">ImageFormat</a> imageFormat)=0</td></tr>
<tr class="memdesc:a08d032c6f8ca689d6a609cf045363007"><td class="mdescLeft">&#160;</td><td class="mdescRight">take a screenshot in the specified buffer of the specified screen area. <a href="#a08d032c6f8ca689d6a609cf045363007">More...</a><br/></td></tr>
<tr class="separator:a08d032c6f8ca689d6a609cf045363007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a47e5d964e0ea391da4b82f838a2e9d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacepvr_1_1api.html#af939d9e7a622e7eda49f452643496ac7">api::TextureView</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a2a47e5d964e0ea391da4b82f838a2e9d">uploadTexture</a> (const ::<a class="el" href="classpvr_1_1_texture.html">pvr::Texture</a> &amp;texture, bool allowDecompress=true)=0</td></tr>
<tr class="memdesc:a2a47e5d964e0ea391da4b82f838a2e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload a texture from a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">pvr::Texture</a> object into the GPU  <a href="#a2a47e5d964e0ea391da4b82f838a2e9d">More...</a><br/></td></tr>
<tr class="separator:a2a47e5d964e0ea391da4b82f838a2e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90844cc56ec06a167335b3e31140fe69"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#a90844cc56ec06a167335b3e31140fe69">waitIdle</a> ()=0</td></tr>
<tr class="memdesc:a90844cc56ec06a167335b3e31140fe69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all pending operations are done <a href="#a90844cc56ec06a167335b3e31140fe69">More...</a><br/></td></tr>
<tr class="separator:a90844cc56ec06a167335b3e31140fe69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad5cd5c44908ade63a14718b26a40fed9"><td class="memItemLeft" align="right" valign="top">GraphicsContextStrongReference <br class="typebreak"/>
PVR_API_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html#ad5cd5c44908ade63a14718b26a40fed9">createGraphicsContext</a> ()</td></tr>
<tr class="memdesc:ad5cd5c44908ade63a14718b26a40fed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is implemented in PVRApi, in order to return a pointer to the actual Graphics Context.  <a href="#ad5cd5c44908ade63a14718b26a40fed9">More...</a><br/></td></tr>
<tr class="separator:ad5cd5c44908ade63a14718b26a40fed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for Graphics context. This interface will be used all over in user code to pass GraphicsContext objects wherever required. It represents a specific GPU configuration.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="af41db73b461b76b3a0d3e7dbae32f110"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpvr_1_1_i_graphics_context.html#af41db73b461b76b3a0d3e7dbae32f110">pvr::IGraphicsContext::ImageFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image Format.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa23111bbf08d4d113b66d52f0e46be72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::IGraphicsContext::IGraphicsContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a>&#160;</td>
          <td class="paramname"><em>apiType</em> = <code>Api::Unspecified</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Note: Object is uninitialized and unusable until <a class="el" href="classpvr_1_1_i_graphics_context.html#ac1e2f69c1ee53d2b0c9489e85f6b12cc" title="Call this function to initialize the Context using the information of a specific OSManager (usually...">init()</a> is called.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7ca73f24d5aeca36e4b15d0e65fdd539"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a84ba9b7b7a7f3ae2ff0eca7e715ec90c">api::Buffer</a> pvr::IGraphicsContext::createBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::BufferBindingUse&#160;</td>
          <td class="paramname"><em>bufferUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMappable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer object, which can then be bound as a VBO/IBO and/or shared with BufferView objects (SSBOView, VBOView)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size, in bytes, of the buffer</td></tr>
    <tr><td class="paramname">bufferUsage</td><td>The intended uses of the Buffer (VBO,IBO,UBO, Copy etc.)</td></tr>
    <tr><td class="paramname">isMappable</td><td>The buffer is mappable by the host</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly constructed Buffer object</dd></dl>

</div>
</div>
<a class="anchor" id="a7b9f066af40417d0a30e494e4c30b835"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a3e2d4659e33a054677ac12c19da5f47c">api::BufferView</a> pvr::IGraphicsContext::createBufferAndView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::BufferBindingUse&#160;</td>
          <td class="paramname"><em>bufferUsage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMappable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One-step create a new Buffer with a corresponding BufferView to the entire range of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the new VBO,</td></tr>
    <tr><td class="paramname">bufferUsage</td><td>A bitfield of all allowed buffer uses</td></tr>
    <tr><td class="paramname">isMappable</td><td>Set to true to allocate the buffer from memory that can be mapped. If this feature is not required, and the buffer will be filled from a transfer (buffer copy or cmd buffer update), set to false and ensure bufferUsage contains the TransferDst flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created BufferView of an entire a newly created Buffer object.</dd></dl>
<p>The UBO created will be representing, in Buffer, range of (offset, offset+range)</p>

</div>
</div>
<a class="anchor" id="a10ee59bbe19be7416d1240416eeda169"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a3e2d4659e33a054677ac12c19da5f47c">api::BufferView</a> pvr::IGraphicsContext::createBufferView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1api.html#a84ba9b7b7a7f3ae2ff0eca7e715ec90c">api::Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>range</em> = <code>0xFFFFFFFFu</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new Shader-Accessible view to Buffer Object (Can be used as UBO/SSBO etc), with an existing backing buffer. BufferViews allow Buffers to be added to DescriptorSets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer that the UBO will be a view of.</td></tr>
    <tr><td class="paramname">offset</td><td>The starting offset in "buffer" that the UBO will represent. Default: 0.</td></tr>
    <tr><td class="paramname">range</td><td>The size of the original buffer that this view will represent/access. Default: the remaining size of the buffer (minus offset).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created BufferView object, wrapping the specified range of the provided buffer.</dd></dl>
<p>The UBO created will be representing, in Buffer, range of (offset, offset+range)</p>

</div>
</div>
<a class="anchor" id="a526cb65d274f477e80ce29df46aea43c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#acc8893ac955643c641d731204f06d8fa">api::CommandBuffer</a> pvr::IGraphicsContext::createCommandBufferOnDefaultPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new primary CommandBuffer on the default CommandPool</p>
<dl class="section return"><dt>Returns</dt><dd>A newly created CommandBuffer. Null if failed.</dd></dl>

</div>
</div>
<a class="anchor" id="aff942ea5acfff4825542cf5bd302dd22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a7885487134a0e2a4b8e86d11c820a2c2">api::CommandPool</a> pvr::IGraphicsContext::createCommandPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new CommandPool.</p>

</div>
</div>
<a class="anchor" id="a5ad4a6b57395e2ca5d546beca0d7e2d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a608e558cf465b3183dc23fdb27b2ce03">api::ComputePipeline</a> pvr::IGraphicsContext::createComputePipeline </td>
          <td>(</td>
          <td class="paramtype">const api::ComputePipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>createParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new ComputePipeline object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParam</td><td>The CreateParameters used to create the pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly constructed ComputePipeline object. Contains NULL if creation failed.</dd></dl>

</div>
</div>
<a class="anchor" id="ac0fc100505fca0371775185ce30b8bcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a637551c1f687221f14122e0beeee2730">api::DescriptorPool</a> pvr::IGraphicsContext::createDescriptorPool </td>
          <td>(</td>
          <td class="paramtype">const api::DescriptorPoolCreateParam &amp;&#160;</td>
          <td class="paramname"><em>createParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new DescriptorPool (descriptor set allocation pool).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParam</td><td>The creation parameters used to create the descriptor pool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new DescriptorPool object. Contains NULL if failed.</dd></dl>

</div>
</div>
<a class="anchor" id="a6dd1c728578ce4139211383ef44d7eeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a51521c1bf928b30d4cb74cbdafda3710">api::DescriptorSetLayout</a> pvr::IGraphicsContext::createDescriptorSetLayout </td>
          <td>(</td>
          <td class="paramtype">const api::DescriptorSetLayoutCreateParam &amp;&#160;</td>
          <td class="paramname"><em>createParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new DescriptorSetLayout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParam</td><td>The creation parameters used to create the descriptor set layout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new DescriptorSetLayout object. Contains NULL if failed.</dd></dl>
<p>A DescriptorSetLayout contains the information required to create "compatible" descriptor sets. </p>

</div>
</div>
<a class="anchor" id="aa805fd871238223f769f9aff84e43cb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#adcc0a391e3ad0455b28b9ac4a1b2ec1a">api::DescriptorSet</a> pvr::IGraphicsContext::createDescriptorSetOnDefaultPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1api.html#a51521c1bf928b30d4cb74cbdafda3710">api::DescriptorSetLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new DescriptorSet on the PVRApi default allocation pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout</td><td>The layout of the DescriptorSet object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new DescriptorSet object</dd></dl>

</div>
</div>
<a class="anchor" id="afc591d393bfc0e648429512eb7534794"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a27b9833ef0620323502da3c3bbc9137e">api::Fbo</a> pvr::IGraphicsContext::createFbo </td>
          <td>(</td>
          <td class="paramtype">const api::FboCreateParam &amp;&#160;</td>
          <td class="paramname"><em>createParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a Framebuffer Object with specified parameters and backing image. Not for on-screen rendering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParam</td><td>The creation parameters for this Fbo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created FBO. Null if failed.</dd></dl>
<p>This method is used to create a typical GL-style FBO (an object that is normally used to render into a texture).</p>

</div>
</div>
<a class="anchor" id="abd43e7d29090ce656256d23d2fa6dc48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a5e08f2cd496ce0f091ab6df00774510a">api::FboSet</a> pvr::IGraphicsContext::createFboSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_multi.html">Multi</a>&lt; api::FboCreateParam &gt; &amp;&#160;</td>
          <td class="paramname"><em>createParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a Framebuffer Object with specified parameters and backing image. Not for on-screen rendering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParams</td><td>The creation parameters for this Fbo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created FBO. Null if failed.</dd></dl>
<p>This method is used to create a typical GL-style FBO (an object that is normally used to render into a texture).</p>

</div>
</div>
<a class="anchor" id="a2362659aef25c2142409383746c52490"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a026dbaa18337b444ba682d97038bbd19">api::Fence</a> pvr::IGraphicsContext::createFence </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createSignaled</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Fence</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createSignaled</td><td>Create Fence with signaled state</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a0b35831c0f1d935732f7b643753a8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#ab07c0f5188f9b6484e4b19ad4fd2926c">api::GraphicsPipeline</a> pvr::IGraphicsContext::createGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype">const api::GraphicsPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>createParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a GraphicsPipeline object associated with this context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParam</td><td>The CreateParameters used to create the pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly constructed GraphicsPipeline. Contains NULL if creation failed.</dd></dl>

</div>
</div>
<a class="anchor" id="a7e71e481b648d2529c8f32c287550cd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#ab07c0f5188f9b6484e4b19ad4fd2926c">api::GraphicsPipeline</a> pvr::IGraphicsContext::createGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype">const api::GraphicsPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>createParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1api.html#a29852cbd107e34395d2b61d8b12d23fd">api::ParentableGraphicsPipeline</a>&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create GraphicsPipeline as a child of another provided GraphicsPipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParam</td><td>The CreateParameters used to create the pipeline. NOTE the create param won't inherit the states from the parent pipeline. The Application must set the states that are to be inherited from parent pipeline see ParentableGraphicsPipeline::getCreateParam() function</td></tr>
    <tr><td class="paramname">parent</td><td>The parent pipeline used to create the new pipeline. If the pipeline does not belong to this context, the results are undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly constructed GraphicsPipeline object, child to "parent". Contains NULL if creation failed. </dd></dl>
<p>Use parenting to denote hierarchies of pipelines to take advantage of very important optimisations that are performed when switching from a child to a parent or a sibling and vice versa.</p>

</div>
</div>
<a class="anchor" id="a78ec82d454049fc629b18307f3b96f07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a527a8dcbcc1b10d0a68aed030faa0e11">api::IndirectRayPipeline</a> pvr::IGraphicsContext::createIndirectRayPipeline </td>
          <td>(</td>
          <td class="paramtype">const api::IndirectRayPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new IndirectRayPipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>The creation parameters used to create IndirectRayPipeline. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new IndirectRayPipeline object. Contains NULL if failed. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>A IndirectRayPipeline encapsulates all the state required for a default ray program to be created. </dd></dl>

</div>
</div>
<a class="anchor" id="a9be54d951c78a310fb2cf05fe5907c22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a27b9833ef0620323502da3c3bbc9137e">api::Fbo</a> pvr::IGraphicsContext::createOnScreenFbo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>swapIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::LoadOp&#160;</td>
          <td class="paramname"><em>colorLoadOp</em> = <code>types::LoadOp::Clear</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::StoreOp&#160;</td>
          <td class="paramname"><em>colorStoreOp</em> = <code>types::StoreOp::Store</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::LoadOp&#160;</td>
          <td class="paramname"><em>depthLoadOp</em> = <code>types::LoadOp::Clear</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::StoreOp&#160;</td>
          <td class="paramname"><em>depthStoreOp</em> = <code>types::StoreOp::Ignore</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::LoadOp&#160;</td>
          <td class="paramname"><em>stencilLoadOp</em> = <code>types::LoadOp::Clear</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::StoreOp&#160;</td>
          <td class="paramname"><em>stencilStoreOp</em> = <code>types::StoreOp::Ignore</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an FBO that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the most common parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIndex</td><td>Swapchain index</td></tr>
    <tr><td class="paramname">colorLoadOp</td><td>The Load Operation for the color attachment (Default is LoadOp::Clear, clearing the color of the screen at every frame start)</td></tr>
    <tr><td class="paramname">colorStoreOp</td><td>The Store Operation for the color attachment (Default is StoreOp::Store, storing the color before buffer swapping)</td></tr>
    <tr><td class="paramname">depthLoadOp</td><td>The Load Operation for the depth (Default is LoadOp::Clear, clearing the Depth at every frame start)</td></tr>
    <tr><td class="paramname">depthStoreOp</td><td>The Store Operation for the depth buffer (Default is StoreOp::Ignore, discarding the Depth before buffer swapping)</td></tr>
    <tr><td class="paramname">stencilLoadOp</td><td>The Load Operation for the stencil buffer (Default is LoadOp::Clear, clearing the Stencil at every frame start)</td></tr>
    <tr><td class="paramname">stencilStoreOp</td><td>The Store Operation for the stencil buffer (Default is StoreOp::Ignore, discarding the Stencil before buffer swapping)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new FBO who can be used to write to the Screen.</dd></dl>
<p>This version uses the most typical parameters used for the backbuffer, and also creates the RenderPass for the FBO. Uses a single subpass at color attachment 0. Use the FBO-&gt;getRenderPass method if you wish to retrieve the renderpass created with this method. WARNING: Defaults discard Depth and Stencil at the end of the renderpass, for performance. This may cause unintended results as it is different from default OpenGL. If you wish to preserve depth and/or stencil after the renderpass, please specify StoreOp:Store for depth and stencil.</p>

</div>
</div>
<a class="anchor" id="a71a6d9766db605ebc2ef819b372f02f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a5e08f2cd496ce0f091ab6df00774510a">api::FboSet</a> pvr::IGraphicsContext::createOnScreenFboSet </td>
          <td>(</td>
          <td class="paramtype">types::LoadOp&#160;</td>
          <td class="paramname"><em>colorLoadOp</em> = <code>types::LoadOp::Clear</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::StoreOp&#160;</td>
          <td class="paramname"><em>colorStoreOp</em> = <code>types::StoreOp::Store</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::LoadOp&#160;</td>
          <td class="paramname"><em>depthLoadOp</em> = <code>types::LoadOp::Clear</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::StoreOp&#160;</td>
          <td class="paramname"><em>depthStoreOp</em> = <code>types::StoreOp::Ignore</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::LoadOp&#160;</td>
          <td class="paramname"><em>stencilLoadOp</em> = <code>types::LoadOp::Clear</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::StoreOp&#160;</td>
          <td class="paramname"><em>stencilStoreOp</em> = <code>types::StoreOp::Ignore</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an FBO that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the most common parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorLoadOp</td><td>The Load Operation for the color attachment (Default is LoadOp::Clear, clearing the color of the screen at every frame start)</td></tr>
    <tr><td class="paramname">colorStoreOp</td><td>The Store Operation for the color attachment (Default is StoreOp::Store, storing the color before buffer swapping)</td></tr>
    <tr><td class="paramname">depthLoadOp</td><td>The Load Operation for the depth (Default is LoadOp::Clear, clearing the Depth at every frame start)</td></tr>
    <tr><td class="paramname">depthStoreOp</td><td>The Store Operation for the depth buffer (Default is StoreOp::Ignore, discarding the Depth before buffer swapping)</td></tr>
    <tr><td class="paramname">stencilLoadOp</td><td>The Load Operation for the stencil buffer (Default is LoadOp::Clear, clearing the Stencil at every frame start)</td></tr>
    <tr><td class="paramname">stencilStoreOp</td><td>The Store Operation for the stencil buffer (Default is StoreOp::Ignore, discarding the Stencil before buffer swapping)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new FBO who can be used to write to the Screen.</dd></dl>
<p>This version uses the most typical parameters used for the backbuffer, and also creates the RenderPass for the FBO. Uses a single subpass at color attachment 0. Use the FBO-&gt;getRenderPass method if you wish to retrieve the renderpass created with this method. WARNING: Defaults discard Depth and Stencil at the end of the renderpass, for performance. This may cause unintended results as it is different from default OpenGL. If you wish to preserve depth and/or stencil after the renderpass, please specify StoreOp:Store for depth and stencil.</p>

</div>
</div>
<a class="anchor" id="a1917dc0b5433c276851e0cdc7c5e594d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a5e08f2cd496ce0f091ab6df00774510a">api::FboSet</a> pvr::IGraphicsContext::createOnScreenFboSetWithRenderPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1api.html#aee83fa35189bd63f8782d17405b68916">api::RenderPass</a> &amp;&#160;</td>
          <td class="paramname"><em>renderPass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create aset of FBOs (one per backbuffer image) that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the RenderPass to use for it. compatible with the actual BackBuffer format and options - this is the user's responsibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderPass</td><td>The renderpass that the new FBO will use. Must be compatible with the backbuffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new FBO who can be used to write to the Screen.</dd></dl>
<p>This version uses a RenderPass that was provided by the user. The color and Depth/Stencil formats must be compatible with the backbuffer, otherwise results are undefined.</p>

</div>
</div>
<a class="anchor" id="ad4109f2b855df6bcfd7f92cb50b1bc6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a5e08f2cd496ce0f091ab6df00774510a">api::FboSet</a> pvr::IGraphicsContext::createOnScreenFboSetWithRenderPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1api.html#aee83fa35189bd63f8782d17405b68916">api::RenderPass</a> &amp;&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_multi.html">api::OnScreenFboCreateParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>onScreenFboCreateParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an FBO that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the RenderPass to use for it. compatible with the actual BackBuffer format and options - this is the user's responsibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderPass</td><td>The renderpass that the new FBO will use. Must be compatible with the backbuffer. </td></tr>
    <tr><td class="paramname">onScreenFboCreateParams</td><td>A vector with additional color view attachments per swap chain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new FBO who can be used to write to the Screen.</dd></dl>
<p>This version uses a RenderPass that was provided by the user. The color and Depth/Stencil formats must be compatible with the backbuffer, otherwise results are undefined.</p>

</div>
</div>
<a class="anchor" id="aac4359f34dcfd9de4d48ed5963fab26b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a27b9833ef0620323502da3c3bbc9137e">api::Fbo</a> pvr::IGraphicsContext::createOnScreenFboWithRenderPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>swapIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1api.html#aee83fa35189bd63f8782d17405b68916">api::RenderPass</a> &amp;&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const api::OnScreenFboCreateParam &amp;&#160;</td>
          <td class="paramname"><em>onScreenFboCreateParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an FBO that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the RenderPass to use for it. compatible with the actual BackBuffer format and options - this is the user's responsibility. Allows the user to specify additional color view attachments for the FBO to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderPass</td><td>The renderpass that the new FBO will use. Must be compatible with the backbuffer. </td></tr>
    <tr><td class="paramname">onScreenFboCreateParam</td><td>An additional set of creation parameters to use for the fbo.</td></tr>
    <tr><td class="paramname">swapIndex</td><td>The Index of the SwapBuffer Image (backbuffer) that the new FBO will be attached to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new FBO who can be used to write to the Screen.</dd></dl>
<p>This version uses a RenderPass that was provided by the user. The color and Depth/Stencil formats must be compatible with the backbuffer, otherwise results are undefined.</p>

</div>
</div>
<a class="anchor" id="aac9445be6aaadc785e04cf2e8a3b7d80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a27b9833ef0620323502da3c3bbc9137e">api::Fbo</a> pvr::IGraphicsContext::createOnScreenFboWithRenderPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>swapIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1api.html#aee83fa35189bd63f8782d17405b68916">api::RenderPass</a> &amp;&#160;</td>
          <td class="paramname"><em>renderPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an FBO that represents the actual backbuffer (i.e. an fbo to be used for on-screen rendering), using the RenderPass to use for it. compatible with the actual BackBuffer format and options - this is the user's responsibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderPass</td><td>The renderpass that the new FBO will use. Must be compatible with the backbuffer. </td></tr>
    <tr><td class="paramname">swapIndex</td><td>The Index of the SwapBuffer Image (backbuffer) that the new FBO will be attached to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new FBO who can be used to write to the Screen.</dd></dl>
<p>This version uses a RenderPass that was provided by the user. The color and Depth/Stencil formats must be compatible with the backbuffer, otherwise results are undefined.</p>

</div>
</div>
<a class="anchor" id="ae1978e7a7c9965fe7bc4e30d73f0321b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a29852cbd107e34395d2b61d8b12d23fd">api::ParentableGraphicsPipeline</a> pvr::IGraphicsContext::createParentableGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype">const api::GraphicsPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>createParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new parentable GraphicsPipeline object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParam</td><td>The CreateParameters used to create the pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly constructed ParentableGraphicsPipeline object. Contains NULL if creation failed.</dd></dl>
<p>ParentableGraphicsPipeline s contain additional information that allows them to be used as parents to other Graphics Pipelines.</p>

</div>
</div>
<a class="anchor" id="a0ea8bd758024fcc24260cd04ca0c33a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a34c808c2dcb00eb1fb273517d935c500">api::PipelineLayout</a> pvr::IGraphicsContext::createPipelineLayout </td>
          <td>(</td>
          <td class="paramtype">const api::PipelineLayoutCreateParam &amp;&#160;</td>
          <td class="paramname"><em>createParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new PipelineLayout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParam</td><td>The creation parameters used to create PipelineLayout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new DescriptorSetLayout object. Contains NULL if failed.</dd></dl>
<p>A PipelineLayout is required for several things, including binding descriptor sets.</p>

</div>
</div>
<a class="anchor" id="ad5a1a5672f52df3229cb63e35db1753b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#aee83fa35189bd63f8782d17405b68916">api::RenderPass</a> pvr::IGraphicsContext::createRenderPass </td>
          <td>(</td>
          <td class="paramtype">const api::RenderPassCreateParam &amp;&#160;</td>
          <td class="paramname"><em>renderPassDesc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new render pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderPassDesc</td><td>The creation parameters used to create the renderPass.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new RenderPass object. Contains NULL if failed.</dd></dl>

</div>
</div>
<a class="anchor" id="a9b1d4c9d855611b4db67f63b9f4b85c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a2cd1fd0d95a3694ae3e9c84b693f2626">api::Sampler</a> pvr::IGraphicsContext::createSampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1types_1_1_sampler_create_param.html">api::SamplerCreateParam</a> &amp;&#160;</td>
          <td class="paramname"><em>createParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new Sampler object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParam</td><td>The CreateParameters used to create the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly constructed Sampler object. Contains NULL if creation failed.</dd></dl>

</div>
</div>
<a class="anchor" id="a23e05bbadcef1b48e88a1838ffb70490"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a353f91024e36e49da60690a24e4a5ef2">api::SceneHierarchy</a> pvr::IGraphicsContext::createSceneHierarchy </td>
          <td>(</td>
          <td class="paramtype">const api::SceneHierarchyCreateParam &amp;&#160;</td>
          <td class="paramname"><em>createParam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new SceneHierarchy. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createParam</td><td>The creation parameters used to create SceneHierarchy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new SceneHierarchy object. Contains NULL if failed. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>A SceneHierarchy is used to store the result of a scene hierarchy build. </dd></dl>

</div>
</div>
<a class="anchor" id="aac52fc12df570c151b76f7aa96d29975"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#acac101df49d6cbde719d4fe15155473d">api::SceneTraversalPipeline</a> pvr::IGraphicsContext::createSceneTraversalPipeline </td>
          <td>(</td>
          <td class="paramtype">const api::SceneTraversalPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new SceneTraversalPipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>The creation parameters used to create SceneTraversalPipeline. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new SceneTraversalPipeline object. Contains NULL if failed. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>A SceneTraversalPipeline encapsulates all the state required to emit rays. </dd></dl>

</div>
</div>
<a class="anchor" id="ac80a04c710dd53f59510eea0deaecb08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a34f13eee73526c78f836fb36c30ea54b">api::SecondaryCommandBuffer</a> pvr::IGraphicsContext::createSecondaryCommandBufferOnDefaultPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new secondary CommandBuffer on the default CommandPool</p>
<dl class="section return"><dt>Returns</dt><dd>A newly created CommandBuffer. Null if failed.</dd></dl>

</div>
</div>
<a class="anchor" id="acf845c4fee52eabfcad547e9f0ae3e9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a99b21d53ebf284d84b30f18bc6cf3ffe">api::Semaphore</a> pvr::IGraphicsContext::createSemaphore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Semaphore</p>

</div>
</div>
<a class="anchor" id="a949818c3ca19b3f782896cde8c304aab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#ac733c31aec277813c9aea6cdcf3d77e4">api::Shader</a> pvr::IGraphicsContext::createShader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>shaderSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ShaderType&#160;</td>
          <td class="paramname"><em>shaderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Shader from source. Accepts an array of custom preprocessor definition directives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderSrc</td><td>The shader source, as a stream.</td></tr>
    <tr><td class="paramname">shaderType</td><td>The type of shader to create</td></tr>
    <tr><td class="paramname">defines</td><td>Optional. A pointer to an array of c-style strings containing preprocessor definition directives</td></tr>
    <tr><td class="paramname">numDefines</td><td>Optional. The number of items in the defines array.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9b4aef45c650017c9d7bd6f078fb37f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#ac733c31aec277813c9aea6cdcf3d77e4">api::Shader</a> pvr::IGraphicsContext::createShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>shaderData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ShaderType&#160;</td>
          <td class="paramname"><em>shaderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::ShaderBinaryFormat&#160;</td>
          <td class="paramname"><em>binaryFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Shader from binary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderData</td><td>The shader binary data, as a stream</td></tr>
    <tr><td class="paramname">shaderType</td><td>The type of shader to create</td></tr>
    <tr><td class="paramname">binaryFormat</td><td>The format of the data.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af023941ac10078499702daea0684e60a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#aefa9a681992c85b2e2dfad5099c6fe5e">api::TextureStore</a> pvr::IGraphicsContext::createTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> object.</p>
<dl class="section return"><dt>Returns</dt><dd>A newly created, unallocated <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a>. Contains NULL if creation failed.</dd></dl>

</div>
</div>
<a class="anchor" id="a41dfb4c26f13e1aa4a2af34230b81fc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#af939d9e7a622e7eda49f452643496ac7">api::TextureView</a> pvr::IGraphicsContext::createTextureView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1api.html#aefa9a681992c85b2e2dfad5099c6fe5e">api::TextureStore</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1types_1_1_image_subresource_range.html">types::ImageSubresourceRange</a>&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1types_1_1_swizzle_channels.html">types::SwizzleChannels</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structpvr_1_1types_1_1_swizzle_channels.html">types::SwizzleChannels</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> object.</p>
<dl class="section return"><dt>Returns</dt><dd>A newly created, unallocated <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a>. Contains NULL if creation failed.</dd></dl>

</div>
</div>
<a class="anchor" id="a6c6b794f985f986a1f5b468b67a3f5d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#af939d9e7a622e7eda49f452643496ac7">api::TextureView</a> pvr::IGraphicsContext::createTextureView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1api.html#aefa9a681992c85b2e2dfad5099c6fe5e">api::TextureStore</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1types_1_1_swizzle_channels.html">types::SwizzleChannels</a>&#160;</td>
          <td class="paramname"> = <code><a class="el" href="structpvr_1_1types_1_1_swizzle_channels.html">types::SwizzleChannels</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> object.</p>
<dl class="section return"><dt>Returns</dt><dd>A newly created, unallocated <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a>. Contains NULL if creation failed.</dd></dl>

</div>
</div>
<a class="anchor" id="aeb3c2b031bba11c6998ad8b70bfebc09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a6b511b47047d554c6347c41721b49496">api::VertexRayPipeline</a> pvr::IGraphicsContext::createVertexRayPipeline </td>
          <td>(</td>
          <td class="paramtype">const api::VertexRayPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new VertexRayPipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>The creation parameters used to create VertexRayPipeline. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new VertexRayPipeline object. Contains NULL if failed. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>A VertexRayPipeline encapsulates all the state and actions that take place when a ray intersects an object. </dd></dl>

</div>
</div>
<a class="anchor" id="aa35beac0d845f528a9355edebab7c01d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpvr_1_1_api_capabilities.html">ApiCapabilities</a>&amp; pvr::IGraphicsContext::getApiCapabilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="structpvr_1_1_api_capabilities.html" title="Struct containing the API capabilities of a specified configuration.">ApiCapabilities</a> object representing the capabilities of this GraphicsContext.</p>

</div>
</div>
<a class="anchor" id="a6215d57531f7cb4e423fd5b8431dcc8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> pvr::IGraphicsContext::getApiType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Api of this GraphicsContext.</p>

</div>
</div>
<a class="anchor" id="ad358c7d3da010c7c2c6365661b6d743a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespacepvr_1_1api.html#a7885487134a0e2a4b8e86d11c820a2c2">api::CommandPool</a>&amp; pvr::IGraphicsContext::getDefaultCommandPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default, automatically generated CommandPool</p>

</div>
</div>
<a class="anchor" id="a0ad286709a45128448b6a4a2e0a6ac47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a7885487134a0e2a4b8e86d11c820a2c2">api::CommandPool</a>&amp; pvr::IGraphicsContext::getDefaultCommandPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default, automatically generated CommandPool</p>

</div>
</div>
<a class="anchor" id="ad0843b41f8cd3b48664586248d162591"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespacepvr_1_1api.html#a637551c1f687221f14122e0beeee2730">api::DescriptorPool</a>&amp; pvr::IGraphicsContext::getDefaultDescriptorPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default, automatically generated DescriptorPool.</p>

</div>
</div>
<a class="anchor" id="a753c731edcc419ebb96a722aed7c7bed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#a637551c1f687221f14122e0beeee2730">api::DescriptorPool</a>&amp; pvr::IGraphicsContext::getDefaultDescriptorPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default, automatically generated DescriptorPool.</p>

</div>
</div>
<a class="anchor" id="ad8077aa01b3b70595222313381e57af5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structpvr_1_1_image_data_format.html">ImageDataFormat</a> pvr::IGraphicsContext::getDepthStencilImageFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the format of the depth stencil image.</p>

</div>
</div>
<a class="anchor" id="a214c666c0e03ae6170281b15a7ebb92c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1platform_1_1_display_attributes.html">platform::DisplayAttributes</a>&amp; pvr::IGraphicsContext::getDisplayAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the DisplayAttributes associated with this GraphicsContext.</p>

</div>
</div>
<a class="anchor" id="a923200f0bc70d51a0079ee65faaef510"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string pvr::IGraphicsContext::getInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print information about this <a class="el" href="classpvr_1_1_i_graphics_context.html" title="Interface for Graphics context. This interface will be used all over in user code to pass GraphicsCon...">IGraphicsContext</a>.</p>

</div>
</div>
<a class="anchor" id="ac19d078d5de4029a8b8e2c001b6021cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> pvr::IGraphicsContext::getLastSwapChainIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last swap chain index</p>

</div>
</div>
<a class="anchor" id="ac424337608e18560ba07f1317053d6f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_i_platform_context.html">IPlatformContext</a>&amp; pvr::IGraphicsContext::getPlatformContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classpvr_1_1_i_platform_context.html" title="Interface for the Platform context. Contains all the operations that the pvr::Shell and StateMachine ...">IPlatformContext</a> object powering this GraphicsContext.</p>

</div>
</div>
<a class="anchor" id="ab69e2d4c380556ff193c456c71f17d5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structpvr_1_1_image_data_format.html">ImageDataFormat</a> pvr::IGraphicsContext::getPresentationImageFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the format of the presentation image.</p>

</div>
</div>
<a class="anchor" id="a0d8ff509b1d808cc95bbf9c72edb8e78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> pvr::IGraphicsContext::getSwapChainIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current swapchain index</p>

</div>
</div>
<a class="anchor" id="aea9eff125221c7878cc5e5cd87193008"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> pvr::IGraphicsContext::getSwapChainLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="classpvr_1_1_multi.html" title="A small statically allocated array This class represents a small array of items. The array is statica...">Multi</a> buffer supported.</p>

</div>
</div>
<a class="anchor" id="ab15994854eb809ceb39451fece16d95c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::IGraphicsContext::hasApiCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpvr_1_1_api_capabilities.html#abb9320fb33b0f72d6a9097abb1c72eb2">ApiCapabilities::Enum</a>&#160;</td>
          <td class="paramname"><em>capability</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="structpvr_1_1_api_capabilities.html" title="Struct containing the API capabilities of a specified configuration.">ApiCapabilities</a> object representing the capabilities of this GraphicsContext.</p>

</div>
</div>
<a class="anchor" id="a52e098be5379bb1ba747fdcf7a5ba7a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::IGraphicsContext::hasApiCapabilityExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpvr_1_1_api_capabilities.html#abb9320fb33b0f72d6a9097abb1c72eb2">ApiCapabilities::Enum</a>&#160;</td>
          <td class="paramname"><em>capability</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="structpvr_1_1_api_capabilities.html" title="Struct containing the API capabilities of a specified configuration.">ApiCapabilities</a> object representing the capabilities of this GraphicsContext.</p>

</div>
</div>
<a class="anchor" id="aa5ffdcce60d4ad8706e84c41b986339c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::IGraphicsContext::hasApiCapabilityNatively </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpvr_1_1_api_capabilities.html#abb9320fb33b0f72d6a9097abb1c72eb2">ApiCapabilities::Enum</a>&#160;</td>
          <td class="paramname"><em>capability</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="structpvr_1_1_api_capabilities.html" title="Struct containing the API capabilities of a specified configuration.">ApiCapabilities</a> object representing the capabilities of this GraphicsContext.</p>

</div>
</div>
<a class="anchor" id="ac1e2f69c1ee53d2b0c9489e85f6b12cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">Result</a> pvr::IGraphicsContext::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_o_s_manager.html">OSManager</a> &amp;&#160;</td>
          <td class="paramname"><em>osManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function to initialize the Context using the information of a specific <a class="el" href="classpvr_1_1_o_s_manager.html" title="This interface abstracts the part of the Shell that will provide the Display and the Window so that t...">OSManager</a> (usually, the Shell instance).</p>

</div>
</div>
<a class="anchor" id="abbe93a0a76e18d5de06876d1b6c9ecc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pvr::IGraphicsContext::isExtensionSupported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr.html#ac3509eed37537ef511f3ae29ee9ad3fc">char8</a> *&#160;</td>
          <td class="paramname"><em>extension</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if a specific extension is supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>A c-style string representing the extension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the extension is supported.</dd></dl>

</div>
</div>
<a class="anchor" id="a06518f303d7f7fe53b10516935fbda87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::IGraphicsContext::isQueueSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1b">DeviceQueueType</a>&#160;</td>
          <td class="paramname"><em>queueType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if a specific DeviceQueue type is supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueType</td><td>The DeviceQueueType to query support for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if queueType is supported by this context.</dd></dl>

</div>
</div>
<a class="anchor" id="a0aefda4d41bc635950993e85dee5f984"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::IGraphicsContext::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the resources held by this context.</p>

</div>
</div>
<a class="anchor" id="a08d032c6f8ca689d6a609cf045363007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pvr::IGraphicsContext::screenCaptureRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_i_graphics_context.html#af41db73b461b76b3a0d3e7dbae32f110">ImageFormat</a>&#160;</td>
          <td class="paramname"><em>imageFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>take a screenshot in the specified buffer of the specified screen area.</p>

</div>
</div>
<a class="anchor" id="a2a47e5d964e0ea391da4b82f838a2e9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepvr_1_1api.html#af939d9e7a622e7eda49f452643496ac7">api::TextureView</a> pvr::IGraphicsContext::uploadTexture </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classpvr_1_1_texture.html">pvr::Texture</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upload a texture from a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">pvr::Texture</a> object into the GPU </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The texture to upload. Should be complete and contain valid data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Allow de-compress a compressed format if the format is not natively supported. If this is set to true, the texture is in a compressed format not supported by the GPU, and the format can be uncompressed in the CPU, the implementation will uncompress the texture and upload the uncompressed texture. If set to false, the implementation will return failure in any case the format is unsupported, even if it could have been uncompressed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The api texture to upload into. Will contain a newly created textureview even if it contained another one before.</p>
<p class="enddd">Result::Success on success, errorcode otherwise</p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a90844cc56ec06a167335b3e31140fe69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::IGraphicsContext::waitIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until all pending operations are done</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ad5cd5c44908ade63a14718b26a40fed9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GraphicsContextStrongReference PVR_API_FUNC createGraphicsContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is implemented in PVRApi, in order to return a pointer to the actual Graphics Context. </p>
<dl class="section return"><dt>Returns</dt><dd>A new GraphicsContext object. Its type will be dependent on the specific PVRApi library loaded. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRCore/Interfaces/<a class="el" href="_i_graphics_context_8h_source.html">IGraphicsContext.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
