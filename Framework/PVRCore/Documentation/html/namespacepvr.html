<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRCore: pvr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pvr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main PowerVR Framework Namespace 
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepvr_1_1api"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1api.html">api</a></td></tr>
<tr class="memdesc:namespacepvr_1_1api"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main PVRApi Namespace. In the PVRCore projects, contains interfaces and enumerations that conceptually belong to PVRApi but need to be shared with other PVR Framework projects (GraphicsContext interface, enums) <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1math"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1math.html">math</a></td></tr>
<tr class="memdesc:namespacepvr_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains mathematical functionality and classes, such as bounding box calculations, intersections etc. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1native"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1native.html">native</a></td></tr>
<tr class="memdesc:namespacepvr_1_1native"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functionality used to interface with the underlying native platform<br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1platform"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1platform.html">platform</a></td></tr>
<tr class="memdesc:namespacepvr_1_1platform"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functionality for the interaction of the Framework with the system it runs on (Console etc). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1strings"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1strings.html">strings</a></td></tr>
<tr class="memdesc:namespacepvr_1_1strings"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains several valuable helpers to assist with common string operations: Starts with, ends with, create with printf-style formatting and others.<br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html">utils</a></td></tr>
<tr class="memdesc:namespacepvr_1_1utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains assorted utility functions (test endianness, unicode conversions etc.)<br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_android_asset_stream.html">AndroidAssetStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> implementation that is used to access resources built in an Android package (apk).  <a href="classpvr_1_1_android_asset_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_api_capabilities.html">ApiCapabilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the API capabilities of a specified configuration. <a href="structpvr_1_1_api_capabilities.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_asset.html">Asset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classpvr_1_1_asset.html" title="An Asset represents an object that can be stored and loaded. Models, Textures, Effects and similar al...">Asset</a> represents an object that can be stored and loaded. Models, Textures, Effects and similar all inherit from <a class="el" href="classpvr_1_1_asset.html" title="An Asset represents an object that can be stored and loaded. Models, Textures, Effects and similar al...">Asset</a>. The class provides a Handle typedef for convenience, which is a reference-counted PVR Framework object type. Provides convenience functions for loading assets with assetReaders. <a href="classpvr_1_1_asset.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_asset_reader.html">AssetReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for an <a class="el" href="classpvr_1_1_asset_reader.html" title="Base class for an AssetReader, a class that can read Assets from a provided Stream.">AssetReader</a>, a class that can read Assets from a provided <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a>. <a href="classpvr_1_1_asset_reader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_asset_writer.html">AssetWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for Classes that can be used to write back effects to disk. <a href="classpvr_1_1_asset_writer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_bitfield.html">Bitfield</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class wrapping an arithmetic type and providing bitwise operation for its bits <a href="classpvr_1_1_bitfield.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_buffer_stream.html">BufferStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to access a block of memory as a <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a>. <a href="classpvr_1_1_buffer_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_compressed_image_data_format.html">CompressedImageDataFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a Compressed format. Compressed formats provide less information than the uncompressed format, as they can only be accessed "black box". <a href="structpvr_1_1_compressed_image_data_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_path.html">FilePath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filepath represents a Path + Filename + Extension. <a href="classpvr_1_1_file_path.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_stream.html">FileStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classpvr_1_1_file_stream.html" title="A FileStream is a Stream that is used to access a File in the filesystem of the platform. ">FileStream</a> is a <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> that is used to access a File in the filesystem of the platform.  <a href="classpvr_1_1_file_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_file_wrap_stream.html">FileWrapStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a stream that can be created from a file on which the FileWrap utility has been used to create a header from. <a href="classpvr_1_1_file_wrap_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type1.html">GeneratePixelType1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 1 channel PixelID. <a href="classpvr_1_1_generate_pixel_type1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type2.html">GeneratePixelType2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 2 channel PixelID. <a href="classpvr_1_1_generate_pixel_type2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type3.html">GeneratePixelType3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 3 channel PixelID. <a href="classpvr_1_1_generate_pixel_type3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_generate_pixel_type4.html">GeneratePixelType4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this template class to generate a 4 channel PixelID. <a href="classpvr_1_1_generate_pixel_type4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_half_float.html">HalfFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software implementation of a 16 bit floating point number. <a href="classpvr_1_1_half_float.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template denoting a hash. Specializations only - no default implementation. (int32/int64/uint32/uint64/string) <a href="structpvr_1_1hash.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_asset_provider.html">IAssetProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1_i_asset_provider.html" title="The IAssetProvider interface marks a class that provides the getAssetStream and getGraphicsContext me...">IAssetProvider</a> interface marks a class that provides the getAssetStream and getGraphicsContext methods. <a href="classpvr_1_1_i_asset_provider.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_graphics_context.html">IGraphicsContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for Graphics context. This interface will be used all over in user code to pass GraphicsContext objects wherever required. It represents a specific GPU configuration. <a href="classpvr_1_1_i_graphics_context.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_data_format.html">ImageDataFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an image format, including pixel format(channels/bits per channel), datatype and colorspace.  <a href="structpvr_1_1_image_data_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_storage_format.html">ImageStorageFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the <a class="el" href="structpvr_1_1_image_data_format.html" title="Represents an image format, including pixel format(channels/bits per channel), datatype and colorspac...">ImageDataFormat</a> with mipmaps and number of Samples. <a href="structpvr_1_1_image_storage_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_image_storage_format_compressed.html">ImageStorageFormatCompressed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a Compressed format. Compressed formats provide less information than the uncompressed format, as they can only be accessed "black box". <a href="structpvr_1_1_image_storage_format_compressed.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html">IndexedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of array (std::vector) with associative container (std::map). Supports association of names with values, and retrieval by index. <a href="classpvr_1_1_indexed_array.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_i_platform_context.html">IPlatformContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the Platform context. Contains all the operations that the pvr::Shell and StateMachine classes needs in order to be able to function (creation, destrurction, create a window, swap the buffers, and make current). Specific platform contexts (Egl, Vulkan) implement this interface. <a href="classpvr_1_1_i_platform_context.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_list_of_interfaces.html">ListOfInterfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized data structure required by the PVRApi. Is a list of variable type objects that are kept in a contiguous block of memory and are at the same time a linked list of interfaces. <a href="classpvr_1_1_list_of_interfaces.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an object capable of providing Logging functionality. This class is normally instantiated and configured, not inherited from. The components providing the Logging capability are contained in this class through interfaces, and as such can be replaced with custom components. <a href="classpvr_1_1_logger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_multi.html">Multi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small statically allocated array This class represents a small array of items. The array is statically allocated, and has at most 255 items, usually 8. It is not meant to (and cannot) be used to store large numbers of items (use a std::vector instead), rather it is meant to hold small tuples of items. The PowerVR framework utilizes this class to store tuples of one-per-swap-image items <a href="classpvr_1_1_multi.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_normalised_integer.html">NormalisedInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a Normalised Integer (an integer representing a fixed point value from 0..1). Contains functions to construct from Integer values, to convert to and from floating point values, arithmetic operators and similar. <a href="classpvr_1_1_normalised_integer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_o_s_manager.html">OSManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface abstracts the part of the Shell that will provide the Display and the Window so that the context can be initialized. <a href="classpvr_1_1_o_s_manager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1_pixel_format.html" title="The PixelFormat class fully defines a Pixel Format (channels, format, compression, bit width etc.). ">PixelFormat</a> class fully defines a Pixel Format (channels, format, compression, bit width etc.).  <a href="classpvr_1_1_pixel_format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_plane3d.html">Plane3d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the plane equation Ax + By + Cz + D = 0, where A B C are plane normal, xyz are position on the plane and D is distance to the plane. <a href="classpvr_1_1_plane3d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_rectangle.html">Rectangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing an axis-aligned rectangle. Internal representation TopLeft and size.  <a href="structpvr_1_1_rectangle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_ring_buffer.html">RingBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A classic, templated, efficient <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a> implementation. Supports operations at both ends (front, back) and dynamic resizing when full. Does not at current implementations support iterators. <a href="classpvr_1_1_ring_buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_sized_pointer.html">SizedPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer with an additional size field. <a href="classpvr_1_1_sized_pointer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to abstract streams of data (files, blocks of memory, resources etc.). In general a stream is considered something that can be read or written from. Specializations for many different types of streams are provided by the PowerVR Framework, the most commonly used ones being Files and Memory. The common interface and pointer types allow the <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> to abstract data in a very useful manner. Use the Stream::ptr_type to pass abstract streams around (it is actually an std::auto_ptr) <a href="classpvr_1_1_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_strided_buffer.html">StridedBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of raw data. Used to store raw data that is logically grouped in blocks with a stride. <a href="classpvr_1_1_strided_buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_string_hash.html">StringHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a hashed string with functionality for fast compares. <a href="classpvr_1_1_string_hash.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html">Texture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset, together with Information, Metadata and actual Pixel data. Only represents the actual data, not the API objects that may be created from it. <a href="classpvr_1_1_texture.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_area.html">TextureArea</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used by texture update functions. Represents an area of the texture to be updated. Default value: width=1, height=1, (depth=1), offsetx=0,offsety=0,offsetz=0, arrayslice=0, cubeface=0, miplevel=0 <a href="structpvr_1_1_texture_area.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html">TextureHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class mirroring the PVR <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> container format header, and which can in general represent any <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset. Contains accessors functions to facilitate using the <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> data in application code.  <a href="classpvr_1_1_texture_header.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1_texture_meta_data.html" title="The TextureMetaData class contains metadata of a texture. Metadata is any information that a texture ...">TextureMetaData</a> class contains metadata of a texture. Metadata is any information that a texture could be correctly loaded from file without. In most cases, metadata may still be necessary to actually USE the texture, such as winding orders, paddings, atlas information and others. <a href="classpvr_1_1_texture_meta_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_time.html">Time</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides functions for measuring time: current time, elapsed time etc. High performance timers are used if available by the platform. <a href="classpvr_1_1_time.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_windows_resource_stream.html">WindowsResourceStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc...">Stream</a> implementation that is used to access resources built in a MS Windows executable.  <a href="classpvr_1_1_windows_resource_stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa90cd73f0aa3430b003b48d119e94f71"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a></td></tr>
<tr class="memdesc:aa90cd73f0aa3430b003b48d119e94f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit integer unsigned type. <a href="#aa90cd73f0aa3430b003b48d119e94f71">More...</a><br/></td></tr>
<tr class="separator:aa90cd73f0aa3430b003b48d119e94f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3509eed37537ef511f3ae29ee9ad3fc"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac3509eed37537ef511f3ae29ee9ad3fc">char8</a></td></tr>
<tr class="memdesc:ac3509eed37537ef511f3ae29ee9ad3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character type. 8-bit integer signed type on all currently supported platforms. <a href="#ac3509eed37537ef511f3ae29ee9ad3fc">More...</a><br/></td></tr>
<tr class="separator:ac3509eed37537ef511f3ae29ee9ad3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9750f5ce8a4b60806a2b9424b583a129"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespacepvr.html#ac3509eed37537ef511f3ae29ee9ad3fc">char8</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a9750f5ce8a4b60806a2b9424b583a129">CharBuffer</a></td></tr>
<tr class="memdesc:a9750f5ce8a4b60806a2b9424b583a129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a buffer of Signed Bytes. Used to store raw data. <a href="#a9750f5ce8a4b60806a2b9424b583a129">More...</a><br/></td></tr>
<tr class="separator:a9750f5ce8a4b60806a2b9424b583a129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81f0f5584b71ee5b8cd3b28f16bd390"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac81f0f5584b71ee5b8cd3b28f16bd390">ErrorLogger</a> )(<a class="el" href="classpvr_1_1_logger.html#ae5ff101ab323f688c2a3887e4e2e70c2">Logger::Severity</a> severity, const <a class="el" href="namespacepvr.html#ac3509eed37537ef511f3ae29ee9ad3fc">char8</a> *,...)</td></tr>
<tr class="memdesc:ac81f0f5584b71ee5b8cd3b28f16bd390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used for some classes to allow them to log errors. static_output follows this signature.  <a href="#ac81f0f5584b71ee5b8cd3b28f16bd390">More...</a><br/></td></tr>
<tr class="separator:ac81f0f5584b71ee5b8cd3b28f16bd390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad4d995a4e0a6098a1f81aef94da2d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpvr_1_1_half_float.html">HalfFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a0ad4d995a4e0a6098a1f81aef94da2d5">float16</a></td></tr>
<tr class="memdesc:a0ad4d995a4e0a6098a1f81aef94da2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit floating point number (half-float). <a href="#a0ad4d995a4e0a6098a1f81aef94da2d5">More...</a><br/></td></tr>
<tr class="separator:a0ad4d995a4e0a6098a1f81aef94da2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92032f9aacbe1cd5d742f1e11ec0b64e"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a92032f9aacbe1cd5d742f1e11ec0b64e">float32</a></td></tr>
<tr class="memdesc:a92032f9aacbe1cd5d742f1e11ec0b64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit floating point number (single-precision float). <a href="#a92032f9aacbe1cd5d742f1e11ec0b64e">More...</a><br/></td></tr>
<tr class="separator:a92032f9aacbe1cd5d742f1e11ec0b64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726e5deff116a47e81049c721526446f"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a726e5deff116a47e81049c721526446f">float64</a></td></tr>
<tr class="memdesc:a726e5deff116a47e81049c721526446f"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit floating point number (double-precision float). <a href="#a726e5deff116a47e81049c721526446f">More...</a><br/></td></tr>
<tr class="separator:a726e5deff116a47e81049c721526446f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b4c61ffca81d2117a06c9c30d3b0ec"><td class="memItemLeft" align="right" valign="top">typedef signed short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a05b4c61ffca81d2117a06c9c30d3b0ec">int16</a></td></tr>
<tr class="memdesc:a05b4c61ffca81d2117a06c9c30d3b0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit signed integer. <a href="#a05b4c61ffca81d2117a06c9c30d3b0ec">More...</a><br/></td></tr>
<tr class="separator:a05b4c61ffca81d2117a06c9c30d3b0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496cd696ccb8dfabf94599ba8b21f00a"><td class="memItemLeft" align="right" valign="top">typedef signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a496cd696ccb8dfabf94599ba8b21f00a">int32</a></td></tr>
<tr class="memdesc:a496cd696ccb8dfabf94599ba8b21f00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit signed integer. <a href="#a496cd696ccb8dfabf94599ba8b21f00a">More...</a><br/></td></tr>
<tr class="separator:a496cd696ccb8dfabf94599ba8b21f00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb7c8cf4d3a809e3915144f0391e580"><td class="memItemLeft" align="right" valign="top">typedef signed long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7eb7c8cf4d3a809e3915144f0391e580">int64</a></td></tr>
<tr class="memdesc:a7eb7c8cf4d3a809e3915144f0391e580"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integer. <a href="#a7eb7c8cf4d3a809e3915144f0391e580">More...</a><br/></td></tr>
<tr class="separator:a7eb7c8cf4d3a809e3915144f0391e580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3702a6365aeb6a5010d42d6507852cb"><td class="memItemLeft" align="right" valign="top">typedef signed char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af3702a6365aeb6a5010d42d6507852cb">int8</a></td></tr>
<tr class="memdesc:af3702a6365aeb6a5010d42d6507852cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit signed integer. <a href="#af3702a6365aeb6a5010d42d6507852cb">More...</a><br/></td></tr>
<tr class="separator:af3702a6365aeb6a5010d42d6507852cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed002df805fdbdb1a5840f9cca51b4d"><td class="memItemLeft" align="right" valign="top">typedef std::basic_string&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1ed002df805fdbdb1a5840f9cca51b4d">string</a></td></tr>
<tr class="memdesc:a1ed002df805fdbdb1a5840f9cca51b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">String of basic characters. <a href="#a1ed002df805fdbdb1a5840f9cca51b4d">More...</a><br/></td></tr>
<tr class="separator:a1ed002df805fdbdb1a5840f9cca51b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0add7b2f029a9c711355a8f5a2f3700"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ae0add7b2f029a9c711355a8f5a2f3700">UCharBuffer</a></td></tr>
<tr class="memdesc:ae0add7b2f029a9c711355a8f5a2f3700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a buffer of Unsigned Bytes. Used to store raw data. <a href="#ae0add7b2f029a9c711355a8f5a2f3700">More...</a><br/></td></tr>
<tr class="separator:ae0add7b2f029a9c711355a8f5a2f3700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4ec5bdf3bb80dae0cb7fa12965c055"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3f4ec5bdf3bb80dae0cb7fa12965c055">uint16</a></td></tr>
<tr class="memdesc:a3f4ec5bdf3bb80dae0cb7fa12965c055"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit unsigned integer. <a href="#a3f4ec5bdf3bb80dae0cb7fa12965c055">More...</a><br/></td></tr>
<tr class="separator:a3f4ec5bdf3bb80dae0cb7fa12965c055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a97b530ff9cb298a9077ad7b4ee556"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a></td></tr>
<tr class="memdesc:a02a97b530ff9cb298a9077ad7b4ee556"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned integer. <a href="#a02a97b530ff9cb298a9077ad7b4ee556">More...</a><br/></td></tr>
<tr class="separator:a02a97b530ff9cb298a9077ad7b4ee556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693aadd10412283ed1afd703dc83560a"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a693aadd10412283ed1afd703dc83560a">uint8</a></td></tr>
<tr class="memdesc:a693aadd10412283ed1afd703dc83560a"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit unsigned integer. <a href="#a693aadd10412283ed1afd703dc83560a">More...</a><br/></td></tr>
<tr class="separator:a693aadd10412283ed1afd703dc83560a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1b3a4b714cc874e267883662058a19"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a2f1b3a4b714cc874e267883662058a19">utf16</a></td></tr>
<tr class="memdesc:a2f1b3a4b714cc874e267883662058a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-16 (unsigned) character. 16-bit unsigned integer. <a href="#a2f1b3a4b714cc874e267883662058a19">More...</a><br/></td></tr>
<tr class="separator:a2f1b3a4b714cc874e267883662058a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae281450f4795e25d5ce35d674b17249b"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ae281450f4795e25d5ce35d674b17249b">utf32</a></td></tr>
<tr class="memdesc:ae281450f4795e25d5ce35d674b17249b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-32 (unsigned) character. 32-bit unsigned integer. <a href="#ae281450f4795e25d5ce35d674b17249b">More...</a><br/></td></tr>
<tr class="separator:ae281450f4795e25d5ce35d674b17249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee58768dfb56ed9216c98178d572e17"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a9ee58768dfb56ed9216c98178d572e17">utf8</a></td></tr>
<tr class="memdesc:a9ee58768dfb56ed9216c98178d572e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UTF-8 (unsigned) character. 8-bit unsigned integer. <a href="#a9ee58768dfb56ed9216c98178d572e17">More...</a><br/></td></tr>
<tr class="separator:a9ee58768dfb56ed9216c98178d572e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98f1ed31a2f8510e608f5f9f6be2c2e"><td class="memItemLeft" align="right" valign="top">typedef wchar_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af98f1ed31a2f8510e608f5f9f6be2c2e">wchar</a></td></tr>
<tr class="memdesc:af98f1ed31a2f8510e608f5f9f6be2c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wide-character type. Platform dependent. <a href="#af98f1ed31a2f8510e608f5f9f6be2c2e">More...</a><br/></td></tr>
<tr class="separator:af98f1ed31a2f8510e608f5f9f6be2c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7141ccbfcf3422f2a5ff5e4727462648"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648aaa082f767fbc77cd47e105b86ded1cca">PVRTEX_MIPMAP</a> = (1 &lt;&lt; 8), 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648a23671adbbb6b36b70a41c08602e2564f">PVRTEX_TWIDDLE</a> = (1 &lt;&lt; 9), 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648ab99b95a8d3e3a09915f701ebd11669e0">PVRTEX_BUMPMAP</a> = (1 &lt;&lt; 10), 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648a5e73cc8fec9a5861208b97999f1cd0b2">PVRTEX_TILING</a> = (1 &lt;&lt; 11), 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648a80424d056ec65d5439dc169f1d35b625">PVRTEX_CUBEMAP</a> = (1 &lt;&lt; 12), 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648aad5d7bfcceebb69cd04ae90c0d908d5b">PVRTEX_FALSEMIPCOL</a> = (1 &lt;&lt; 13), 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648aaa409129950b394648312efe10d36586">PVRTEX_VOLUME</a> = (1 &lt;&lt; 14), 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648a572250b03ef82171e377f9c87fa5e25f">PVRTEX_ALPHA</a> = (1 &lt;&lt; 15), 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648aab9c48c3d41c2cc10f01442e1856b77c">PVRTEX_VERTICAL_FLIP</a> = (1 &lt;&lt; 16), 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648a691f6acd2426ef4b6dfbecaec8600b13">PVRTEX_PIXELTYPE</a> = 0xff, 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648a365c121026e2901f535781d41d93d3da">PVRTEX_IDENTIFIER</a> = 0x21525650, 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648aff34d9bbfcc9a6c42a07476cf6661cd9">PVRTEX_V1_HEADER_SIZE</a> = 44, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648a7ec982a2d890d48cae143c5970765ecf">PVRTC2_MIN_TEXWIDTH</a> = 16, 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648ae3decd2de15588863ccea790249edc0a">PVRTC2_MIN_TEXHEIGHT</a> = 8, 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648a997b74fc5e403a09bdb4faf5b352f7b4">PVRTC4_MIN_TEXWIDTH</a> = 8, 
<a class="el" href="namespacepvr.html#a7141ccbfcf3422f2a5ff5e4727462648a1a04f251581dd946893556f0dce39d1a">PVRTC4_MIN_TEXHEIGHT</a> = 8
<br/>
 }</td></tr>
<tr class="separator:a7141ccbfcf3422f2a5ff5e4727462648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3bfc097db46c04c4872bc7d690857b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:aee3bfc097db46c04c4872bc7d690857b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag interpreted as All mipmap levels. <a href="namespacepvr.html#aee3bfc097db46c04c4872bc7d690857b">More...</a><br/></td></tr>
<tr class="separator:aee3bfc097db46c04c4872bc7d690857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c5d1afa51512f076dd8e5844b171c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> </td></tr>
<tr class="memdesc:a74c5d1afa51512f076dd8e5844b171c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all API types supported by this implementation <a href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">More...</a><br/></td></tr>
<tr class="separator:a74c5d1afa51512f076dd8e5844b171c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbd5ce89bc8de993cf97d91512d73c0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#adbbd5ce89bc8de993cf97d91512d73c0">BaseApi</a> </td></tr>
<tr class="memdesc:adbbd5ce89bc8de993cf97d91512d73c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all API types supported by this implementation <a href="namespacepvr.html#adbbd5ce89bc8de993cf97d91512d73c0">More...</a><br/></td></tr>
<tr class="separator:adbbd5ce89bc8de993cf97d91512d73c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfc7d042b44f46e4d5dfbb32d0f16b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7cfc7d042b44f46e4d5dfbb32d0f16b1">CompressedPixelFormat</a> </td></tr>
<tr class="memdesc:a7cfc7d042b44f46e4d5dfbb32d0f16b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all known Compressed pixel formats. <a href="namespacepvr.html#a7cfc7d042b44f46e4d5dfbb32d0f16b1">More...</a><br/></td></tr>
<tr class="separator:a7cfc7d042b44f46e4d5dfbb32d0f16b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a6e9db5b1a2dfe5d226b836305ca1b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1b">DeviceQueueType</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1bad334dfcea59127bedfcdbe0a3ee7f494">DeviceQueueType::Graphics</a> = 0x01, 
<a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1baa623a8d0366bf079411aa30be45b2d10">DeviceQueueType::Compute</a> = 0x02, 
<a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1ba206202eaf7fe52b08be45313fe66d1e5">DeviceQueueType::Dma</a> = 0x04, 
<a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1baf23578fcd2a868168854ab714e7de537">DeviceQueueType::Extended</a> = 0x08, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1ba95a69acfe49f3d68ecd2e3538e14e0f6">DeviceQueueType::MemoryManagement</a>, 
<a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1ba90e05e9a960962ce73f8d350782dbbd6">DeviceQueueType::RayTracing</a> = 0x00000010, 
<a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1badd4c3a0262992b448aaf8d22de6428e0">DeviceQueueType::SceneGenerator</a> = 0x00000020
<br/>
 }</td></tr>
<tr class="memdesc:a62a6e9db5b1a2dfe5d226b836305ca1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all types of DeviceQueue. <a href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1b">More...</a><br/></td></tr>
<tr class="separator:a62a6e9db5b1a2dfe5d226b836305ca1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f59f3b07a9eef11ccc1f34434bbcafa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6f59f3b07a9eef11ccc1f34434bbcafa">FrameworkCaps</a> { <a class="el" href="namespacepvr.html#a6f59f3b07a9eef11ccc1f34434bbcafaa51f97cef6d79d61c32e806eb68eb046f">FrameworkCaps::MaxColorAttachments</a> = 8
 }</td></tr>
<tr class="separator:a6f59f3b07a9eef11ccc1f34434bbcafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5fa1488e4ba61dd568718646a8c73d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">Result</a> </td></tr>
<tr class="memdesc:a1c5fa1488e4ba61dd568718646a8c73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-defined Result codes (success and generic errors). <a href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">More...</a><br/></td></tr>
<tr class="separator:a1c5fa1488e4ba61dd568718646a8c73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7d779089afe1df56a1bf542134d0d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a> </td></tr>
<tr class="memdesc:a8be7d779089afe1df56a1bf542134d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the formats directly supported by the Framework. <a href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">More...</a><br/></td></tr>
<tr class="separator:a8be7d779089afe1df56a1bf542134d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7777c11dfff8fcf4a03d85e5ab0b98"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> </td></tr>
<tr class="memdesc:a6f7777c11dfff8fcf4a03d85e5ab0b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Datatypes. <a href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">More...</a><br/></td></tr>
<tr class="separator:a6f7777c11dfff8fcf4a03d85e5ab0b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3166dd9130684c23ff89682e4b38c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8">VsyncMode</a> { <br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8ad15305d7a4e34e02489c74a5ef542f36">VsyncMode::Off</a>, 
<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8a521c36a31c2762741cf0f8890cbe05e3">VsyncMode::On</a>, 
<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8a4160be5df3fc34c3b165f28616f1bd16">VsyncMode::Relaxed</a>, 
<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8a2dcff8c037093c5d3552ad532e603f9f">VsyncMode::Mailbox</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8ac48615a1bc4197056d522af276aa5a85">VsyncMode::Half</a>
<br/>
 }</td></tr>
<tr class="separator:a7f3166dd9130684c23ff89682e4b38c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0303f68824c30e29b02875302cd75d96"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a0303f68824c30e29b02875302cd75d96">apiCode</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api)</td></tr>
<tr class="memdesc:a0303f68824c30e29b02875302cd75d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the api code <a href="#a0303f68824c30e29b02875302cd75d96">More...</a><br/></td></tr>
<tr class="separator:a0303f68824c30e29b02875302cd75d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e39bf9a267425bc06d61d9a0130f6ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6e39bf9a267425bc06d61d9a0130f6ea">apiFamilyMax</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api)</td></tr>
<tr class="memdesc:a6e39bf9a267425bc06d61d9a0130f6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the api family max version <a href="#a6e39bf9a267425bc06d61d9a0130f6ea">More...</a><br/></td></tr>
<tr class="separator:a6e39bf9a267425bc06d61d9a0130f6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec9f9921823c5b479a99d3a5f8a3457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a8ec9f9921823c5b479a99d3a5f8a3457">apiFamilyMin</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api)</td></tr>
<tr class="memdesc:a8ec9f9921823c5b479a99d3a5f8a3457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the api family min version <a href="#a8ec9f9921823c5b479a99d3a5f8a3457">More...</a><br/></td></tr>
<tr class="separator:a8ec9f9921823c5b479a99d3a5f8a3457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0940447f72ad2b8777a37cd3181b5c9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ac0940447f72ad2b8777a37cd3181b5c9">apiName</a> (<a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> api)</td></tr>
<tr class="memdesc:ac0940447f72ad2b8777a37cd3181b5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the api name string of the given Enumeration <a href="#ac0940447f72ad2b8777a37cd3181b5c9">More...</a><br/></td></tr>
<tr class="separator:ac0940447f72ad2b8777a37cd3181b5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576584b43300e762dbade2201b702df2"><td class="memItemLeft" align="right" valign="top">GraphicsContextStrongReference <br class="typebreak"/>
PVR_API_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a576584b43300e762dbade2201b702df2">createGraphicsContext</a> ()</td></tr>
<tr class="memdesc:a576584b43300e762dbade2201b702df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is implemented in PVRApi, in order to return a pointer to the actual Graphics Context.  <a href="#a576584b43300e762dbade2201b702df2">More...</a><br/></td></tr>
<tr class="separator:a576584b43300e762dbade2201b702df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a73ab7268cf7790b6f2b0cd1f434608"><td class="memItemLeft" align="right" valign="top">std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1_i_platform_context.html">IPlatformContext</a> &gt;<br class="typebreak"/>
 PVR_API_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a6a73ab7268cf7790b6f2b0cd1f434608">createNativePlatformContext</a> (<a class="el" href="classpvr_1_1_o_s_manager.html">OSManager</a> &amp;osManager)</td></tr>
<tr class="memdesc:a6a73ab7268cf7790b6f2b0cd1f434608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a smart pointer to the Platform context depending on the platform. Implemented in the specific PVRNativeApi to return the correct type of context required. <a href="#a6a73ab7268cf7790b6f2b0cd1f434608">More...</a><br/></td></tr>
<tr class="separator:a6a73ab7268cf7790b6f2b0cd1f434608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5486ebd5e2197fa607b0fc29c7850742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a5486ebd5e2197fa607b0fc29c7850742">getTextureFormatFromFilename</a> (const char *assetname)</td></tr>
<tr class="memdesc:a5486ebd5e2197fa607b0fc29c7850742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the texture format from a filename. <a href="#a5486ebd5e2197fa607b0fc29c7850742">More...</a><br/></td></tr>
<tr class="separator:a5486ebd5e2197fa607b0fc29c7850742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82539b99e24e7d908dfc9054331ee2f"><td class="memTemplParams" colspan="2">template&lt;typename T1_ &gt; </td></tr>
<tr class="memitem:af82539b99e24e7d908dfc9054331ee2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#af82539b99e24e7d908dfc9054331ee2f">hash32_32</a> (const T1_ &amp;t)</td></tr>
<tr class="memdesc:af82539b99e24e7d908dfc9054331ee2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object hashing to 32 bit values into a 32 bit unsigned integer. <a href="#af82539b99e24e7d908dfc9054331ee2f">More...</a><br/></td></tr>
<tr class="separator:af82539b99e24e7d908dfc9054331ee2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e014591a7987f32c1ece4744260307c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a0e014591a7987f32c1ece4744260307c">hash32_bytes</a> (const void *bytes, size_t count)</td></tr>
<tr class="memdesc:a0e014591a7987f32c1ece4744260307c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object hashing a number of bytes into a 32 bit unsigned integer. <a href="#a0e014591a7987f32c1ece4744260307c">More...</a><br/></td></tr>
<tr class="separator:a0e014591a7987f32c1ece4744260307c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e870d81dc33ead75e7ac7e0380e7b43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3e870d81dc33ead75e7ac7e0380e7b43">PVRTDecompressETC</a> (const void *srcData, unsigned int xDim, unsigned int yDim, void *destData, int mode)</td></tr>
<tr class="memdesc:a3e870d81dc33ead75e7ac7e0380e7b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses ETC to RGBA 8888. <a href="#a3e870d81dc33ead75e7ac7e0380e7b43">More...</a><br/></td></tr>
<tr class="separator:a3e870d81dc33ead75e7ac7e0380e7b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eff095fd53269c754c4f3b02499ace"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a53eff095fd53269c754c4f3b02499ace">PVRTDecompressPVRTC</a> (const void *compressedData, int do2bitMode, int xDim, int yDim, unsigned char *outResultImage)</td></tr>
<tr class="memdesc:a53eff095fd53269c754c4f3b02499ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses PVRTC to RGBA 8888. <a href="#a53eff095fd53269c754c4f3b02499ace">More...</a><br/></td></tr>
<tr class="separator:a53eff095fd53269c754c4f3b02499ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e73b56533c028c46d6d5d55f1e70f00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a92032f9aacbe1cd5d742f1e11ec0b64e">float32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a7e73b56533c028c46d6d5d55f1e70f00">randomrange</a> (<a class="el" href="namespacepvr.html#a92032f9aacbe1cd5d742f1e11ec0b64e">float32</a> min, <a class="el" href="namespacepvr.html#a92032f9aacbe1cd5d742f1e11ec0b64e">float32</a> max)</td></tr>
<tr class="memdesc:a7e73b56533c028c46d6d5d55f1e70f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random Number between min and max <a href="#a7e73b56533c028c46d6d5d55f1e70f00">More...</a><br/></td></tr>
<tr class="separator:a7e73b56533c028c46d6d5d55f1e70f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37496ce30d200726b9bef9242ba09067"><td class="memTemplParams" colspan="2">template&lt;typename T1_ &gt; </td></tr>
<tr class="memitem:a37496ce30d200726b9bef9242ba09067"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T1_, sizeof(T1_)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a37496ce30d200726b9bef9242ba09067">readBits</a> (const T1_ &amp;value)</td></tr>
<tr class="memdesc:a37496ce30d200726b9bef9242ba09067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the bits of a value in a static array of char. <a href="#a37496ce30d200726b9bef9242ba09067">More...</a><br/></td></tr>
<tr class="separator:a37496ce30d200726b9bef9242ba09067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f231dbfb5ad9022123a9972f169854"><td class="memTemplParams" colspan="2">template&lt;typename Toutput_ , typename Tinput_ &gt; </td></tr>
<tr class="memitem:a76f231dbfb5ad9022123a9972f169854"><td class="memTemplItemLeft" align="right" valign="top">Toutput_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a76f231dbfb5ad9022123a9972f169854">reinterpretBits</a> (const Tinput_ &amp;value)</td></tr>
<tr class="memdesc:a76f231dbfb5ad9022123a9972f169854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a value's bit representation and reinterpret them as another type. Second template parameter should normally be implicitly declared. First template parameter is mandatory. <a href="#a76f231dbfb5ad9022123a9972f169854">More...</a><br/></td></tr>
<tr class="separator:a76f231dbfb5ad9022123a9972f169854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51280ed25278cee3f54f412a863158ad"><td class="memTemplParams" colspan="2">template&lt;typename Item &gt; </td></tr>
<tr class="memitem:a51280ed25278cee3f54f412a863158ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a51280ed25278cee3f54f412a863158ad">swap</a> (<a class="el" href="classpvr_1_1_ring_buffer.html">RingBuffer</a>&lt; Item &gt; &amp;left, <a class="el" href="classpvr_1_1_ring_buffer.html">RingBuffer</a>&lt; Item &gt; &amp;right)</td></tr>
<tr class="memdesc:a51280ed25278cee3f54f412a863158ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A swap function for the <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a>. Efficiently exchanges the items between two ring buffers. No actual item copies happen. <a href="#a51280ed25278cee3f54f412a863158ad">More...</a><br/></td></tr>
<tr class="separator:a51280ed25278cee3f54f412a863158ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e94c2ba31753bbeee3f63aa9d68d97"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#ab1e94c2ba31753bbeee3f63aa9d68d97">textureOffset2D</a> (uint64 x, uint64 y, uint64 width)</td></tr>
<tr class="memdesc:ab1e94c2ba31753bbeee3f63aa9d68d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the offset of a 2D texture <a href="#ab1e94c2ba31753bbeee3f63aa9d68d97">More...</a><br/></td></tr>
<tr class="separator:ab1e94c2ba31753bbeee3f63aa9d68d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e18a200f3f0d5c265df5a852f5ee801"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a2e18a200f3f0d5c265df5a852f5ee801">textureOffset3D</a> (uint64 x, uint64 y, uint64 z, uint64 width, uint64 height)</td></tr>
<tr class="memdesc:a2e18a200f3f0d5c265df5a852f5ee801"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the offset of 3D texture <a href="#a2e18a200f3f0d5c265df5a852f5ee801">More...</a><br/></td></tr>
<tr class="separator:a2e18a200f3f0d5c265df5a852f5ee801"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3c0ab02bcc448423ae5efc03f357d75c"><td class="memItemLeft" align="right" valign="top">extern::pvr::Logger&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html#a3c0ab02bcc448423ae5efc03f357d75c">Log</a></td></tr>
<tr class="memdesc:a3c0ab02bcc448423ae5efc03f357d75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">&mdash; GLOBAL OBJECT THAT IS NORMALLY THE DEFAULT LOG &mdash; Use to log your issues. <a href="#a3c0ab02bcc448423ae5efc03f357d75c">More...</a><br/></td></tr>
<tr class="separator:a3c0ab02bcc448423ae5efc03f357d75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main PowerVR Framework Namespace</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aa90cd73f0aa3430b003b48d119e94f71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">pvr::byte</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8-bit integer unsigned type.</p>

</div>
</div>
<a class="anchor" id="ac3509eed37537ef511f3ae29ee9ad3fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="namespacepvr.html#ac3509eed37537ef511f3ae29ee9ad3fc">pvr::char8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Character type. 8-bit integer signed type on all currently supported platforms.</p>

</div>
</div>
<a class="anchor" id="a9750f5ce8a4b60806a2b9424b583a129"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespacepvr.html#ac3509eed37537ef511f3ae29ee9ad3fc">char8</a>&gt; <a class="el" href="namespacepvr.html#a9750f5ce8a4b60806a2b9424b583a129">pvr::CharBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a buffer of Signed Bytes. Used to store raw data.</p>

</div>
</div>
<a class="anchor" id="ac81f0f5584b71ee5b8cd3b28f16bd390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pvr::ErrorLogger)(<a class="el" href="classpvr_1_1_logger.html#ae5ff101ab323f688c2a3887e4e2e70c2">Logger::Severity</a> severity, const <a class="el" href="namespacepvr.html#ac3509eed37537ef511f3ae29ee9ad3fc">char8</a> *,...)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback used for some classes to allow them to log errors. static_output follows this signature. </p>

</div>
</div>
<a class="anchor" id="a0ad4d995a4e0a6098a1f81aef94da2d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpvr_1_1_half_float.html">HalfFloat</a> <a class="el" href="namespacepvr.html#a0ad4d995a4e0a6098a1f81aef94da2d5">pvr::float16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16-bit floating point number (half-float).</p>

</div>
</div>
<a class="anchor" id="a92032f9aacbe1cd5d742f1e11ec0b64e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="namespacepvr.html#a92032f9aacbe1cd5d742f1e11ec0b64e">pvr::float32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32-bit floating point number (single-precision float).</p>

</div>
</div>
<a class="anchor" id="a726e5deff116a47e81049c721526446f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespacepvr.html#a726e5deff116a47e81049c721526446f">pvr::float64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit floating point number (double-precision float).</p>

</div>
</div>
<a class="anchor" id="a05b4c61ffca81d2117a06c9c30d3b0ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef signed short <a class="el" href="namespacepvr.html#a05b4c61ffca81d2117a06c9c30d3b0ec">pvr::int16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16-bit signed integer.</p>

</div>
</div>
<a class="anchor" id="a496cd696ccb8dfabf94599ba8b21f00a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef signed int <a class="el" href="namespacepvr.html#a496cd696ccb8dfabf94599ba8b21f00a">pvr::int32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32-bit signed integer.</p>

</div>
</div>
<a class="anchor" id="a7eb7c8cf4d3a809e3915144f0391e580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef signed long long <a class="el" href="namespacepvr.html#a7eb7c8cf4d3a809e3915144f0391e580">pvr::int64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit signed integer.</p>

</div>
</div>
<a class="anchor" id="af3702a6365aeb6a5010d42d6507852cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef signed char <a class="el" href="namespacepvr.html#af3702a6365aeb6a5010d42d6507852cb">pvr::int8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8-bit signed integer.</p>

</div>
</div>
<a class="anchor" id="a1ed002df805fdbdb1a5840f9cca51b4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::basic_string&lt;char&gt; <a class="el" href="namespacepvr.html#a1ed002df805fdbdb1a5840f9cca51b4d">pvr::string</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String of basic characters.</p>

</div>
</div>
<a class="anchor" id="ae0add7b2f029a9c711355a8f5a2f3700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a>&gt; <a class="el" href="namespacepvr.html#ae0add7b2f029a9c711355a8f5a2f3700">pvr::UCharBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a buffer of Unsigned Bytes. Used to store raw data.</p>

</div>
</div>
<a class="anchor" id="a3f4ec5bdf3bb80dae0cb7fa12965c055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="namespacepvr.html#a3f4ec5bdf3bb80dae0cb7fa12965c055">pvr::uint16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16-bit unsigned integer.</p>

</div>
</div>
<a class="anchor" id="a02a97b530ff9cb298a9077ad7b4ee556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">pvr::uint32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32-bit unsigned integer.</p>

</div>
</div>
<a class="anchor" id="a693aadd10412283ed1afd703dc83560a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacepvr.html#a693aadd10412283ed1afd703dc83560a">pvr::uint8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8-bit unsigned integer.</p>

</div>
</div>
<a class="anchor" id="a2f1b3a4b714cc874e267883662058a19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="namespacepvr.html#a2f1b3a4b714cc874e267883662058a19">pvr::utf16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A UTF-16 (unsigned) character. 16-bit unsigned integer.</p>

</div>
</div>
<a class="anchor" id="ae281450f4795e25d5ce35d674b17249b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespacepvr.html#ae281450f4795e25d5ce35d674b17249b">pvr::utf32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A UTF-32 (unsigned) character. 32-bit unsigned integer.</p>

</div>
</div>
<a class="anchor" id="a9ee58768dfb56ed9216c98178d572e17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacepvr.html#a9ee58768dfb56ed9216c98178d572e17">pvr::utf8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A UTF-8 (unsigned) character. 8-bit unsigned integer.</p>

</div>
</div>
<a class="anchor" id="af98f1ed31a2f8510e608f5f9f6be2c2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef wchar_t <a class="el" href="namespacepvr.html#af98f1ed31a2f8510e608f5f9f6be2c2e">pvr::wchar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wide-character type. Platform dependent.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648aaa082f767fbc77cd47e105b86ded1cca"></a>PVRTEX_MIPMAP</em>&#160;</td><td class="fielddoc">
<p>Has mip map levels. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648a23671adbbb6b36b70a41c08602e2564f"></a>PVRTEX_TWIDDLE</em>&#160;</td><td class="fielddoc">
<p>Is twiddled. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648ab99b95a8d3e3a09915f701ebd11669e0"></a>PVRTEX_BUMPMAP</em>&#160;</td><td class="fielddoc">
<p>Has normals encoded for a bump map. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648a5e73cc8fec9a5861208b97999f1cd0b2"></a>PVRTEX_TILING</em>&#160;</td><td class="fielddoc">
<p>Is bordered for tiled pvr. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648a80424d056ec65d5439dc169f1d35b625"></a>PVRTEX_CUBEMAP</em>&#160;</td><td class="fielddoc">
<p>Is a cubemap/skybox. DEPRECATED.}. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648aad5d7bfcceebb69cd04ae90c0d908d5b"></a>PVRTEX_FALSEMIPCOL</em>&#160;</td><td class="fielddoc">
<p>Are there false colored MIP levels. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648aaa409129950b394648312efe10d36586"></a>PVRTEX_VOLUME</em>&#160;</td><td class="fielddoc">
<p>Is this a volume texture. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648a572250b03ef82171e377f9c87fa5e25f"></a>PVRTEX_ALPHA</em>&#160;</td><td class="fielddoc">
<p>v2.1. Is there transparency info in the texture. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648aab9c48c3d41c2cc10f01442e1856b77c"></a>PVRTEX_VERTICAL_FLIP</em>&#160;</td><td class="fielddoc">
<p>v2.1. Is the texture vertically flipped. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648a691f6acd2426ef4b6dfbecaec8600b13"></a>PVRTEX_PIXELTYPE</em>&#160;</td><td class="fielddoc">
<p>Pixel type is always in the last 16bits of the flags. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648a365c121026e2901f535781d41d93d3da"></a>PVRTEX_IDENTIFIER</em>&#160;</td><td class="fielddoc">
<p>The pvr identifier is the characters 'P','V','R'. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648aff34d9bbfcc9a6c42a07476cf6661cd9"></a>PVRTEX_V1_HEADER_SIZE</em>&#160;</td><td class="fielddoc">
<p>Old header size was 44 for identification purposes. DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648a7ec982a2d890d48cae143c5970765ecf"></a>PVRTC2_MIN_TEXWIDTH</em>&#160;</td><td class="fielddoc">
<p>DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648ae3decd2de15588863ccea790249edc0a"></a>PVRTC2_MIN_TEXHEIGHT</em>&#160;</td><td class="fielddoc">
<p>DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648a997b74fc5e403a09bdb4faf5b352f7b4"></a>PVRTC4_MIN_TEXWIDTH</em>&#160;</td><td class="fielddoc">
<p>DEPRECATED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7141ccbfcf3422f2a5ff5e4727462648a1a04f251581dd946893556f0dce39d1a"></a>PVRTC4_MIN_TEXHEIGHT</em>&#160;</td><td class="fielddoc">
<p>DEPRECATED. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aee3bfc097db46c04c4872bc7d690857b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag interpreted as All mipmap levels.</p>

</div>
</div>
<a class="anchor" id="a74c5d1afa51512f076dd8e5844b171c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">pvr::Api</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all API types supported by this implementation</p>

</div>
</div>
<a class="anchor" id="adbbd5ce89bc8de993cf97d91512d73c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#adbbd5ce89bc8de993cf97d91512d73c0">pvr::BaseApi</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all API types supported by this implementation</p>

</div>
</div>
<a class="anchor" id="a7cfc7d042b44f46e4d5dfbb32d0f16b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a7cfc7d042b44f46e4d5dfbb32d0f16b1">pvr::CompressedPixelFormat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all known Compressed pixel formats.</p>

</div>
</div>
<a class="anchor" id="a62a6e9db5b1a2dfe5d226b836305ca1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a62a6e9db5b1a2dfe5d226b836305ca1b">pvr::DeviceQueueType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of all types of DeviceQueue.</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a62a6e9db5b1a2dfe5d226b836305ca1bad334dfcea59127bedfcdbe0a3ee7f494"></a>Graphics</em>&#160;</td><td class="fielddoc">
<p>graphics operations </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a62a6e9db5b1a2dfe5d226b836305ca1baa623a8d0366bf079411aa30be45b2d10"></a>Compute</em>&#160;</td><td class="fielddoc">
<p>compute operations </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a62a6e9db5b1a2dfe5d226b836305ca1ba206202eaf7fe52b08be45313fe66d1e5"></a>Dma</em>&#160;</td><td class="fielddoc">
<p>DMA operations. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a62a6e9db5b1a2dfe5d226b836305ca1baf23578fcd2a868168854ab714e7de537"></a>Extended</em>&#160;</td><td class="fielddoc">
<p>extended operations </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a62a6e9db5b1a2dfe5d226b836305ca1ba95a69acfe49f3d68ecd2e3538e14e0f6"></a>MemoryManagement</em>&#160;</td><td class="fielddoc">
<p>memory management operations </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a62a6e9db5b1a2dfe5d226b836305ca1ba90e05e9a960962ce73f8d350782dbbd6"></a>RayTracing</em>&#160;</td><td class="fielddoc">
<p>ray tracing </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a62a6e9db5b1a2dfe5d226b836305ca1badd4c3a0262992b448aaf8d22de6428e0"></a>SceneGenerator</em>&#160;</td><td class="fielddoc">
<p>scene generator </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a6f59f3b07a9eef11ccc1f34434bbcafa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a6f59f3b07a9eef11ccc1f34434bbcafa">pvr::FrameworkCaps</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a6f59f3b07a9eef11ccc1f34434bbcafaa51f97cef6d79d61c32e806eb68eb046f"></a>MaxColorAttachments</em>&#160;</td><td class="fielddoc">
<p>Max Color attachment supported by the fbo. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1c5fa1488e4ba61dd568718646a8c73d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a1c5fa1488e4ba61dd568718646a8c73d">pvr::Result</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-defined Result codes (success and generic errors).</p>

</div>
</div>
<a class="anchor" id="a8be7d779089afe1df56a1bf542134d0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">pvr::TextureFileFormat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates the formats directly supported by the Framework.</p>

</div>
</div>
<a class="anchor" id="a6f7777c11dfff8fcf4a03d85e5ab0b98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">pvr::VariableType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of Datatypes.</p>

</div>
</div>
<a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepvr.html#a7f3166dd9130684c23ff89682e4b38c8">pvr::VsyncMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8ad15305d7a4e34e02489c74a5ef542f36"></a>Off</em>&#160;</td><td class="fielddoc">
<p>The application does not synchronizes with the vertical sync. If application renders faster than the display refreshes, frames are wasted and tearing may be observed. FPS is uncapped. Maximum power consumption. If unsupported, "ON" value will be used instead. Minimum latency. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8a521c36a31c2762741cf0f8890cbe05e3"></a>On</em>&#160;</td><td class="fielddoc">
<p>The application is always syncrhonized with the vertical sync. Tearing does not happen. FPS is capped to the display's refresh rate. For fast applications, battery life is improved. Always supported. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8a4160be5df3fc34c3b165f28616f1bd16"></a>Relaxed</em>&#160;</td><td class="fielddoc">
<p>The application synchronizes with the vertical sync, but only if the application rendering speed is greater than refresh rate. Compared to OFF, there is no tearing. Compared to ON, the FPS will be improved for "slower" applications. If unsupported, "ON" value will be used instead. Recommended for most applications. Default if supported. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8a2dcff8c037093c5d3552ad532e603f9f"></a>Mailbox</em>&#160;</td><td class="fielddoc">
<p>The presentation engine will always use the latest fully rendered image. Compared to OFF, no tearing will be observed. Compared to ON, battery power will be worse, especially for faster applications. If unsupported, "OFF" will be attempted next. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7f3166dd9130684c23ff89682e4b38c8ac48615a1bc4197056d522af276aa5a85"></a>Half</em>&#160;</td><td class="fielddoc">
<p>The application is capped to using half the vertical sync time. FPS artificially capped to Half the display speed (usually 30fps) to maintain battery. Best possible battery savings. Worst possibly performance. Recommended for specific applications where battery saving is critical. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0303f68824c30e29b02875302cd75d96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::apiCode </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the api code</p>
<dl class="section return"><dt>Returns</dt><dd>Api code</dd></dl>

</div>
</div>
<a class="anchor" id="a6e39bf9a267425bc06d61d9a0130f6ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> pvr::apiFamilyMax </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the api family max version</p>
<dl class="section return"><dt>Returns</dt><dd>Api family Max</dd></dl>

</div>
</div>
<a class="anchor" id="a8ec9f9921823c5b479a99d3a5f8a3457"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a74c5d1afa51512f076dd8e5844b171c8">Api</a> pvr::apiFamilyMin </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the api family min version</p>
<dl class="section return"><dt>Returns</dt><dd>Api family min</dd></dl>

</div>
</div>
<a class="anchor" id="ac0940447f72ad2b8777a37cd3181b5c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::apiName </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the api name string of the given Enumeration</p>
<dl class="section return"><dt>Returns</dt><dd>Api name string</dd></dl>

</div>
</div>
<a class="anchor" id="a576584b43300e762dbade2201b702df2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GraphicsContextStrongReference PVR_API_FUNC pvr::createGraphicsContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is implemented in PVRApi, in order to return a pointer to the actual Graphics Context. </p>
<dl class="section return"><dt>Returns</dt><dd>A new GraphicsContext object. Its type will be dependent on the specific PVRApi library loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a73ab7268cf7790b6f2b0cd1f434608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="classpvr_1_1_i_platform_context.html">IPlatformContext</a>&gt; PVR_API_FUNC pvr::createNativePlatformContext </td>
          <td>(</td>
          <td class="paramtype">OSManager &amp;&#160;</td>
          <td class="paramname"><em>osManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and returns a smart pointer to the Platform context depending on the platform. Implemented in the specific PVRNativeApi to return the correct type of context required.</p>

</div>
</div>
<a class="anchor" id="a5486ebd5e2197fa607b0fc29c7850742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a> pvr::getTextureFormatFromFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>assetname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the texture format from a filename.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assetname</td><td>The name of the asset, containing the extension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The TextureFileFormat if understood, otherwise TextureFileFormat::Unknown.</dd></dl>

</div>
</div>
<a class="anchor" id="af82539b99e24e7d908dfc9054331ee2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> pvr::hash32_32 </td>
          <td>(</td>
          <td class="paramtype">const T1_ &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function object hashing to 32 bit values into a 32 bit unsigned integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The value to hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1_</td><td>The type of the value to hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash of the value.</dd></dl>

</div>
</div>
<a class="anchor" id="a0e014591a7987f32c1ece4744260307c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> pvr::hash32_bytes </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function object hashing a number of bytes into a 32 bit unsigned integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Pointer to a block of memory.</td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash of the value.</dd></dl>

</div>
</div>
<a class="anchor" id="a3e870d81dc33ead75e7ac7e0380e7b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr::PVRTDecompressETC </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>srcData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>yDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompresses ETC to RGBA 8888.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcData</td><td>The ETC texture data to decompress</td></tr>
    <tr><td class="paramname">xDim</td><td>X dimension of the texture</td></tr>
    <tr><td class="paramname">yDim</td><td>Y dimension of the texture</td></tr>
    <tr><td class="paramname">destData</td><td>The decompressed texture data</td></tr>
    <tr><td class="paramname">mode</td><td>The format of the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The number of bytes of ETC data decompressed</dd></dl>

</div>
</div>
<a class="anchor" id="a53eff095fd53269c754c4f3b02499ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr::PVRTDecompressPVRTC </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>compressedData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do2bitMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>outResultImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompresses PVRTC to RGBA 8888.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compressedData</td><td>The PVRTC texture data to decompress</td></tr>
    <tr><td class="paramname">do2bitMode</td><td>Signifies whether the data is PVRTC2 or PVRTC4</td></tr>
    <tr><td class="paramname">xDim</td><td>X dimension of the texture</td></tr>
    <tr><td class="paramname">yDim</td><td>Y dimension of the texture</td></tr>
    <tr><td class="paramname">outResultImage</td><td>The decompressed texture data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the amount of data that was decompressed.</dd></dl>

</div>
</div>
<a class="anchor" id="a7e73b56533c028c46d6d5d55f1e70f00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a92032f9aacbe1cd5d742f1e11ec0b64e">float32</a> pvr::randomrange </td>
          <td>(</td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a random Number between min and max</p>
<dl class="section return"><dt>Returns</dt><dd>Random number</dd></dl>

</div>
</div>
<a class="anchor" id="a37496ce30d200726b9bef9242ba09067"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T1_, sizeof(T1_)&gt; pvr::readBits </td>
          <td>(</td>
          <td class="paramtype">const T1_ &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the bits of a value in a static array of char.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to reinterpret</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1_</td><td>Input value type. Should not need to be explicitly defined, can be inferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A StaticArray&lt;T1_&gt; with a size exactly equal to the size of T1_ in characters, containing the bit representation of value.</dd></dl>

</div>
</div>
<a class="anchor" id="a76f231dbfb5ad9022123a9972f169854"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Toutput_ , typename Tinput_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Toutput_ pvr::reinterpretBits </td>
          <td>(</td>
          <td class="paramtype">const Tinput_ &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a value's bit representation and reinterpret them as another type. Second template parameter should normally be implicitly declared. First template parameter is mandatory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to reinterpret</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Toutput_</td><td>Output value type. Must be explicitly defined.</td></tr>
    <tr><td class="paramname">Tinput_</td><td>Input value type. Should not need to be explicitly defined, can be inferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reinterpreted value</dd></dl>

</div>
</div>
<a class="anchor" id="a51280ed25278cee3f54f412a863158ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pvr::swap </td>
          <td>(</td>
          <td class="paramtype">RingBuffer&lt; Item &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RingBuffer&lt; Item &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A swap function for the <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a>. Efficiently exchanges the items between two ring buffers. No actual item copies happen.</p>
<p>Swap the items of two ringbuffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The first <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a> to swap</td></tr>
    <tr><td class="paramname">right</td><td>The second <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a> to swap</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Item</td><td>The type of the items stored in the <a class="el" href="classpvr_1_1_ring_buffer.html" title="A classic, templated, efficient RingBuffer implementation. Supports operations at both ends (front...">RingBuffer</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The first item to swap</td></tr>
    <tr><td class="paramname">left</td><td>The right item to swap</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1e94c2ba31753bbeee3f63aa9d68d97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 pvr::textureOffset2D </td>
          <td>(</td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the offset of a 2D texture</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Offset X</td></tr>
    <tr><td class="paramname">y</td><td>Offset Y</td></tr>
    <tr><td class="paramname">width</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> width</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the offset of a 2D texture</dd></dl>

</div>
</div>
<a class="anchor" id="a2e18a200f3f0d5c265df5a852f5ee801"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 pvr::textureOffset3D </td>
          <td>(</td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate the offset of 3D texture</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Offset X</td></tr>
    <tr><td class="paramname">y</td><td>Offset Y</td></tr>
    <tr><td class="paramname">z</td><td>Offset Z</td></tr>
    <tr><td class="paramname">width</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> Width</td></tr>
    <tr><td class="paramname">height</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> Height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the offset of a 3D texture</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a3c0ab02bcc448423ae5efc03f357d75c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">extern ::<a class="el" href="classpvr_1_1_logger.html">pvr::Logger</a> pvr::Log</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&mdash; GLOBAL OBJECT THAT IS NORMALLY THE DEFAULT LOG &mdash; Use to log your issues.</p>
<p>Normally used as a functor: Log(Log.Warning, "This is warning number %d", 42)</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
