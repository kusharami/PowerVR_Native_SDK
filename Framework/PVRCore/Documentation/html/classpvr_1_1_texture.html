<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRCore: pvr::Texture Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="classpvr_1_1_texture.html">Texture</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1_texture-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::Texture Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A 2D <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset, together with Information, Metadata and actual Pixel data. Only represents the actual data, not the API objects that may be created from it. 
 <a href="classpvr_1_1_texture.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::Texture:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1_texture__inherit__graph.png" border="0" usemap="#pvr_1_1_texture_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1_texture_inherit__map" id="pvr_1_1_texture_inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1_texture_header.html" title="A class mirroring the PVR Texture container format header, and which can in general represent any Tex..." alt="" coords="5,5,139,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1d4ae5b8b2c94ca4cc26d84350c0073d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a1d4ae5b8b2c94ca4cc26d84350c0073d">Texture</a> ()</td></tr>
<tr class="memdesc:a1d4ae5b8b2c94ca4cc26d84350c0073d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new empty texture. <a href="#a1d4ae5b8b2c94ca4cc26d84350c0073d">More...</a><br/></td></tr>
<tr class="separator:a1d4ae5b8b2c94ca4cc26d84350c0073d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a23d9e1954f652b74bccd57633ff94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a84a23d9e1954f652b74bccd57633ff94">Texture</a> (const <a class="el" href="classpvr_1_1_texture_header.html">TextureHeader</a> &amp;sHeader, const <a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a> *pData=NULL)</td></tr>
<tr class="memdesc:a84a23d9e1954f652b74bccd57633ff94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture using the information from a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> header and copy the actual data from a provided pointer. <a href="#a84a23d9e1954f652b74bccd57633ff94">More...</a><br/></td></tr>
<tr class="separator:a84a23d9e1954f652b74bccd57633ff94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728551fb0796372ed9d3171ae29a8d49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a728551fb0796372ed9d3171ae29a8d49">addPaddingMetaData</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> alignment)</td></tr>
<tr class="memdesc:a728551fb0796372ed9d3171ae29a8d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function pads to a boundary value equal to "uiPadding". For example, setting alignment=8 will align the start of the texture data to an 8 byte boundary. <a href="#a728551fb0796372ed9d3171ae29a8d49">More...</a><br/></td></tr>
<tr class="separator:a728551fb0796372ed9d3171ae29a8d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76961ba046070091ff295cc23aafded7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a76961ba046070091ff295cc23aafded7">getDataPointer</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> mipMapLevel=0, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> arrayMember=0, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> faceNumber=0) const </td></tr>
<tr class="memdesc:a76961ba046070091ff295cc23aafded7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (const) pointer into the raw texture's data. Can be offset to a specific array member, face and/or MIP Map levels. <a href="#a76961ba046070091ff295cc23aafded7">More...</a><br/></td></tr>
<tr class="separator:a76961ba046070091ff295cc23aafded7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb544d6976846a1237f5f55a5cd38a48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#aeb544d6976846a1237f5f55a5cd38a48">getDataPointer</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> mipMapLevel=0, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> arrayMember=0, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> faceNumber=0)</td></tr>
<tr class="memdesc:aeb544d6976846a1237f5f55a5cd38a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer into the raw texture's data. Can be offset to a specific array member, face and/or MIP Map levels. <a href="#aeb544d6976846a1237f5f55a5cd38a48">More...</a><br/></td></tr>
<tr class="separator:aeb544d6976846a1237f5f55a5cd38a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cef97d22e6cfac6d8c6ac6d60fbf503"><td class="memItemLeft" align="right" valign="top">types::ImageBaseType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a8cef97d22e6cfac6d8c6ac6d60fbf503">getDimension</a> () const </td></tr>
<tr class="memdesc:a8cef97d22e6cfac6d8c6ac6d60fbf503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base dimensioning type of the image (3D, 2D, 1D). <a href="#a8cef97d22e6cfac6d8c6ac6d60fbf503">More...</a><br/></td></tr>
<tr class="separator:a8cef97d22e6cfac6d8c6ac6d60fbf503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049bb43e31e75bfb38228bfbe29aa79a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1types_1_1_generic_extent3_d.html">types::Extent3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a049bb43e31e75bfb38228bfbe29aa79a">getDimensions</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> miplevel=0) const </td></tr>
<tr class="memdesc:a049bb43e31e75bfb38228bfbe29aa79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the texture's dimensions as a 3D extent (height, width, depth). <a href="#a049bb43e31e75bfb38228bfbe29aa79a">More...</a><br/></td></tr>
<tr class="separator:a049bb43e31e75bfb38228bfbe29aa79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6418204403dc94b6aca003d62bcfed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1types_1_1_image_layers_size.html">types::ImageLayersSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a5f6418204403dc94b6aca003d62bcfed">getLayersSize</a> () const </td></tr>
<tr class="memdesc:a5f6418204403dc94b6aca003d62bcfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the texture's layer layout (miplevels, arraylevels). Faces are considered array levels, so a cube array has array x face array levels. <a href="#a5f6418204403dc94b6aca003d62bcfed">More...</a><br/></td></tr>
<tr class="separator:a5f6418204403dc94b6aca003d62bcfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6093e2f3d6e0cbceb6d8e493cfdd3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a9a6093e2f3d6e0cbceb6d8e493cfdd3f">getPixelPointer</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> x, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> y, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> z=0, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> mipMapLevel=0, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> arrayMember=0, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> faceNumber=0)</td></tr>
<tr class="memdesc:a9a6093e2f3d6e0cbceb6d8e493cfdd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer into the raw texture's data, offset to a specific pixel. DOES NOT WORK FOR COMPRESSED TEXTURES. <a href="#a9a6093e2f3d6e0cbceb6d8e493cfdd3f">More...</a><br/></td></tr>
<tr class="separator:a9a6093e2f3d6e0cbceb6d8e493cfdd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cfd0852221a1853911c112655f551f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a693aadd10412283ed1afd703dc83560a">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a13cfd0852221a1853911c112655f551f">getPixelSize</a> () const </td></tr>
<tr class="memdesc:a13cfd0852221a1853911c112655f551f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bits size of each pixel in the texture. Not accurate for many compressed textures (e.g. ASTC) <a href="#a13cfd0852221a1853911c112655f551f">More...</a><br/></td></tr>
<tr class="separator:a13cfd0852221a1853911c112655f551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f67d1a139861e8f91f11d4fc913dfaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1types_1_1_image_area_size.html">types::ImageAreaSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a8f67d1a139861e8f91f11d4fc913dfaa">getTotalDimensions</a> () const </td></tr>
<tr class="memdesc:a8f67d1a139861e8f91f11d4fc913dfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entire size of the image as an ImageAreaSize (height, width, depth, miplevels, arraylayers)  <a href="#a8f67d1a139861e8f91f11d4fc913dfaa">More...</a><br/></td></tr>
<tr class="separator:a8f67d1a139861e8f91f11d4fc913dfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bda057c26fb767772415ed46c49998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#ac5bda057c26fb767772415ed46c49998">initializeWithHeader</a> (const <a class="el" href="classpvr_1_1_texture_header.html">TextureHeader</a> &amp;sHeader)</td></tr>
<tr class="memdesc:ac5bda057c26fb767772415ed46c49998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture using the information from a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> header and preallocate memory for its data.  <a href="#ac5bda057c26fb767772415ed46c49998">More...</a><br/></td></tr>
<tr class="separator:ac5bda057c26fb767772415ed46c49998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpvr_1_1_texture_header"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpvr_1_1_texture_header')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpvr_1_1_texture_header.html">pvr::TextureHeader</a></td></tr>
<tr class="memitem:aeb28e3c3a9f26529ff3fb001fe327f04 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#aeb28e3c3a9f26529ff3fb001fe327f04">TextureHeader</a> ()</td></tr>
<tr class="memdesc:aeb28e3c3a9f26529ff3fb001fe327f04 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for a <a class="el" href="classpvr_1_1_texture_header.html" title="A class mirroring the PVR Texture container format header, and which can in general represent any Tex...">TextureHeader</a>. Returns an empty header. <a href="#aeb28e3c3a9f26529ff3fb001fe327f04">More...</a><br/></td></tr>
<tr class="separator:aeb28e3c3a9f26529ff3fb001fe327f04 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5b259fd890f3d0a18182eef7ddda1e inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#aeb5b259fd890f3d0a18182eef7ddda1e">TextureHeader</a> (const <a class="el" href="classpvr_1_1_texture_header.html">TextureHeader</a> &amp;rhs)</td></tr>
<tr class="memdesc:aeb5b259fd890f3d0a18182eef7ddda1e inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor <a href="#aeb5b259fd890f3d0a18182eef7ddda1e">More...</a><br/></td></tr>
<tr class="separator:aeb5b259fd890f3d0a18182eef7ddda1e inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d65e5620541bbb903391acc7a1773f inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a24d65e5620541bbb903391acc7a1773f">TextureHeader</a> (<a class="el" href="structpvr_1_1_texture_header_1_1_header.html">Header</a> &amp;header)</td></tr>
<tr class="memdesc:a24d65e5620541bbb903391acc7a1773f inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this from the given file header <a href="#a24d65e5620541bbb903391acc7a1773f">More...</a><br/></td></tr>
<tr class="separator:a24d65e5620541bbb903391acc7a1773f inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f9274ed3b9762e92a1e0e20042d3e4 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a57f9274ed3b9762e92a1e0e20042d3e4">TextureHeader</a> (<a class="el" href="structpvr_1_1_texture_header_1_1_header.html">Header</a> fileHeader, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> metaDataCount, <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> *metaData)</td></tr>
<tr class="memdesc:a57f9274ed3b9762e92a1e0e20042d3e4 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this from file header and meta data <a href="#a57f9274ed3b9762e92a1e0e20042d3e4">More...</a><br/></td></tr>
<tr class="separator:a57f9274ed3b9762e92a1e0e20042d3e4 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d553f5a71774f12b508bf33a64442bd inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a4d553f5a71774f12b508bf33a64442bd">TextureHeader</a> (<a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> pixelFormat, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> width, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> height, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> depth=1, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> mipMapCount=1, types::ColorSpace colorSpace=types::ColorSpace::lRGB, <a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> channelType=VariableType::UnsignedByteNorm, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> numberOfSurfaces=1, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> numberOfFaces=1, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> flags=0, <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> *metaData=NULL, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> metaDataSize=0)</td></tr>
<tr class="memdesc:a4d553f5a71774f12b508bf33a64442bd inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <a href="#a4d553f5a71774f12b508bf33a64442bd">More...</a><br/></td></tr>
<tr class="separator:a4d553f5a71774f12b508bf33a64442bd inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c81430182569becd27c48dc12e9f36 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a15c81430182569becd27c48dc12e9f36">addMetaData</a> (const <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> &amp;metaData)</td></tr>
<tr class="memdesc:a15c81430182569becd27c48dc12e9f36 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an arbitrary piece of meta data. <a href="#a15c81430182569becd27c48dc12e9f36">More...</a><br/></td></tr>
<tr class="separator:a15c81430182569becd27c48dc12e9f36 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62b61c16df58374013f50807457e9e0 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#ad62b61c16df58374013f50807457e9e0">getBitsPerPixel</a> () const </td></tr>
<tr class="memdesc:ad62b61c16df58374013f50807457e9e0 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bits per pixel of the texture format. <a href="#ad62b61c16df58374013f50807457e9e0">More...</a><br/></td></tr>
<tr class="separator:ad62b61c16df58374013f50807457e9e0 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9915833ffc12d621f404db7f3adfcaa4 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a9915833ffc12d621f404db7f3adfcaa4">getChannelType</a> () const </td></tr>
<tr class="memdesc:a9915833ffc12d621f404db7f3adfcaa4 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the channel type that the texture's data is stored in. <a href="#a9915833ffc12d621f404db7f3adfcaa4">More...</a><br/></td></tr>
<tr class="separator:a9915833ffc12d621f404db7f3adfcaa4 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f18ed15f2a8180e2a66b98c7954f3e inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">types::ColorSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a13f18ed15f2a8180e2a66b98c7954f3e">getColorSpace</a> () const </td></tr>
<tr class="memdesc:a13f18ed15f2a8180e2a66b98c7954f3e inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the color space of the texture. <a href="#a13f18ed15f2a8180e2a66b98c7954f3e">More...</a><br/></td></tr>
<tr class="separator:a13f18ed15f2a8180e2a66b98c7954f3e inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f3a0e6a241a373e9a9c4cfed6c5346 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#ad7f3a0e6a241a373e9a9c4cfed6c5346">getCubeMapOrder</a> () const </td></tr>
<tr class="memdesc:ad7f3a0e6a241a373e9a9c4cfed6c5346 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cube map face order. <a href="#ad7f3a0e6a241a373e9a9c4cfed6c5346">More...</a><br/></td></tr>
<tr class="separator:ad7f3a0e6a241a373e9a9c4cfed6c5346 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc3792fd42b19c631bcb79f25f04097 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a9cc3792fd42b19c631bcb79f25f04097">getDataOffset</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> mipMapLevel=0, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> arrayMember=0, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> face=0) const </td></tr>
<tr class="memdesc:a9cc3792fd42b19c631bcb79f25f04097 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a offset in the data <a href="#a9cc3792fd42b19c631bcb79f25f04097">More...</a><br/></td></tr>
<tr class="separator:a9cc3792fd42b19c631bcb79f25f04097 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f3bfcd45947c46248048c32c627a13 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a85f3bfcd45947c46248048c32c627a13">getDataSize</a> (<a class="el" href="namespacepvr.html#a496cd696ccb8dfabf94599ba8b21f00a">int32</a> mipLevel=pvrTextureAllMIPMaps, bool allSurfaces=true, bool allFaces=true) const </td></tr>
<tr class="memdesc:a85f3bfcd45947c46248048c32c627a13 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in BYTES of the texture, given various input parameters. <a href="#a85f3bfcd45947c46248048c32c627a13">More...</a><br/></td></tr>
<tr class="separator:a85f3bfcd45947c46248048c32c627a13 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac188bf4a98cf109551bd1daa5be0f684 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#ac188bf4a98cf109551bd1daa5be0f684">getDepth</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> mipLevel=0) const </td></tr>
<tr class="memdesc:ac188bf4a98cf109551bd1daa5be0f684 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the depth of the user specified MIP-Map level for the texture. <a href="#ac188bf4a98cf109551bd1daa5be0f684">More...</a><br/></td></tr>
<tr class="separator:ac188bf4a98cf109551bd1daa5be0f684 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa184df21de25c40903d5be3079023e inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a4fa184df21de25c40903d5be3079023e">getDirect3DFormat</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> &amp;outD3dFormat) const </td></tr>
<tr class="memdesc:a4fa184df21de25c40903d5be3079023e inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Direct3D equivalent format enumeration for this texture. <a href="#a4fa184df21de25c40903d5be3079023e">More...</a><br/></td></tr>
<tr class="separator:a4fa184df21de25c40903d5be3079023e inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada881b4d0e9befbcb9936effc933902b inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#ada881b4d0e9befbcb9936effc933902b">getDirectXGIFormat</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> &amp;outDxgiFormat, bool &amp;notAlpha) const </td></tr>
<tr class="memdesc:ada881b4d0e9befbcb9936effc933902b inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the DirectXGI equivalent format enumeration for this texture. <a href="#ada881b4d0e9befbcb9936effc933902b">More...</a><br/></td></tr>
<tr class="separator:ada881b4d0e9befbcb9936effc933902b inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f36bb369bdd8dbe49725cbb33559c8 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpvr_1_1_texture_header_1_1_header.html">Header</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#aa3f36bb369bdd8dbe49725cbb33559c8">getHeader</a> () const </td></tr>
<tr class="memdesc:aa3f36bb369bdd8dbe49725cbb33559c8 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file header structure. <a href="#aa3f36bb369bdd8dbe49725cbb33559c8">More...</a><br/></td></tr>
<tr class="separator:aa3f36bb369bdd8dbe49725cbb33559c8 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae186c6406bdcfd645c598b5d5cf9aafb inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1_texture_header_1_1_header.html">Header</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#ae186c6406bdcfd645c598b5d5cf9aafb">getHeaderAccess</a> ()</td></tr>
<tr class="memdesc:ae186c6406bdcfd645c598b5d5cf9aafb inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file header access. <a href="#ae186c6406bdcfd645c598b5d5cf9aafb">More...</a><br/></td></tr>
<tr class="separator:ae186c6406bdcfd645c598b5d5cf9aafb inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3e965c2be719d990dd5945130d0f06 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a0f3e965c2be719d990dd5945130d0f06">getHeight</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> uiMipLevel=0) const </td></tr>
<tr class="memdesc:a0f3e965c2be719d990dd5945130d0f06 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the height of the user specified MIP-Map level for the texture. <a href="#a0f3e965c2be719d990dd5945130d0f06">More...</a><br/></td></tr>
<tr class="separator:a0f3e965c2be719d990dd5945130d0f06 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da245ac3eb5ed7c427a2e19aec5b392 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>, <br class="typebreak"/>
std::map&lt; <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>, <br class="typebreak"/>
<a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a4da245ac3eb5ed7c427a2e19aec5b392">getMetaDataMap</a> () const </td></tr>
<tr class="memdesc:a4da245ac3eb5ed7c427a2e19aec5b392 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer directly to the Meta Data Map, to allow users to read out data. <a href="#a4da245ac3eb5ed7c427a2e19aec5b392">More...</a><br/></td></tr>
<tr class="separator:a4da245ac3eb5ed7c427a2e19aec5b392 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe50bf63696e5e1fd261fd54f48ef11 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#aefe50bf63696e5e1fd261fd54f48ef11">getMetaDataSize</a> () const </td></tr>
<tr class="memdesc:aefe50bf63696e5e1fd261fd54f48ef11 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the meta data stored in the header. This includes the size of all information stored in all CPVRMetaDataBlocks. <a href="#aefe50bf63696e5e1fd261fd54f48ef11">More...</a><br/></td></tr>
<tr class="separator:aefe50bf63696e5e1fd261fd54f48ef11 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01657bae943993d3c4a04d8a5c4c803 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#ab01657bae943993d3c4a04d8a5c4c803">getMinDimensionsForFormat</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> &amp;minX, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> &amp;minY, <a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> &amp;minZ) const </td></tr>
<tr class="memdesc:ab01657bae943993d3c4a04d8a5c4c803 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum dimensions that the texture format of this header can be. <a href="#ab01657bae943993d3c4a04d8a5c4c803">More...</a><br/></td></tr>
<tr class="separator:ab01657bae943993d3c4a04d8a5c4c803 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82abdc5c650f46d828e241f608841250 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a82abdc5c650f46d828e241f608841250">getNumberOfArrayMembers</a> () const </td></tr>
<tr class="memdesc:a82abdc5c650f46d828e241f608841250 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of array members stored in this texture. <a href="#a82abdc5c650f46d828e241f608841250">More...</a><br/></td></tr>
<tr class="separator:a82abdc5c650f46d828e241f608841250 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef196e4cc0f8a150fade3012ce4d65a inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a0ef196e4cc0f8a150fade3012ce4d65a">getNumberOfFaces</a> () const </td></tr>
<tr class="memdesc:a0ef196e4cc0f8a150fade3012ce4d65a inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of faces stored in this texture. <a href="#a0ef196e4cc0f8a150fade3012ce4d65a">More...</a><br/></td></tr>
<tr class="separator:a0ef196e4cc0f8a150fade3012ce4d65a inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4042de983a1fdfec15c13fb71fd01d2b inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a4042de983a1fdfec15c13fb71fd01d2b">getNumberOfMIPLevels</a> () const </td></tr>
<tr class="memdesc:a4042de983a1fdfec15c13fb71fd01d2b inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of MIP-Map levels stored in this texture. <a href="#a4042de983a1fdfec15c13fb71fd01d2b">More...</a><br/></td></tr>
<tr class="separator:a4042de983a1fdfec15c13fb71fd01d2b inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa518e82662bf007fe17f690053f21c inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">TextureMetaData::AxisOrientation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a4aa518e82662bf007fe17f690053f21c">getOrientation</a> (TextureMetaData::Axis axis) const </td></tr>
<tr class="memdesc:a4aa518e82662bf007fe17f690053f21c inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the data orientation for this texture. <a href="#a4aa518e82662bf007fe17f690053f21c">More...</a><br/></td></tr>
<tr class="separator:a4aa518e82662bf007fe17f690053f21c inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc8abcb39a043540ee5806b89294e84 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a8cc8abcb39a043540ee5806b89294e84">getPixelFormat</a> () const </td></tr>
<tr class="memdesc:a8cc8abcb39a043540ee5806b89294e84 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pixel type ID of the texture. <a href="#a8cc8abcb39a043540ee5806b89294e84">More...</a><br/></td></tr>
<tr class="separator:a8cc8abcb39a043540ee5806b89294e84 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d65fc586b570ecde2a11e85fc3ee102 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a9d65fc586b570ecde2a11e85fc3ee102">getTextureSize</a> (<a class="el" href="namespacepvr.html#a496cd696ccb8dfabf94599ba8b21f00a">int32</a> mipMapLevel=pvrTextureAllMIPMaps, bool allSurfaces=true, bool allFaces=true) const </td></tr>
<tr class="memdesc:a9d65fc586b570ecde2a11e85fc3ee102 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in PIXELS of the texture, given various input parameters. <a href="#a9d65fc586b570ecde2a11e85fc3ee102">More...</a><br/></td></tr>
<tr class="separator:a9d65fc586b570ecde2a11e85fc3ee102 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65879da34f5bb2041d9abc93804313c1 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a65879da34f5bb2041d9abc93804313c1">getWidth</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> uiMipLevel=0) const </td></tr>
<tr class="memdesc:a65879da34f5bb2041d9abc93804313c1 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the width of the user specified MIP-Map level for the texture. <a href="#a65879da34f5bb2041d9abc93804313c1">More...</a><br/></td></tr>
<tr class="separator:a65879da34f5bb2041d9abc93804313c1 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e47c2529adeb18f7f6c78dc7133598 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a65e47c2529adeb18f7f6c78dc7133598">isBumpMap</a> () const </td></tr>
<tr class="memdesc:a65e47c2529adeb18f7f6c78dc7133598 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this texture is bumpmap <a href="#a65e47c2529adeb18f7f6c78dc7133598">More...</a><br/></td></tr>
<tr class="separator:a65e47c2529adeb18f7f6c78dc7133598 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cff2e66e9eb6b951ec397bded48228 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#af5cff2e66e9eb6b951ec397bded48228">isFileCompressed</a> () const </td></tr>
<tr class="memdesc:af5cff2e66e9eb6b951ec397bded48228 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. <a href="#af5cff2e66e9eb6b951ec397bded48228">More...</a><br/></td></tr>
<tr class="separator:af5cff2e66e9eb6b951ec397bded48228 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4b350aeddec1229aadbe6d4f62c3dc inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#add4b350aeddec1229aadbe6d4f62c3dc">isPreMultiplied</a> () const </td></tr>
<tr class="memdesc:add4b350aeddec1229aadbe6d4f62c3dc inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not the texture's color has been pre-multiplied by the alpha values. <a href="#add4b350aeddec1229aadbe6d4f62c3dc">More...</a><br/></td></tr>
<tr class="separator:add4b350aeddec1229aadbe6d4f62c3dc inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0112d526c9778ab5b27329a6a590fd18 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a0112d526c9778ab5b27329a6a590fd18">setBumpMap</a> (float bumpScale, <a class="el" href="namespacepvr.html#a1ed002df805fdbdb1a5840f9cca51b4d">string</a> bumpOrder)</td></tr>
<tr class="memdesc:a0112d526c9778ab5b27329a6a590fd18 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture's bump map data. <a href="#a0112d526c9778ab5b27329a6a590fd18">More...</a><br/></td></tr>
<tr class="separator:a0112d526c9778ab5b27329a6a590fd18 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b159d430023c0b9d1f3cf0b62164cfb inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a2b159d430023c0b9d1f3cf0b62164cfb">setChannelType</a> (<a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> channelType)</td></tr>
<tr class="memdesc:a2b159d430023c0b9d1f3cf0b62164cfb inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the channel type of this texture. <a href="#a2b159d430023c0b9d1f3cf0b62164cfb">More...</a><br/></td></tr>
<tr class="separator:a2b159d430023c0b9d1f3cf0b62164cfb inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6567cd6054474b49d8a729c0e1e224ad inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a6567cd6054474b49d8a729c0e1e224ad">setColorSpace</a> (types::ColorSpace colorSpace)</td></tr>
<tr class="memdesc:a6567cd6054474b49d8a729c0e1e224ad inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color space for this texture. Default is lRGB. <a href="#a6567cd6054474b49d8a729c0e1e224ad">More...</a><br/></td></tr>
<tr class="separator:a6567cd6054474b49d8a729c0e1e224ad inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae0add42744eb80a320819c7a30ceba inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a6ae0add42744eb80a320819c7a30ceba">setCubeMapOrder</a> (std::string cubeMapOrder)</td></tr>
<tr class="memdesc:a6ae0add42744eb80a320819c7a30ceba inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture's bump map data. <a href="#a6ae0add42744eb80a320819c7a30ceba">More...</a><br/></td></tr>
<tr class="separator:a6ae0add42744eb80a320819c7a30ceba inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55cdb75cb5ca2e7501dac0ccf7d36f8 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#aa55cdb75cb5ca2e7501dac0ccf7d36f8">setDepth</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> newDepth)</td></tr>
<tr class="memdesc:aa55cdb75cb5ca2e7501dac0ccf7d36f8 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture depth. <a href="#aa55cdb75cb5ca2e7501dac0ccf7d36f8">More...</a><br/></td></tr>
<tr class="separator:aa55cdb75cb5ca2e7501dac0ccf7d36f8 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7b8dac2d29c7964d253b62caf34dc2 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#adc7b8dac2d29c7964d253b62caf34dc2">setHeight</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> newHeight)</td></tr>
<tr class="memdesc:adc7b8dac2d29c7964d253b62caf34dc2 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture height. <a href="#adc7b8dac2d29c7964d253b62caf34dc2">More...</a><br/></td></tr>
<tr class="separator:adc7b8dac2d29c7964d253b62caf34dc2 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cee1199768def6a9748792eb5b0ccc3 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a2cee1199768def6a9748792eb5b0ccc3">setIsFileCompressed</a> (bool <a class="el" href="classpvr_1_1_texture_header.html#af5cff2e66e9eb6b951ec397bded48228">isFileCompressed</a>)</td></tr>
<tr class="memdesc:a2cee1199768def6a9748792eb5b0ccc3 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. Currently unsupported. <a href="#a2cee1199768def6a9748792eb5b0ccc3">More...</a><br/></td></tr>
<tr class="separator:a2cee1199768def6a9748792eb5b0ccc3 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edb013521dccb80f92759ab1c45f61b inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a3edb013521dccb80f92759ab1c45f61b">setIsPreMultiplied</a> (bool <a class="el" href="classpvr_1_1_texture_header.html#add4b350aeddec1229aadbe6d4f62c3dc">isPreMultiplied</a>)</td></tr>
<tr class="memdesc:a3edb013521dccb80f92759ab1c45f61b inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the texture's color has been pre-multiplied by the alpha values. <a href="#a3edb013521dccb80f92759ab1c45f61b">More...</a><br/></td></tr>
<tr class="separator:a3edb013521dccb80f92759ab1c45f61b inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1fee3b270f444e8a9237ddd6fe1f02 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a9f1fee3b270f444e8a9237ddd6fe1f02">setNumberOfArrayMembers</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> newNumMembers)</td></tr>
<tr class="memdesc:a9f1fee3b270f444e8a9237ddd6fe1f02 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of arrays in this texture <a href="#a9f1fee3b270f444e8a9237ddd6fe1f02">More...</a><br/></td></tr>
<tr class="separator:a9f1fee3b270f444e8a9237ddd6fe1f02 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125e7ad1706f36041d385d91f0332d89 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a125e7ad1706f36041d385d91f0332d89">setNumberOfFaces</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> newNumFaces)</td></tr>
<tr class="memdesc:a125e7ad1706f36041d385d91f0332d89 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of faces stored in this texture. <a href="#a125e7ad1706f36041d385d91f0332d89">More...</a><br/></td></tr>
<tr class="separator:a125e7ad1706f36041d385d91f0332d89 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c71b91b1b68218d92f7adf778274a0 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#ad5c71b91b1b68218d92f7adf778274a0">setNumberOfMIPLevels</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> newNumMIPLevels)</td></tr>
<tr class="memdesc:ad5c71b91b1b68218d92f7adf778274a0 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of MIP-Map levels in this texture. <a href="#ad5c71b91b1b68218d92f7adf778274a0">More...</a><br/></td></tr>
<tr class="separator:ad5c71b91b1b68218d92f7adf778274a0 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafee0c616f4217ebc193b0a4082a72f inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#aaafee0c616f4217ebc193b0a4082a72f">setOrientation</a> (TextureMetaData::AxisOrientation axisOrientation)</td></tr>
<tr class="memdesc:aaafee0c616f4217ebc193b0a4082a72f inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data orientation for a given axis in this texture. <a href="#aaafee0c616f4217ebc193b0a4082a72f">More...</a><br/></td></tr>
<tr class="separator:aaafee0c616f4217ebc193b0a4082a72f inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac843ef8bfde1ea52d0aad891807c4ea2 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#ac843ef8bfde1ea52d0aad891807c4ea2">setPixelFormat</a> (<a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> uPixelFormat)</td></tr>
<tr class="memdesc:ac843ef8bfde1ea52d0aad891807c4ea2 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pixel format for this texture. <a href="#ac843ef8bfde1ea52d0aad891807c4ea2">More...</a><br/></td></tr>
<tr class="separator:ac843ef8bfde1ea52d0aad891807c4ea2 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26164e0c3c65664a71bd88ec788e4329 inherit pub_methods_classpvr_1_1_texture_header"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture_header.html#a26164e0c3c65664a71bd88ec788e4329">setWidth</a> (<a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a> newWidth)</td></tr>
<tr class="memdesc:a26164e0c3c65664a71bd88ec788e4329 inherit pub_methods_classpvr_1_1_texture_header"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture width. <a href="#a26164e0c3c65664a71bd88ec788e4329">More...</a><br/></td></tr>
<tr class="separator:a26164e0c3c65664a71bd88ec788e4329 inherit pub_methods_classpvr_1_1_texture_header"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A 2D <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset, together with Information, Metadata and actual Pixel data. Only represents the actual data, not the API objects that may be created from it.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1d4ae5b8b2c94ca4cc26d84350c0073d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::Texture::Texture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new empty texture.</p>

</div>
</div>
<a class="anchor" id="a84a23d9e1954f652b74bccd57633ff94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::Texture::Texture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_texture_header.html">TextureHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>sHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a> *&#160;</td>
          <td class="paramname"><em>pData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a texture using the information from a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> header and copy the actual data from a provided pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sHeader</td><td>A texture header describing the texture</td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to memory containing the actual data.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a new texture based on a texture header, pre-allocating the correct amount of memory. If data is supplied, it will be copied into memory. If the pointer contains less data than is dictated by the texture header, the behaviour is undefined.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a728551fb0796372ed9d3171ae29a8d49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::Texture::addPaddingMetaData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function pads to a boundary value equal to "uiPadding". For example, setting alignment=8 will align the start of the texture data to an 8 byte boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alignment</td><td>The final alignment of the metadata</td></tr>
  </table>
  </dd>
</dl>
<p>When writing the texture out to a PVR file, it is often desirable to pad the meta data so that the start of the texture data aligns to a given boundary. Note - this should be called immediately before saving (in any case, before adding any metadata) as the value is worked out based on the current meta data size. </p>

</div>
</div>
<a class="anchor" id="a76961ba046070091ff295cc23aafded7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a>* pvr::Texture::getDataPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>faceNumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a (const) pointer into the raw texture's data. Can be offset to a specific array member, face and/or MIP Map levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level to get a pointer to (default 0)</td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array member to get a pointer to (default 0)</td></tr>
    <tr><td class="paramname">faceNumber</td><td>The cube face to get a pointer to (default 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const raw pointer to a location in the texture.</dd></dl>
<p>The data is contiguous so that the entire texture (all mips, array members and faces) can always be accessed from any pointer.</p>

</div>
</div>
<a class="anchor" id="aeb544d6976846a1237f5f55a5cd38a48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a>* pvr::Texture::getDataPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>faceNumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer into the raw texture's data. Can be offset to a specific array member, face and/or MIP Map levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array member for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">faceNumber</td><td>The face for which to get the data pointer (default 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to a location in the texture.</dd></dl>
<p>The data is contiguous so that the entire texture (all mips, array members and faces) can always be accessed from any pointer.</p>

</div>
</div>
<a class="anchor" id="a8cef97d22e6cfac6d8c6ac6d60fbf503"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">types::ImageBaseType pvr::Texture::getDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base dimensioning type of the image (3D, 2D, 1D).</p>
<dl class="section return"><dt>Returns</dt><dd>The base dimensioning type of the image (3D, 2D, 1D).</dd></dl>

</div>
</div>
<a class="anchor" id="a049bb43e31e75bfb38228bfbe29aa79a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1types_1_1_generic_extent3_d.html">types::Extent3D</a> pvr::Texture::getDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>miplevel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the texture's dimensions as a 3D extent (height, width, depth).</p>
<dl class="section return"><dt>Returns</dt><dd>Return the texture's dimensions as a 3D extent (height, width, depth)</dd></dl>

</div>
</div>
<a class="anchor" id="a5f6418204403dc94b6aca003d62bcfed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1types_1_1_image_layers_size.html">types::ImageLayersSize</a> pvr::Texture::getLayersSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the texture's layer layout (miplevels, arraylevels). Faces are considered array levels, so a cube array has array x face array levels.</p>
<dl class="section return"><dt>Returns</dt><dd>The texture's layer layout (miplevels, arraylevels)</dd></dl>

</div>
</div>
<a class="anchor" id="a9a6093e2f3d6e0cbceb6d8e493cfdd3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#aa90cd73f0aa3430b003b48d119e94f71">byte</a>* pvr::Texture::getPixelPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>z</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a02a97b530ff9cb298a9077ad7b4ee556">uint32</a>&#160;</td>
          <td class="paramname"><em>faceNumber</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer into the raw texture's data, offset to a specific pixel. DOES NOT WORK FOR COMPRESSED TEXTURES.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x position of the pointer</td></tr>
    <tr><td class="paramname">y</td><td>The y position of the pointer</td></tr>
    <tr><td class="paramname">z</td><td>The z position of the pointer (default 0)</td></tr>
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array member for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">faceNumber</td><td>The face for which to get the data pointer (default 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to a location in the texture.</dd></dl>
<p>The data is contiguous so that the entire texture (all mips, array members and faces) can always be accessed from any pointer. Equivalent to getDataPointer(mipMapLevel, arrayMember, faceNumber) + [byte offset of pixel (x,y,z)]</p>

</div>
</div>
<a class="anchor" id="a13cfd0852221a1853911c112655f551f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a693aadd10412283ed1afd703dc83560a">uint8</a> pvr::Texture::getPixelSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bits size of each pixel in the texture. Not accurate for many compressed textures (e.g. ASTC)</p>
<dl class="section return"><dt>Returns</dt><dd>he number of bits size of each pixel in the texture. May return zero for some compressed formats. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f67d1a139861e8f91f11d4fc913dfaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1types_1_1_image_area_size.html">types::ImageAreaSize</a> pvr::Texture::getTotalDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the entire size of the image as an ImageAreaSize (height, width, depth, miplevels, arraylayers) </p>
<dl class="section return"><dt>Returns</dt><dd>The entire size of the image as an ImageAreaSize (height, width, depth, miplevels, arraylayers) </dd></dl>

</div>
</div>
<a class="anchor" id="ac5bda057c26fb767772415ed46c49998"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::Texture::initializeWithHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_texture_header.html">TextureHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>sHeader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a texture using the information from a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> header and preallocate memory for its data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sHeader</td><td>A texture header describing the texture</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a new texture based on a texture header, pre-allocating the correct amount of memory.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRCore/<a class="el" href="_texture_8h_source.html">Texture.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
