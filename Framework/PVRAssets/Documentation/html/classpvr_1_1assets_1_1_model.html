<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRAssets: pvr::assets::Model Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1assets.html">assets</a></li><li class="navelem"><a class="el" href="classpvr_1_1assets_1_1_model.html">Model</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1assets_1_1_model-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::assets::Model Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a> class represents an entire Scene, or <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>. It is mainly a <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> can be a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> node (containing a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>), <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> node or <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through <a class="el" href="classpvr_1_1assets_1_1_animation.html" title="Represents an Animation that can be applied to different objects.">Animation</a> objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> nodes will be laid out, then <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> and <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> nodes. 
 <a href="classpvr_1_1assets_1_1_model.html#details">More...</a></p>

<p>Inherits Asset&lt; Model &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_model_1_1_internal_data.html">InternalData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the internal data of the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>. <a href="structpvr_1_1assets_1_1_model_1_1_internal_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which stores model material info. <a href="classpvr_1_1assets_1_1_model_1_1_material.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> represents a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>, <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> or <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a>. A <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through <a class="el" href="classpvr_1_1assets_1_1_animation.html" title="Represents an Animation that can be applied to different objects.">Animation</a> objects (a static transform is an animation with a single frame). Note: <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes.  <a href="classpvr_1_1assets_1_1_model_1_1_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html">Texture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class which stores <a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html" title="Internal class which stores Texture information of the model (name).">Texture</a> information of the model (name). <a href="classpvr_1_1assets_1_1_model_1_1_texture.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad4d1b6e161c5f0992818c8aeff35256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aad4d1b6e161c5f0992818c8aeff35256">allocCameras</a> (uint32 count)</td></tr>
<tr class="memdesc:aad4d1b6e161c5f0992818c8aeff35256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate an number of cameras. <a href="#aad4d1b6e161c5f0992818c8aeff35256">More...</a><br/></td></tr>
<tr class="separator:aad4d1b6e161c5f0992818c8aeff35256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82421f2bf54a313876a00bfb748937ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a82421f2bf54a313876a00bfb748937ab">allocLights</a> (uint32 count)</td></tr>
<tr class="memdesc:a82421f2bf54a313876a00bfb748937ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate a number of lights. <a href="#a82421f2bf54a313876a00bfb748937ab">More...</a><br/></td></tr>
<tr class="separator:a82421f2bf54a313876a00bfb748937ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1168828bad61d70d52b21a613a540fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a1168828bad61d70d52b21a613a540fbb">allocMeshes</a> (uint32 count)</td></tr>
<tr class="memdesc:a1168828bad61d70d52b21a613a540fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate a number of meshes. <a href="#a1168828bad61d70d52b21a613a540fbb">More...</a><br/></td></tr>
<tr class="separator:a1168828bad61d70d52b21a613a540fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b4034a7c6a8827d4b0a5b16c526cf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a05b4034a7c6a8827d4b0a5b16c526cf5">allocNodes</a> (uint32 count)</td></tr>
<tr class="memdesc:a05b4034a7c6a8827d4b0a5b16c526cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate a number of nodes. <a href="#a05b4034a7c6a8827d4b0a5b16c526cf5">More...</a><br/></td></tr>
<tr class="separator:a05b4034a7c6a8827d4b0a5b16c526cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0774f378974f948b9a54cba42f32c192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a0774f378974f948b9a54cba42f32c192">assignMaterialToMeshNodes</a> (uint32 materialIndex, uint32 beginMeshNodeId, uint32 endMeshNodeId)</td></tr>
<tr class="memdesc:a0774f378974f948b9a54cba42f32c192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign material id to number of mesh nodes <a href="#a0774f378974f948b9a54cba42f32c192">More...</a><br/></td></tr>
<tr class="separator:a0774f378974f948b9a54cba42f32c192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eff76a532c44f6dc1b9b0a5a1c38c4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a8eff76a532c44f6dc1b9b0a5a1c38c4a">beginMeshes</a> ()</td></tr>
<tr class="memdesc:a8eff76a532c44f6dc1b9b0a5a1c38c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning of the meshes. <a href="#a8eff76a532c44f6dc1b9b0a5a1c38c4a">More...</a><br/></td></tr>
<tr class="separator:a8eff76a532c44f6dc1b9b0a5a1c38c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0a2f65a40d2f9b9e3b84afd95f431d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#acb0a2f65a40d2f9b9e3b84afd95f431d">beginMeshes</a> () const </td></tr>
<tr class="memdesc:acb0a2f65a40d2f9b9e3b84afd95f431d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_iterator to the beginning of the meshes. <a href="#acb0a2f65a40d2f9b9e3b84afd95f431d">More...</a><br/></td></tr>
<tr class="separator:acb0a2f65a40d2f9b9e3b84afd95f431d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9c4a5eb52493f031919ff32ed2727e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a4f9c4a5eb52493f031919ff32ed2727e">connectMeshWithMeshNodes</a> (uint32 meshId, uint32 beginMeshNodeId, uint32 endMeshNodeId)</td></tr>
<tr class="memdesc:a4f9c4a5eb52493f031919ff32ed2727e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect mesh to number of mesh nodes <a href="#a4f9c4a5eb52493f031919ff32ed2727e">More...</a><br/></td></tr>
<tr class="separator:a4f9c4a5eb52493f031919ff32ed2727e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc81369c3ebc723a7ba82f122753f2c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#abc81369c3ebc723a7ba82f122753f2c4">destroy</a> ()</td></tr>
<tr class="memdesc:abc81369c3ebc723a7ba82f122753f2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the resources of this model. <a href="#abc81369c3ebc723a7ba82f122753f2c4">More...</a><br/></td></tr>
<tr class="separator:abc81369c3ebc723a7ba82f122753f2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3aafc1e3dac0fe88ab6615b94e80efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#af3aafc1e3dac0fe88ab6615b94e80efb">destroyCache</a> ()</td></tr>
<tr class="memdesc:af3aafc1e3dac0fe88ab6615b94e80efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the memory of the cache. <a href="#af3aafc1e3dac0fe88ab6615b94e80efb">More...</a><br/></td></tr>
<tr class="separator:af3aafc1e3dac0fe88ab6615b94e80efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dfb1ff94b791bd1b6372c69616468f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a60dfb1ff94b791bd1b6372c69616468f">endMeshes</a> ()</td></tr>
<tr class="memdesc:a60dfb1ff94b791bd1b6372c69616468f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the end of the meshes. <a href="#a60dfb1ff94b791bd1b6372c69616468f">More...</a><br/></td></tr>
<tr class="separator:a60dfb1ff94b791bd1b6372c69616468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b49a9866a99113358744701066a6821"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a7b49a9866a99113358744701066a6821">endMeshes</a> () const </td></tr>
<tr class="memdesc:a7b49a9866a99113358744701066a6821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_iterator past the end of the meshes. <a href="#a7b49a9866a99113358744701066a6821">More...</a><br/></td></tr>
<tr class="separator:a7b49a9866a99113358744701066a6821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6829a4d9579d6c9c27d07e6f6d58081a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a6829a4d9579d6c9c27d07e6f6d58081a">flushCache</a> ()</td></tr>
<tr class="memdesc:a6829a4d9579d6c9c27d07e6f6d58081a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a node's transformation then flush the cache. No effect if cache is uninitialized <a href="#a6829a4d9579d6c9c27d07e6f6d58081a">More...</a><br/></td></tr>
<tr class="separator:a6829a4d9579d6c9c27d07e6f6d58081a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f17fbeb770d413f1f3c03b04af1619a"><td class="memItemLeft" align="right" valign="top">const float32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a7f17fbeb770d413f1f3c03b04af1619a">getBackgroundColor</a> () const </td></tr>
<tr class="memdesc:a7f17fbeb770d413f1f3c03b04af1619a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clear color (background) (float array R,G,B,A). <a href="#a7f17fbeb770d413f1f3c03b04af1619a">More...</a><br/></td></tr>
<tr class="separator:a7f17fbeb770d413f1f3c03b04af1619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe6b208b0239c08c028790711b98198"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aebe6b208b0239c08c028790711b98198">getBoneWorldMatrix</a> (uint32 skinNodeID, uint32 boneId) const </td></tr>
<tr class="memdesc:aebe6b208b0239c08c028790711b98198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a specified bone. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will use caching. <a href="#aebe6b208b0239c08c028790711b98198">More...</a><br/></td></tr>
<tr class="separator:aebe6b208b0239c08c028790711b98198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d34080c6aadc24ef76560144d1def3c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a1d34080c6aadc24ef76560144d1def3c">getCamera</a> (uint32 cameraIndex) const </td></tr>
<tr class="memdesc:a1d34080c6aadc24ef76560144d1def3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> from this model <a href="#a1d34080c6aadc24ef76560144d1def3c">More...</a><br/></td></tr>
<tr class="separator:a1d34080c6aadc24ef76560144d1def3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443067ead98bc601041fbf6f17e61254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a443067ead98bc601041fbf6f17e61254">getCamera</a> (uint32 cameraIndex)</td></tr>
<tr class="memdesc:a443067ead98bc601041fbf6f17e61254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> from this model <a href="#a443067ead98bc601041fbf6f17e61254">More...</a><br/></td></tr>
<tr class="separator:a443067ead98bc601041fbf6f17e61254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513a7d311eb793c49166f2f53b7e2635"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a513a7d311eb793c49166f2f53b7e2635">getCameraNode</a> (uint32 cameraNodeIndex) const </td></tr>
<tr class="memdesc:a513a7d311eb793c49166f2f53b7e2635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific CameraNode. <a href="#a513a7d311eb793c49166f2f53b7e2635">More...</a><br/></td></tr>
<tr class="separator:a513a7d311eb793c49166f2f53b7e2635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332148a3b122e934a113ac0465b3343a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a332148a3b122e934a113ac0465b3343a">getCameraProperties</a> (int32 cameraIdx, float32 &amp;fov, glm::vec3 &amp;from, glm::vec3 &amp;to, glm::vec3 &amp;up) const </td></tr>
<tr class="memdesc:a332148a3b122e934a113ac0465b3343a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties of a camera. This is additional info on the class (remarks or documentation).  <a href="#a332148a3b122e934a113ac0465b3343a">More...</a><br/></td></tr>
<tr class="separator:a332148a3b122e934a113ac0465b3343a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2de5048718ec3a92df3f457be35d9ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ae2de5048718ec3a92df3f457be35d9ae">getCameraProperties</a> (int32 cameraIdx, float32 &amp;fov, glm::vec3 &amp;from, glm::vec3 &amp;to, glm::vec3 &amp;up, float &amp;nearClip, float &amp;farClip) const </td></tr>
<tr class="memdesc:ae2de5048718ec3a92df3f457be35d9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties of a camera. <a href="#ae2de5048718ec3a92df3f457be35d9ae">More...</a><br/></td></tr>
<tr class="separator:ae2de5048718ec3a92df3f457be35d9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe76347659b09a0e23e51f377407bd7"><td class="memItemLeft" align="right" valign="top">float32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#affe76347659b09a0e23e51f377407bd7">getCurrentFrame</a> ()</td></tr>
<tr class="memdesc:affe76347659b09a0e23e51f377407bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current frame of the scene. <a href="#affe76347659b09a0e23e51f377407bd7">More...</a><br/></td></tr>
<tr class="separator:affe76347659b09a0e23e51f377407bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34515ffb23fa46606ef5b91facc95a51"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a34515ffb23fa46606ef5b91facc95a51">getFPS</a> () const </td></tr>
<tr class="memdesc:a34515ffb23fa46606ef5b91facc95a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expected FPS of the animation. <a href="#a34515ffb23fa46606ef5b91facc95a51">More...</a><br/></td></tr>
<tr class="separator:a34515ffb23fa46606ef5b91facc95a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3f8d53b699918178ee6496e1a2e5c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1assets_1_1_model_1_1_internal_data.html">InternalData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a9a3f8d53b699918178ee6496e1a2e5c7">getInternalData</a> ()</td></tr>
<tr class="memdesc:a9a3f8d53b699918178ee6496e1a2e5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the internal data of this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>. Handle with care. <a href="#a9a3f8d53b699918178ee6496e1a2e5c7">More...</a><br/></td></tr>
<tr class="separator:a9a3f8d53b699918178ee6496e1a2e5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ba306a106882ba303a6bce48185341"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a55ba306a106882ba303a6bce48185341">getLight</a> (uint32 lightIndex) const </td></tr>
<tr class="memdesc:a55ba306a106882ba303a6bce48185341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Index. <a href="#a55ba306a106882ba303a6bce48185341">More...</a><br/></td></tr>
<tr class="separator:a55ba306a106882ba303a6bce48185341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ba89db38f7ad3edf8688670a7a5544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a83ba89db38f7ad3edf8688670a7a5544">getLight</a> (uint32 lightIndex)</td></tr>
<tr class="memdesc:a83ba89db38f7ad3edf8688670a7a5544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Index. <a href="#a83ba89db38f7ad3edf8688670a7a5544">More...</a><br/></td></tr>
<tr class="separator:a83ba89db38f7ad3edf8688670a7a5544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea7c901e4c45376136798071937ffe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#afea7c901e4c45376136798071937ffe6">getLightDirection</a> (int32 lightIdx, glm::vec3 &amp;direction) const </td></tr>
<tr class="memdesc:afea7c901e4c45376136798071937ffe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the direction of a spot or directional light. <a href="#afea7c901e4c45376136798071937ffe6">More...</a><br/></td></tr>
<tr class="separator:afea7c901e4c45376136798071937ffe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae894785004a1d03940b68be315d4d4da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ae894785004a1d03940b68be315d4d4da">getLightNode</a> (uint32 lightNodeIndex) const </td></tr>
<tr class="memdesc:ae894785004a1d03940b68be315d4d4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. <a href="#ae894785004a1d03940b68be315d4d4da">More...</a><br/></td></tr>
<tr class="separator:ae894785004a1d03940b68be315d4d4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae47083c876e9d4ab399b9b8b6a77b85"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aae47083c876e9d4ab399b9b8b6a77b85">getLightPosition</a> (uint32 lightId) const </td></tr>
<tr class="memdesc:aae47083c876e9d4ab399b9b8b6a77b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the world-space position of a light. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation.  <a href="#aae47083c876e9d4ab399b9b8b6a77b85">More...</a><br/></td></tr>
<tr class="separator:aae47083c876e9d4ab399b9b8b6a77b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282ab635a48828ed3200e171a8c5fea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a282ab635a48828ed3200e171a8c5fea5">getLightPosition</a> (int32 lightIdx, glm::vec3 &amp;position) const </td></tr>
<tr class="memdesc:a282ab635a48828ed3200e171a8c5fea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of a point or spot light. <a href="#a282ab635a48828ed3200e171a8c5fea5">More...</a><br/></td></tr>
<tr class="separator:a282ab635a48828ed3200e171a8c5fea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196cd01d1dfd4d9b5a37e4ed2f290ae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a196cd01d1dfd4d9b5a37e4ed2f290ae5">getLightPosition</a> (int32 lightIdx, glm::vec4 &amp;position) const </td></tr>
<tr class="memdesc:a196cd01d1dfd4d9b5a37e4ed2f290ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of a point or spot light. <a href="#a196cd01d1dfd4d9b5a37e4ed2f290ae5">More...</a><br/></td></tr>
<tr class="separator:a196cd01d1dfd4d9b5a37e4ed2f290ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fede8b68d50c5206a70ea59da64a8a"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a79fede8b68d50c5206a70ea59da64a8a">getLocalMatrix</a> (uint32 nodeId) const </td></tr>
<tr class="memdesc:a79fede8b68d50c5206a70ea59da64a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a node, <b>relative to its parent node</b>. In order to get the actual model-to-world matrix of the node, call getWorldMatrix (which will multiply the local matrix by the parent't matrix). <a href="#a79fede8b68d50c5206a70ea59da64a8a">More...</a><br/></td></tr>
<tr class="separator:a79fede8b68d50c5206a70ea59da64a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98e72bd829c789b6bb4bd5c7b7b256c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab98e72bd829c789b6bb4bd5c7b7b256c">getMaterial</a> (uint32 index) const </td></tr>
<tr class="memdesc:ab98e72bd829c789b6bb4bd5c7b7b256c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the material with the specified index. <a href="#ab98e72bd829c789b6bb4bd5c7b7b256c">More...</a><br/></td></tr>
<tr class="separator:ab98e72bd829c789b6bb4bd5c7b7b256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa663d8c57d9af1597515b1036987f3a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aa663d8c57d9af1597515b1036987f3a0">getMaterial</a> (uint32 index)</td></tr>
<tr class="memdesc:aa663d8c57d9af1597515b1036987f3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the material with the specified index. <a href="#aa663d8c57d9af1597515b1036987f3a0">More...</a><br/></td></tr>
<tr class="separator:aa663d8c57d9af1597515b1036987f3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8471884a70857b491fb30a8a8895cad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ac8471884a70857b491fb30a8a8895cad">getMesh</a> (uint32 meshIndex) const </td></tr>
<tr class="memdesc:ac8471884a70857b491fb30a8a8895cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> Index. Constant overload. <a href="#ac8471884a70857b491fb30a8a8895cad">More...</a><br/></td></tr>
<tr class="separator:ac8471884a70857b491fb30a8a8895cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc3d7fe991a4416e41d6e92cd5b770c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a6bc3d7fe991a4416e41d6e92cd5b770c">getMesh</a> (uint32 index)</td></tr>
<tr class="memdesc:a6bc3d7fe991a4416e41d6e92cd5b770c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> Index. <a href="#a6bc3d7fe991a4416e41d6e92cd5b770c">More...</a><br/></td></tr>
<tr class="separator:a6bc3d7fe991a4416e41d6e92cd5b770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba8b1d130b2d3e9c1769975796c0b3b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a3ba8b1d130b2d3e9c1769975796c0b3b">getMeshNode</a> (uint32 meshIndex) const </td></tr>
<tr class="memdesc:a3ba8b1d130b2d3e9c1769975796c0b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. <a href="#a3ba8b1d130b2d3e9c1769975796c0b3b">More...</a><br/></td></tr>
<tr class="separator:a3ba8b1d130b2d3e9c1769975796c0b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3861c022d1169735d3eae4b94482a1b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad3861c022d1169735d3eae4b94482a1b">getNode</a> (uint32 index) const </td></tr>
<tr class="memdesc:ad3861c022d1169735d3eae4b94482a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node with the specified index. <a href="#ad3861c022d1169735d3eae4b94482a1b">More...</a><br/></td></tr>
<tr class="separator:ad3861c022d1169735d3eae4b94482a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba9b2139e2fd4511d0f836e3e798a7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a0ba9b2139e2fd4511d0f836e3e798a7a">getNode</a> (uint32 index)</td></tr>
<tr class="memdesc:a0ba9b2139e2fd4511d0f836e3e798a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node with the specified index. <a href="#a0ba9b2139e2fd4511d0f836e3e798a7a">More...</a><br/></td></tr>
<tr class="separator:a0ba9b2139e2fd4511d0f836e3e798a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6573a674fe1b8437465b505541cebdad"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a6573a674fe1b8437465b505541cebdad">getNodeIdForMeshNodeId</a> (uint32 meshNodeIndex) const </td></tr>
<tr class="memdesc:a6573a674fe1b8437465b505541cebdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific MeshNode. This function is provided for completion, as NodeID == MeshNodeID <a href="#a6573a674fe1b8437465b505541cebdad">More...</a><br/></td></tr>
<tr class="separator:a6573a674fe1b8437465b505541cebdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102d1bfd1a7a3010ceef58366aab2c91"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a102d1bfd1a7a3010ceef58366aab2c91">getNodeIdFromCameraId</a> (uint32 cameraNodeIndex) const </td></tr>
<tr class="memdesc:a102d1bfd1a7a3010ceef58366aab2c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific CameraNode. <a href="#a102d1bfd1a7a3010ceef58366aab2c91">More...</a><br/></td></tr>
<tr class="separator:a102d1bfd1a7a3010ceef58366aab2c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7ceeb09ea19701306d6896c01a6773"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a1e7ceeb09ea19701306d6896c01a6773">getNodeIdFromLightNodeId</a> (uint32 lightNodeIndex) const </td></tr>
<tr class="memdesc:a1e7ceeb09ea19701306d6896c01a6773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GLOBAL index of a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. <a href="#a1e7ceeb09ea19701306d6896c01a6773">More...</a><br/></td></tr>
<tr class="separator:a1e7ceeb09ea19701306d6896c01a6773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fc8bd4319414e87c68f592785e95f3"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#af8fc8bd4319414e87c68f592785e95f3">getNumCameraNodes</a> () const </td></tr>
<tr class="memdesc:af8fc8bd4319414e87c68f592785e95f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> nodes in this model <a href="#af8fc8bd4319414e87c68f592785e95f3">More...</a><br/></td></tr>
<tr class="separator:af8fc8bd4319414e87c68f592785e95f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c57b2961fd9b09a2b545a5517badc85"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a8c57b2961fd9b09a2b545a5517badc85">getNumCameras</a> () const </td></tr>
<tr class="memdesc:a8c57b2961fd9b09a2b545a5517badc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct camera objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> Instances (Nodes). <a href="#a8c57b2961fd9b09a2b545a5517badc85">More...</a><br/></td></tr>
<tr class="separator:a8c57b2961fd9b09a2b545a5517badc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5ecf05c4a2056b8f0a2fc602c47c89"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aeb5ecf05c4a2056b8f0a2fc602c47c89">getNumFrames</a> () const </td></tr>
<tr class="memdesc:aeb5ecf05c4a2056b8f0a2fc602c47c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of frames in the scene. The total number of usable animated frames is limited to exclude (numFrames - 1) but include any partial number up to (numFrames - 1). Example: If there are 100 frames of animation, the highest frame number allowed is 98, since that will blend between frames 98 and 99. (99 being of course the 100th frame.) <a href="#aeb5ecf05c4a2056b8f0a2fc602c47c89">More...</a><br/></td></tr>
<tr class="separator:aeb5ecf05c4a2056b8f0a2fc602c47c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1fa99092486c46ab5ae93700f24d32"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a8c1fa99092486c46ab5ae93700f24d32">getNumLightNodes</a> () const </td></tr>
<tr class="memdesc:a8c1fa99092486c46ab5ae93700f24d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> nodes. <a href="#a8c1fa99092486c46ab5ae93700f24d32">More...</a><br/></td></tr>
<tr class="separator:a8c1fa99092486c46ab5ae93700f24d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca9f5e292c557593869a19b34dfa8f1"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#abca9f5e292c557593869a19b34dfa8f1">getNumLights</a> () const </td></tr>
<tr class="memdesc:abca9f5e292c557593869a19b34dfa8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Instances (Nodes). <a href="#abca9f5e292c557593869a19b34dfa8f1">More...</a><br/></td></tr>
<tr class="separator:abca9f5e292c557593869a19b34dfa8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdfc2581e90fc95fa9c80361d1054fa"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#adcdfc2581e90fc95fa9c80361d1054fa">getNumMaterials</a> () const </td></tr>
<tr class="memdesc:adcdfc2581e90fc95fa9c80361d1054fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct Materials in the scene. <a href="#adcdfc2581e90fc95fa9c80361d1054fa">More...</a><br/></td></tr>
<tr class="separator:adcdfc2581e90fc95fa9c80361d1054fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0265d41fa06b5a1a6f7ed767536c67"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aee0265d41fa06b5a1a6f7ed767536c67">getNumMeshes</a> () const </td></tr>
<tr class="memdesc:aee0265d41fa06b5a1a6f7ed767536c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> objects. Unless each <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> appears at exactly one <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>, may be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> instances. <a href="#aee0265d41fa06b5a1a6f7ed767536c67">More...</a><br/></td></tr>
<tr class="separator:aee0265d41fa06b5a1a6f7ed767536c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d54d1be8870914b0b832bea3c970ce"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ac8d54d1be8870914b0b832bea3c970ce">getNumMeshNodes</a> () const </td></tr>
<tr class="memdesc:ac8d54d1be8870914b0b832bea3c970ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> nodes. <a href="#ac8d54d1be8870914b0b832bea3c970ce">More...</a><br/></td></tr>
<tr class="separator:ac8d54d1be8870914b0b832bea3c970ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af716e167c0a1a792ec1183c1c027aebe"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#af716e167c0a1a792ec1183c1c027aebe">getNumNodes</a> () const </td></tr>
<tr class="memdesc:af716e167c0a1a792ec1183c1c027aebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of nodes (Meshes, Cameras, Lights, others (helpers etc)). <a href="#af716e167c0a1a792ec1183c1c027aebe">More...</a><br/></td></tr>
<tr class="separator:af716e167c0a1a792ec1183c1c027aebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0bc08904b1d06b6715f76fcbfec437"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a5b0bc08904b1d06b6715f76fcbfec437">getNumTextures</a> () const </td></tr>
<tr class="memdesc:a5b0bc08904b1d06b6715f76fcbfec437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct Textures in the scene. <a href="#a5b0bc08904b1d06b6715f76fcbfec437">More...</a><br/></td></tr>
<tr class="separator:a5b0bc08904b1d06b6715f76fcbfec437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56ccd607bc189d8ccb6e3eb8541ec37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html">Texture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad56ccd607bc189d8ccb6e3eb8541ec37">getTexture</a> (uint32 index) const </td></tr>
<tr class="memdesc:ad56ccd607bc189d8ccb6e3eb8541ec37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the texture with the specified index. <a href="#ad56ccd607bc189d8ccb6e3eb8541ec37">More...</a><br/></td></tr>
<tr class="separator:ad56ccd607bc189d8ccb6e3eb8541ec37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d60bce3fce1c4a613d181f1cb56a5f"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad9d60bce3fce1c4a613d181f1cb56a5f">getWorldMatrix</a> (uint32 nodeId) const </td></tr>
<tr class="memdesc:ad9d60bce3fce1c4a613d181f1cb56a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will store a copy of the matrix in an internal cache so that repeated calls for it will use the cached copy of it. Will also store the cached versions of all parents of this node, or use cached versions of them if they exist. Use this if you have long hierarchies and/or repeated calls per frame. <a href="#ad9d60bce3fce1c4a613d181f1cb56a5f">More...</a><br/></td></tr>
<tr class="separator:ad9d60bce3fce1c4a613d181f1cb56a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83240720d4a46efd7b4e47844fdf535e"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a83240720d4a46efd7b4e47844fdf535e">getWorldMatrixNoCache</a> (uint32 nodeId) const </td></tr>
<tr class="memdesc:a83240720d4a46efd7b4e47844fdf535e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will not use caching and will recalculate the matrix. Faster if the matrix is only used a few times.  <a href="#a83240720d4a46efd7b4e47844fdf535e">More...</a><br/></td></tr>
<tr class="separator:a83240720d4a46efd7b4e47844fdf535e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78c62c58d34db54afab9b9349bb29b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab78c62c58d34db54afab9b9349bb29b7">initCache</a> ()</td></tr>
<tr class="memdesc:ab78c62c58d34db54afab9b9349bb29b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the cache. Call this after changing the model data. It is automatically called by <a class="el" href="classpvr_1_1assets_1_1_p_o_d_reader.html" title="This class creates pvr::assets::Model object from Streams of POD Model data. Use the readAsset method...">PODReader</a> when reading a POD file. <a href="#ab78c62c58d34db54afab9b9349bb29b7">More...</a><br/></td></tr>
<tr class="separator:ab78c62c58d34db54afab9b9349bb29b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a62ffa50fdac571582f6ae9cef4ce67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a4a62ffa50fdac571582f6ae9cef4ce67">setCurrentFrame</a> (float32 frame)</td></tr>
<tr class="memdesc:a4a62ffa50fdac571582f6ae9cef4ce67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current frame. Affects future animation calls (getWorldMatrix etc.). <a href="#a4a62ffa50fdac571582f6ae9cef4ce67">More...</a><br/></td></tr>
<tr class="separator:a4a62ffa50fdac571582f6ae9cef4ce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41781d67f47ca6c63299d570c96a717d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a41781d67f47ca6c63299d570c96a717d">setFPS</a> (uint32 fps)</td></tr>
<tr class="memdesc:a41781d67f47ca6c63299d570c96a717d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the expected FPS of the animation. <a href="#a41781d67f47ca6c63299d570c96a717d">More...</a><br/></td></tr>
<tr class="separator:a41781d67f47ca6c63299d570c96a717d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d2206341aff4dc3bcd281ab6ef3c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a56d2206341aff4dc3bcd281ab6ef3c51">setUserData</a> (uint32 size, const byte *data)</td></tr>
<tr class="memdesc:a56d2206341aff4dc3bcd281ab6ef3c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set custom user data. <a href="#a56d2206341aff4dc3bcd281ab6ef3c51">More...</a><br/></td></tr>
<tr class="separator:a56d2206341aff4dc3bcd281ab6ef3c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4f26cbd59a02e09724292826732215"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ade4f26cbd59a02e09724292826732215">toWorldMatrix</a> (uint32 nodeId, const glm::mat4 &amp;localMatrix) const </td></tr>
<tr class="memdesc:ade4f26cbd59a02e09724292826732215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a custom matrix with a node's parent's transformation. Allows a custom matrix to be applied to a node, while honoring the hierarchical transformations applied by its parent hierarchy. <a href="#ade4f26cbd59a02e09724292826732215">More...</a><br/></td></tr>
<tr class="separator:ade4f26cbd59a02e09724292826732215"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a> class represents an entire Scene, or <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>. It is mainly a <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> can be a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> node (containing a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>), <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> node or <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through <a class="el" href="classpvr_1_1assets_1_1_animation.html" title="Represents an Animation that can be applied to different objects.">Animation</a> objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> nodes will be laid out, then <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> and <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> nodes.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aad4d1b6e161c5f0992818c8aeff35256"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocCameras </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate an number of cameras.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of camera to allocate in this scene</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82421f2bf54a313876a00bfb748937ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocLights </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate a number of lights.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of lights to allocate in this scene</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1168828bad61d70d52b21a613a540fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocMeshes </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate a number of meshes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of meshes to allocate in this scene</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05b4034a7c6a8827d4b0a5b16c526cf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocNodes </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate a number of nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of nodes to allocate in this scene</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0774f378974f948b9a54cba42f32c192"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::assignMaterialToMeshNodes </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>materialIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>beginMeshNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>endMeshNodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign material id to number of mesh nodes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">materialIndex</td><td><a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html" title="Class which stores model material info.">Material</a> id</td></tr>
    <tr><td class="paramname">beginMeshNodeId</td><td>Begin mesh node id (inclusive)</td></tr>
    <tr><td class="paramname">endMeshNodeId</td><td>end mesh node id (inclusive)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8eff76a532c44f6dc1b9b0a5a1c38c4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a>&gt;::iterator pvr::assets::Model::beginMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the beginning of the meshes.</p>
<dl class="section return"><dt>Returns</dt><dd>Return an iterator</dd></dl>

</div>
</div>
<a class="anchor" id="acb0a2f65a40d2f9b9e3b84afd95f431d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a>&gt;::const_iterator pvr::assets::Model::beginMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_iterator to the beginning of the meshes.</p>

</div>
</div>
<a class="anchor" id="a4f9c4a5eb52493f031919ff32ed2727e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::connectMeshWithMeshNodes </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>meshId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>beginMeshNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>endMeshNodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect mesh to number of mesh nodes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshId</td><td>The mesh id</td></tr>
    <tr><td class="paramname">beginMeshNodeId</td><td>Begin mesh node id (inclusive)</td></tr>
    <tr><td class="paramname">endMeshNodeId</td><td>End mesh node id (inclusive)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc81369c3ebc723a7ba82f122753f2c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the resources of this model.</p>

</div>
</div>
<a class="anchor" id="af3aafc1e3dac0fe88ab6615b94e80efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::destroyCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the memory of the cache.</p>

</div>
</div>
<a class="anchor" id="a60dfb1ff94b791bd1b6372c69616468f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a>&gt;::iterator pvr::assets::Model::endMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the end of the meshes.</p>
<dl class="section return"><dt>Returns</dt><dd>Return an iterator</dd></dl>

</div>
</div>
<a class="anchor" id="a7b49a9866a99113358744701066a6821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a>&gt;::const_iterator pvr::assets::Model::endMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_iterator past the end of the meshes.</p>

</div>
</div>
<a class="anchor" id="a6829a4d9579d6c9c27d07e6f6d58081a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::flushCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a node's transformation then flush the cache. No effect if cache is uninitialized</p>

</div>
</div>
<a class="anchor" id="a7f17fbeb770d413f1f3c03b04af1619a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float32* pvr::assets::Model::getBackgroundColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the clear color (background) (float array R,G,B,A).</p>

</div>
</div>
<a class="anchor" id="aebe6b208b0239c08c028790711b98198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getBoneWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>skinNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>boneId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a specified bone. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will use caching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skinNodeID</td><td>The node for which to return the world matrix</td></tr>
    <tr><td class="paramname">boneId</td><td>The bone for which to return the world matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The world matrix of (nodeId, boneID)</dd></dl>

</div>
</div>
<a class="anchor" id="a1d34080c6aadc24ef76560144d1def3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a>&amp; pvr::assets::Model::getCamera </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>cameraIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> from this model</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraIndex</td><td>The index of the camera. Valid values (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a8c57b2961fd9b09a2b545a5517badc85" title="Get the number of distinct camera objects. May be different than the actual number of Camera Instance...">getNumCameras()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the camera</dd></dl>

</div>
</div>
<a class="anchor" id="a443067ead98bc601041fbf6f17e61254"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a>&amp; pvr::assets::Model::getCamera </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>cameraIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> from this model</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraIndex</td><td>The index of the camera. Valid values (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a8c57b2961fd9b09a2b545a5517badc85" title="Get the number of distinct camera objects. May be different than the actual number of Camera Instance...">getNumCameras()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the camera</dd></dl>

</div>
</div>
<a class="anchor" id="a513a7d311eb793c49166f2f53b7e2635"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getCameraNode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>cameraNodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific CameraNode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraNodeIndex</td><td>The Index of a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. It is not the same as the NodeID. Valid values: (0 .. <a class="el" href="classpvr_1_1assets_1_1_model.html#af8fc8bd4319414e87c68f592785e95f3" title="Get the number of Camera nodes in this model">getNumCameraNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a></dd></dl>

</div>
</div>
<a class="anchor" id="a332148a3b122e934a113ac0465b3343a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getCameraProperties </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>cameraIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32 &amp;&#160;</td>
          <td class="paramname"><em>fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the properties of a camera. This is additional info on the class (remarks or documentation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraIdx</td><td>The index of the camera.</td></tr>
    <tr><td class="paramname">fov</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> field of view.</td></tr>
    <tr><td class="paramname">from</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> position in world.</td></tr>
    <tr><td class="paramname">to</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> target point in world.</td></tr>
    <tr><td class="paramname">up</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> tilt up (roll) vector in world.</td></tr>
  </table>
  </dd>
</dl>
<p>If cameraIdx &gt;= number of cameras, an error will be logged and this function will have no effect. </p>

</div>
</div>
<a class="anchor" id="ae2de5048718ec3a92df3f457be35d9ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getCameraProperties </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>cameraIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32 &amp;&#160;</td>
          <td class="paramname"><em>fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>nearClip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>farClip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the properties of a camera.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraIdx</td><td>The index of the camera.</td></tr>
    <tr><td class="paramname">fov</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> field of view in world.</td></tr>
    <tr><td class="paramname">from</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> position in world.</td></tr>
    <tr><td class="paramname">to</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> target point in world.</td></tr>
    <tr><td class="paramname">up</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> tilt up (roll) vector in world.</td></tr>
    <tr><td class="paramname">nearClip</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> near clipping plane distance</td></tr>
    <tr><td class="paramname">farClip</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> far clipping plane distance</td></tr>
  </table>
  </dd>
</dl>
<p>If cameraIdx &gt;= number of cameras, an error will be logged and this function will have no effect. </p>

</div>
</div>
<a class="anchor" id="affe76347659b09a0e23e51f377407bd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float32 pvr::assets::Model::getCurrentFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current frame of the scene.</p>
<dl class="section return"><dt>Returns</dt><dd>Return the current frame</dd></dl>

</div>
</div>
<a class="anchor" id="a34515ffb23fa46606ef5b91facc95a51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getFPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the expected FPS of the animation.</p>

</div>
</div>
<a class="anchor" id="a9a3f8d53b699918178ee6496e1a2e5c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1assets_1_1_model_1_1_internal_data.html">InternalData</a>&amp; pvr::assets::Model::getInternalData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the internal data of this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>. Handle with care.</p>
<dl class="section return"><dt>Returns</dt><dd>Return internal data</dd></dl>

</div>
</div>
<a class="anchor" id="a55ba306a106882ba303a6bce48185341"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a>&amp; pvr::assets::Model::getLight </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>lightIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>The index of the light. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#abca9f5e292c557593869a19b34dfa8f1" title="Get the number of distinct Light objects. May be different than the actual number of Light Instances ...">getNumLights()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the light</dd></dl>

</div>
</div>
<a class="anchor" id="a83ba89db38f7ad3edf8688670a7a5544"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a>&amp; pvr::assets::Model::getLight </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>lightIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>The index of the light. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#abca9f5e292c557593869a19b34dfa8f1" title="Get the number of distinct Light objects. May be different than the actual number of Light Instances ...">getNumLights()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the light</dd></dl>

</div>
</div>
<a class="anchor" id="afea7c901e4c45376136798071937ffe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getLightDirection </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>lightIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the direction of a spot or directional light.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIdx</td><td>index of the light.</td></tr>
    <tr><td class="paramname">direction</td><td>The direction of the light.</td></tr>
  </table>
  </dd>
</dl>
<p>If lightIdx &gt;= number of lights, an error will be logged and this function will have no effect. </p>

</div>
</div>
<a class="anchor" id="ae894785004a1d03940b68be315d4d4da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getLightNode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>lightNodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightNodeIndex</td><td>The Index of the <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. It is not the same as the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a8c1fa99092486c46ab5ae93700f24d32" title="Get the number of Light nodes.">getNumLightNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the light node</dd></dl>

</div>
</div>
<a class="anchor" id="aae47083c876e9d4ab399b9b8b6a77b85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 pvr::assets::Model::getLightPosition </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>lightId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the world-space position of a light. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightId</td><td>The node for which to return the world matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The world matrix of (nodeId).</dd></dl>

</div>
</div>
<a class="anchor" id="a282ab635a48828ed3200e171a8c5fea5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getLightPosition </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>lightIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the position of a point or spot light.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIdx</td><td>light index.</td></tr>
    <tr><td class="paramname">position</td><td>The position of the light.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <em>lightIdx</em> does not exist</dd></dl>
<p>If lightIdx &gt;= number of lights, an error will be logged and this function will have no effect. </p>

</div>
</div>
<a class="anchor" id="a196cd01d1dfd4d9b5a37e4ed2f290ae5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getLightPosition </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>lightIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the position of a point or spot light.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIdx</td><td>light index.</td></tr>
    <tr><td class="paramname">position</td><td>The position of the light.</td></tr>
  </table>
  </dd>
</dl>
<p>If lightIdx &gt;= number of lights, an error will be logged and this function will have no effect. </p>

</div>
</div>
<a class="anchor" id="a79fede8b68d50c5206a70ea59da64a8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getLocalMatrix </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>nodeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a node, <b>relative to its parent node</b>. In order to get the actual model-to-world matrix of the node, call getWorldMatrix (which will multiply the local matrix by the parent't matrix).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node for which to return the local matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The locatmatrix of (nodeId).</dd></dl>
<p>You can use this to get the transformation of a node relative to its parent hierarchies. May be useful for implementing custom (e.g. procedural) animation/kinematics.</p>

</div>
</div>
<a class="anchor" id="ab98e72bd829c789b6bb4bd5c7b7b256c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a>&amp; pvr::assets::Model::getMaterial </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the material with the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of material to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a material from this scene</dd></dl>

</div>
</div>
<a class="anchor" id="aa663d8c57d9af1597515b1036987f3a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a>&amp; pvr::assets::Model::getMaterial </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the material with the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of material to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a material from this scene</dd></dl>

</div>
</div>
<a class="anchor" id="ac8471884a70857b491fb30a8a8895cad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a>&amp; pvr::assets::Model::getMesh </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> Index. Constant overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshIndex</td><td>The index of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#aee0265d41fa06b5a1a6f7ed767536c67" title="Get the number of distinct Mesh objects. Unless each Mesh appears at exactly one Node, may be different than the actual number of Mesh instances.">getNumMeshes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mesh with id <em>meshIndex.</em> Const ref.</dd></dl>

</div>
</div>
<a class="anchor" id="a6bc3d7fe991a4416e41d6e92cd5b770c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a>&amp; pvr::assets::Model::getMesh </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> Index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a>. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#aee0265d41fa06b5a1a6f7ed767536c67" title="Get the number of distinct Mesh objects. Unless each Mesh appears at exactly one Node, may be different than the actual number of Mesh instances.">getNumMeshes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the mesh from this model</dd></dl>

</div>
</div>
<a class="anchor" id="a3ba8b1d130b2d3e9c1769975796c0b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getMeshNode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>meshIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshIndex</td><td>The Index of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. For meshes, it is the same as the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#ac8d54d1be8870914b0b832bea3c970ce" title="Get the number of Mesh nodes.">getNumMeshNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return he <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> from this model</dd></dl>

</div>
</div>
<a class="anchor" id="ad3861c022d1169735d3eae4b94482a1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getNode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the node with the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the node to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> from this scene</dd></dl>

</div>
</div>
<a class="anchor" id="a0ba9b2139e2fd4511d0f836e3e798a7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getNode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the node with the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the node to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> from this scene</dd></dl>

</div>
</div>
<a class="anchor" id="a6573a674fe1b8437465b505541cebdad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNodeIdForMeshNodeId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>meshNodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific MeshNode. This function is provided for completion, as NodeID == MeshNodeID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshNodeIndex</td><td>The Index of a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> that will be used to calculate the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#ac8d54d1be8870914b0b832bea3c970ce" title="Get the number of Mesh nodes.">getNumMeshNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> index of the specified <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> node. This function just returns the meshNodeIndex (but is harmless and inlined).</dd></dl>

</div>
</div>
<a class="anchor" id="a102d1bfd1a7a3010ceef58366aab2c91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNodeIdFromCameraId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>cameraNodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific CameraNode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraNodeIndex</td><td>The Index of a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> that will be used to calculate the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#af8fc8bd4319414e87c68f592785e95f3" title="Get the number of Camera nodes in this model">getNumCameraNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retunr The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> index of the specified camera node. Normally, it is the same as getNumMeshes + getNumLights + cameraNodeIndex</dd></dl>

</div>
</div>
<a class="anchor" id="a1e7ceeb09ea19701306d6896c01a6773"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNodeIdFromLightNodeId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>lightNodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the GLOBAL index of a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightNodeIndex</td><td>The Index of the <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. It is not the same as the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a8c1fa99092486c46ab5ae93700f24d32" title="Get the number of Light nodes.">getNumLightNodes()</a>-1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> index of the same index. It is the same as <a class="el" href="classpvr_1_1assets_1_1_model.html#ac8d54d1be8870914b0b832bea3c970ce" title="Get the number of Mesh nodes.">getNumMeshNodes()</a> + lightNodeIndex. </dd></dl>

</div>
</div>
<a class="anchor" id="af8fc8bd4319414e87c68f592785e95f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumCameraNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> nodes in this model</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> instances (Nodes) in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="a8c57b2961fd9b09a2b545a5517badc85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumCameras </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct camera objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene.">Camera</a> Instances (Nodes).</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of distinct camera objects.</dd></dl>

</div>
</div>
<a class="anchor" id="aeb5ecf05c4a2056b8f0a2fc602c47c89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumFrames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of frames in the scene. The total number of usable animated frames is limited to exclude (numFrames - 1) but include any partial number up to (numFrames - 1). Example: If there are 100 frames of animation, the highest frame number allowed is 98, since that will blend between frames 98 and 99. (99 being of course the 100th frame.)</p>
<dl class="section return"><dt>Returns</dt><dd>Return the number of frames in this model</dd></dl>

</div>
</div>
<a class="anchor" id="a8c1fa99092486c46ab5ae93700f24d32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumLightNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> instances (Nodes) in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="abca9f5e292c557593869a19b34dfa8f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> Instances (Nodes).</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of distinct <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene.">Light</a> objects in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="adcdfc2581e90fc95fa9c80361d1054fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumMaterials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct Materials in the scene.</p>
<dl class="section return"><dt>Returns</dt><dd>Return number of materials in this scene</dd></dl>

</div>
</div>
<a class="anchor" id="aee0265d41fa06b5a1a6f7ed767536c67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> objects. Unless each <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> appears at exactly one <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>, may be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> instances.</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of different <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> objects in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="ac8d54d1be8870914b0b832bea3c970ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumMeshNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>Return The number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.">Mesh</a> instances (Nodes) in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="af716e167c0a1a792ec1183c1c027aebe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of nodes (Meshes, Cameras, Lights, others (helpers etc)).</p>
<dl class="section return"><dt>Returns</dt><dd>Return number of nodes in this model</dd></dl>

</div>
</div>
<a class="anchor" id="a5b0bc08904b1d06b6715f76fcbfec437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct Textures in the scene.</p>
<dl class="section return"><dt>Returns</dt><dd>Return number of distinct textures</dd></dl>

</div>
</div>
<a class="anchor" id="ad56ccd607bc189d8ccb6e3eb8541ec37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html">Texture</a>&amp; pvr::assets::Model::getTexture </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the texture with the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the texture to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a texture from this scene</dd></dl>

</div>
</div>
<a class="anchor" id="ad9d60bce3fce1c4a613d181f1cb56a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>nodeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will store a copy of the matrix in an internal cache so that repeated calls for it will use the cached copy of it. Will also store the cached versions of all parents of this node, or use cached versions of them if they exist. Use this if you have long hierarchies and/or repeated calls per frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node for which to return the world matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The world matrix of (nodeId).</dd></dl>

</div>
</div>
<a class="anchor" id="a83240720d4a46efd7b4e47844fdf535e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getWorldMatrixNoCache </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>nodeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes.">Model</a>'s current frame of animation. This version will not use caching and will recalculate the matrix. Faster if the matrix is only used a few times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node for which to return the world matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return The world matrix of (nodeId)</dd></dl>

</div>
</div>
<a class="anchor" id="ab78c62c58d34db54afab9b9349bb29b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::initCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the cache. Call this after changing the model data. It is automatically called by <a class="el" href="classpvr_1_1assets_1_1_p_o_d_reader.html" title="This class creates pvr::assets::Model object from Streams of POD Model data. Use the readAsset method...">PODReader</a> when reading a POD file.</p>

</div>
</div>
<a class="anchor" id="a4a62ffa50fdac571582f6ae9cef4ce67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::Model::setCurrentFrame </td>
          <td>(</td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current frame. Affects future animation calls (getWorldMatrix etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The current frame. Can be fractional, in which case interpolation will normally be performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if out of bounds.</dd></dl>

</div>
</div>
<a class="anchor" id="a41781d67f47ca6c63299d570c96a717d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::setFPS </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>fps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the expected FPS of the animation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fps</td><td>FPS of the animation</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56d2206341aff4dc3bcd281ab6ef3c51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::setUserData </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set custom user data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size, in bytes, of the data.</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the raw data. (size) bytes will be copied as-is from this pointer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade4f26cbd59a02e09724292826732215"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::toWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4 &amp;&#160;</td>
          <td class="paramname"><em>localMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a custom matrix with a node's parent's transformation. Allows a custom matrix to be applied to a node, while honoring the hierarchical transformations applied by its parent hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node whose parents will be applied to the transformation.</td></tr>
    <tr><td class="paramname">localMatrix</td><td>The matrix to transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The localMatrix transformation, modified by the hierarchical transformations of the node. </dd></dl>
<p>This function can be used to implement custom procedural animation/kinematics schemes, in which case some nodes may need to have their animations customly defined, but must still honor their parents' transformations.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRAssets/<a class="el" href="_model_8h_source.html">Model.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
