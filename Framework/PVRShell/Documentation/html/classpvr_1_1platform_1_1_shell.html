<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRShell: pvr::platform::Shell Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRShell</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1platform.html">platform</a></li><li class="navelem"><a class="el" href="classpvr_1_1platform_1_1_shell.html">Shell</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classpvr_1_1platform_1_1_shell-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::platform::Shell Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The PowerVR <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> (pvr::Shell) is the main class that the user will inherit his application from.  
 <a href="classpvr_1_1platform_1_1_shell.html#details">More...</a></p>

<p>Inherits IPlatformProvider.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1platform_1_1_shell_1_1_pointer_normalised_location.html">PointerNormalisedLocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a pointer location in normalised coordinates. <a href="structpvr_1_1platform_1_1_shell_1_1_pointer_normalised_location.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1platform_1_1_shell_1_1_pointing_device_state.html">PointingDeviceState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the state of a pointing device (mouse, touch screen). <a href="structpvr_1_1platform_1_1_shell_1_1_pointing_device_state.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1platform_1_1_shell_1_1_private_pointer_state.html">PrivatePointerState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class of the pvr::Shell. <a href="structpvr_1_1platform_1_1_shell_1_1_private_pointer_state.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8823ff36848a13ebad921e9d3b2aedeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a8823ff36848a13ebad921e9d3b2aedeb">Shell</a> ()</td></tr>
<tr class="memdesc:a8823ff36848a13ebad921e9d3b2aedeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Do not instantiate a <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> class directly - extend as your application and then provide the <a class="el" href="namespacepvr.html#aacdfd9cc3d99a51f4b534c2b75f40920" title="—IMPLEMENT THIS FUNCTION IN YOUR MAIN CODE FILE TO POWER YOUR APPLICATION—">newDemo()</a> function returning your application instance. See bottom of this file. <a href="#a8823ff36848a13ebad921e9d3b2aedeb">More...</a><br/></td></tr>
<tr class="separator:a8823ff36848a13ebad921e9d3b2aedeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53e03eb253c06ad0977e07f7b53c938"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ad53e03eb253c06ad0977e07f7b53c938">~Shell</a> ()</td></tr>
<tr class="memdesc:ad53e03eb253c06ad0977e07f7b53c938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <a href="#ad53e03eb253c06ad0977e07f7b53c938">More...</a><br/></td></tr>
<tr class="separator:ad53e03eb253c06ad0977e07f7b53c938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a970a5e3e4389dfb11d9fbd860c9d0"><td class="memItemLeft" align="right" valign="top">GraphicsContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a91a970a5e3e4389dfb11d9fbd860c9d0">context</a> ()</td></tr>
<tr class="memdesc:a91a970a5e3e4389dfb11d9fbd860c9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GraphicsContext utilized by this shell. If operating without a context, it will be empty.  <a href="#a91a970a5e3e4389dfb11d9fbd860c9d0">More...</a><br/></td></tr>
<tr class="separator:a91a970a5e3e4389dfb11d9fbd860c9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd146a5f05d11ca3146e07b86f83991"><td class="memItemLeft" align="right" valign="top">const GraphicsContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#adcd146a5f05d11ca3146e07b86f83991">context</a> () const </td></tr>
<tr class="memdesc:adcd146a5f05d11ca3146e07b86f83991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GraphicsContext utilized by this shell. If operating without a context, it will be empty.  <a href="#adcd146a5f05d11ca3146e07b86f83991">More...</a><br/></td></tr>
<tr class="separator:adcd146a5f05d11ca3146e07b86f83991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4167538c72b7eae18d00a73f9f72a753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a4167538c72b7eae18d00a73f9f72a753">exitShell</a> ()</td></tr>
<tr class="memdesc:a4167538c72b7eae18d00a73f9f72a753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies the application to clean up and exit. Will go through the normal <a class="el" href="classpvr_1_1platform_1_1_state_machine.html" title="The StateMachine controlling the PowerVR Shell. Provides the application main loop and callbacks...">StateMachine</a> cycle and exit cleanly, exactly like returning ExitRenderFrame from RenderFrame. Will skip the next RenderFrame execution.  <a href="#a4167538c72b7eae18d00a73f9f72a753">More...</a><br/></td></tr>
<tr class="separator:a4167538c72b7eae18d00a73f9f72a753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07b1caa59d76f1e46b4f8061e2ba6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae07b1caa59d76f1e46b4f8061e2ba6c6">forceReinitView</a> ()</td></tr>
<tr class="memdesc:ae07b1caa59d76f1e46b4f8061e2ba6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">EFFECTIVE IF CALLED DURING RenderFrame. Force the shell to ReleaseView and then InitView again after this frame. <a href="#ae07b1caa59d76f1e46b4f8061e2ba6c6">More...</a><br/></td></tr>
<tr class="separator:ae07b1caa59d76f1e46b4f8061e2ba6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eb1cae4e8d14a89c02bbc1c119a3df"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ab2eb1cae4e8d14a89c02bbc1c119a3df">getAASamples</a> () const </td></tr>
<tr class="memdesc:ab2eb1cae4e8d14a89c02bbc1c119a3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of anti-aliasing samples. <a href="#ab2eb1cae4e8d14a89c02bbc1c119a3df">More...</a><br/></td></tr>
<tr class="separator:ab2eb1cae4e8d14a89c02bbc1c119a3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc1a0807e40d972b546137d91aec6c3"><td class="memItemLeft" align="right" valign="top">Api&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a3fc1a0807e40d972b546137d91aec6c3">getApiType</a> () const </td></tr>
<tr class="memdesc:a3fc1a0807e40d972b546137d91aec6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT VIEW OR AFTER. Get the actual API version created. <a href="#a3fc1a0807e40d972b546137d91aec6c3">More...</a><br/></td></tr>
<tr class="separator:a3fc1a0807e40d972b546137d91aec6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694831dd042c23a0f558f4edb0f5881f"><td class="memItemLeft" align="right" valign="top">BaseApi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a694831dd042c23a0f558f4edb0f5881f">getApiTypeBase</a> ()</td></tr>
<tr class="memdesc:a694831dd042c23a0f558f4edb0f5881f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context type/version (if any) that will be/was requested. Before init view, returns the requested base api type (OpenGL ES/ Vulkan). After init application, it returns the Created api type. This only makes sense if the PVRApi library is loaded Dynamically (in which case it controls the PVRApi library that the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> will attempt to load, otherwise the Base api type is fixed to the linked-in library. Default: BaseApi::Unspecified. If unspecified, the application will try Vulkan first, then OpenGL ES, then will set it to whichever one succeeded first. <a href="#a694831dd042c23a0f558f4edb0f5881f">More...</a><br/></td></tr>
<tr class="separator:a694831dd042c23a0f558f4edb0f5881f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e445a570eeb47d780682102a63c62f"><td class="memItemLeft" align="right" valign="top">Api&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#af5e445a570eeb47d780682102a63c62f">getApiTypeRequired</a> ()</td></tr>
<tr class="memdesc:af5e445a570eeb47d780682102a63c62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context type/version (if any) that will be requested <a href="#af5e445a570eeb47d780682102a63c62f">More...</a><br/></td></tr>
<tr class="separator:af5e445a570eeb47d780682102a63c62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae636d636efc52d5975692490186c4bed"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae636d636efc52d5975692490186c4bed">getApplicationName</a> () const </td></tr>
<tr class="memdesc:ae636d636efc52d5975692490186c4bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get application name. <a href="#ae636d636efc52d5975692490186c4bed">More...</a><br/></td></tr>
<tr class="separator:ae636d636efc52d5975692490186c4bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ec603b5cbc6f40e8c1dcd7649dd2b1"><td class="memItemLeft" align="right" valign="top">Stream::ptr_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a40ec603b5cbc6f40e8c1dcd7649dd2b1">getAssetStream</a> (const string &amp;filename, bool logFileNotFound=true)</td></tr>
<tr class="memdesc:a40ec603b5cbc6f40e8c1dcd7649dd2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a Stream object for a specific filename. Uses platform dependent lookup rules to create the stream from the filesystem or a platform-specific store (Windows resources, Android .apk assets) etc. Will first try the filesystem (if available) and then the built-in stores, in order to allow the user to easily override built-in assets. <a href="#a40ec603b5cbc6f40e8c1dcd7649dd2b1">More...</a><br/></td></tr>
<tr class="separator:a40ec603b5cbc6f40e8c1dcd7649dd2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478955ee7e0d4af18f047e14a4536472"><td class="memItemLeft" align="right" valign="top">types::ColorSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a478955ee7e0d4af18f047e14a4536472">getBackBufferColorspace</a> ()</td></tr>
<tr class="memdesc:a478955ee7e0d4af18f047e14a4536472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Colorspace of the main window framebuffer (linear RGB or sRGB). <a href="#a478955ee7e0d4af18f047e14a4536472">More...</a><br/></td></tr>
<tr class="separator:a478955ee7e0d4af18f047e14a4536472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a2ce302d8aa51534fe6726efd2c4ff"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae9a2ce302d8aa51534fe6726efd2c4ff">getCaptureFrameStart</a> () const </td></tr>
<tr class="memdesc:ae9a2ce302d8aa51534fe6726efd2c4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">If capturing frames, get the first frame to be captured. <a href="#ae9a2ce302d8aa51534fe6726efd2c4ff">More...</a><br/></td></tr>
<tr class="separator:ae9a2ce302d8aa51534fe6726efd2c4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e9d72f396bad01589c4aa0f1839bdb"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a30e9d72f396bad01589c4aa0f1839bdb">getCaptureFrameStop</a> () const </td></tr>
<tr class="memdesc:a30e9d72f396bad01589c4aa0f1839bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If capturing frames, get the last frame to be captured. <a href="#a30e9d72f396bad01589c4aa0f1839bdb">More...</a><br/></td></tr>
<tr class="separator:a30e9d72f396bad01589c4aa0f1839bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c77934b5e22e606f9aa4e962ebabec"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a49c77934b5e22e606f9aa4e962ebabec">getColorBitsPerPixel</a> () const </td></tr>
<tr class="separator:a49c77934b5e22e606f9aa4e962ebabec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9607ec52c4262f8ca2f9f341f1edea"><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="classpvr_1_1platform_1_1_command_line_parser_1_1_parsed_command_line.html">platform::CommandLineParser::ParsedCommandLine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a9a9607ec52c4262f8ca2f9f341f1edea">getCommandLine</a> () const </td></tr>
<tr class="memdesc:a9a9607ec52c4262f8ca2f9f341f1edea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the command line options that were passed at application launch. <a href="#a9a9607ec52c4262f8ca2f9f341f1edea">More...</a><br/></td></tr>
<tr class="separator:a9a9607ec52c4262f8ca2f9f341f1edea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0edfc58e438752960a5172af253326d"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ad0edfc58e438752960a5172af253326d">getContextPriority</a> () const </td></tr>
<tr class="memdesc:ad0edfc58e438752960a5172af253326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the requested context priority.0=Low,1=Medium, 2+ = High. Initial value: High. <a href="#ad0edfc58e438752960a5172af253326d">More...</a><br/></td></tr>
<tr class="separator:ad0edfc58e438752960a5172af253326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c345be69760b5902cc24740ba22095"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a34c345be69760b5902cc24740ba22095">getDefaultReadPath</a> () const </td></tr>
<tr class="memdesc:a34c345be69760b5902cc24740ba22095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default read path. <a href="#a34c345be69760b5902cc24740ba22095">More...</a><br/></td></tr>
<tr class="separator:a34c345be69760b5902cc24740ba22095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c58cf0d8f870a438f08849b5ee312d"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a92c58cf0d8f870a438f08849b5ee312d">getDepthBitsPerPixel</a> () const </td></tr>
<tr class="memdesc:a92c58cf0d8f870a438f08849b5ee312d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of framebuffer depth bits per pixel. <a href="#a92c58cf0d8f870a438f08849b5ee312d">More...</a><br/></td></tr>
<tr class="separator:a92c58cf0d8f870a438f08849b5ee312d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae909ba5e257bff6d2008928e54a89ea3"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae909ba5e257bff6d2008928e54a89ea3">getDesiredConfig</a> () const </td></tr>
<tr class="memdesc:ae909ba5e257bff6d2008928e54a89ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If setDesiredConfig was called, get the desired ConfigID. <a href="#ae909ba5e257bff6d2008928e54a89ea3">More...</a><br/></td></tr>
<tr class="separator:ae909ba5e257bff6d2008928e54a89ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70dde0ad120cda0c7c35c81d0a4c675"><td class="memItemLeft" align="right" valign="top">DeviceQueueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#aa70dde0ad120cda0c7c35c81d0a4c675">getDeviceQueueTypesRequired</a> ()</td></tr>
<tr class="memdesc:aa70dde0ad120cda0c7c35c81d0a4c675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the DeviceQueueTypes that have been set as required. <a href="#aa70dde0ad120cda0c7c35c81d0a4c675">More...</a><br/></td></tr>
<tr class="separator:aa70dde0ad120cda0c7c35c81d0a4c675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e13da25122536b19408761a0a70dad"><td class="memItemLeft" align="right" valign="top">OSDisplay&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ad9e13da25122536b19408761a0a70dad">getDisplay</a> ()</td></tr>
<tr class="memdesc:ad9e13da25122536b19408761a0a70dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying Display object of this shell <a href="#ad9e13da25122536b19408761a0a70dad">More...</a><br/></td></tr>
<tr class="separator:ad9e13da25122536b19408761a0a70dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d80f476079f36afb8b8a2f6245a6ac"><td class="memItemLeft" align="right" valign="top">DisplayAttributes &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#aa7d80f476079f36afb8b8a2f6245a6ac">getDisplayAttributes</a> ()</td></tr>
<tr class="memdesc:aa7d80f476079f36afb8b8a2f6245a6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the display attributes (width, height, bpp, AA, etc) of this pvr::Shell <a href="#aa7d80f476079f36afb8b8a2f6245a6ac">More...</a><br/></td></tr>
<tr class="separator:aa7d80f476079f36afb8b8a2f6245a6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d68ff773c8298caf65664ba57708285"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a0d68ff773c8298caf65664ba57708285">getExitMessage</a> () const </td></tr>
<tr class="memdesc:a0d68ff773c8298caf65664ba57708285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the exit message set by the user. <a href="#a0d68ff773c8298caf65664ba57708285">More...</a><br/></td></tr>
<tr class="separator:a0d68ff773c8298caf65664ba57708285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0720fc590a4e1b3d6c1e1ebc1389a014"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a0720fc590a4e1b3d6c1e1ebc1389a014">getFakeFrameTime</a> () const </td></tr>
<tr class="memdesc:a0720fc590a4e1b3d6c1e1ebc1389a014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the artificial frame time that has been set. 0 means unset. <a href="#a0720fc590a4e1b3d6c1e1ebc1389a014">More...</a><br/></td></tr>
<tr class="separator:a0720fc590a4e1b3d6c1e1ebc1389a014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2fbebe378e7b93953dbe2b801f7689"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a4c2fbebe378e7b93953dbe2b801f7689">getFPS</a> () const </td></tr>
<tr class="memdesc:a4c2fbebe378e7b93953dbe2b801f7689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an FPS calculation of the last frame. <a href="#a4c2fbebe378e7b93953dbe2b801f7689">More...</a><br/></td></tr>
<tr class="separator:a4c2fbebe378e7b93953dbe2b801f7689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2235132400a63d495f48a1b24ce3daf0"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a2235132400a63d495f48a1b24ce3daf0">getFrameTime</a> ()</td></tr>
<tr class="memdesc:a2235132400a63d495f48a1b24ce3daf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The duration of the last frame to pass, in milliseconds. This is the time to use to advance app logic. <a href="#a2235132400a63d495f48a1b24ce3daf0">More...</a><br/></td></tr>
<tr class="separator:a2235132400a63d495f48a1b24ce3daf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816cb36e28cff45dfaf925027f386608"><td class="memItemLeft" align="right" valign="top">GraphicsContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a816cb36e28cff45dfaf925027f386608">getGraphicsContext</a> ()</td></tr>
<tr class="memdesc:a816cb36e28cff45dfaf925027f386608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GraphicsContext utilized by this shell. If operating without a context, it will be empty.  <a href="#a816cb36e28cff45dfaf925027f386608">More...</a><br/></td></tr>
<tr class="separator:a816cb36e28cff45dfaf925027f386608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ff7d4bc499f4630dc89075599fe988"><td class="memItemLeft" align="right" valign="top">const GraphicsContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#aa9ff7d4bc499f4630dc89075599fe988">getGraphicsContext</a> () const </td></tr>
<tr class="memdesc:aa9ff7d4bc499f4630dc89075599fe988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GraphicsContext utilized by this shell. If operating without a context, it will be empty.  <a href="#aa9ff7d4bc499f4630dc89075599fe988">More...</a><br/></td></tr>
<tr class="separator:aa9ff7d4bc499f4630dc89075599fe988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc29050d03645b8cbde647aa658a90e"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#acdc29050d03645b8cbde647aa658a90e">getHeight</a> () const </td></tr>
<tr class="memdesc:acdc29050d03645b8cbde647aa658a90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the height of the application area (window height for windowed, or screen height for full screen). <a href="#acdc29050d03645b8cbde647aa658a90e">More...</a><br/></td></tr>
<tr class="separator:acdc29050d03645b8cbde647aa658a90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fac01f919fec264e9535714290c20e"><td class="memItemLeft" align="right" valign="top">Api&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a00fac01f919fec264e9535714290c20e">getMaxApiLevel</a> ()</td></tr>
<tr class="memdesc:a00fac01f919fec264e9535714290c20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum supported Graphics API type. <a href="#a00fac01f919fec264e9535714290c20e">More...</a><br/></td></tr>
<tr class="separator:a00fac01f919fec264e9535714290c20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b81d587a96f6d1fabd02affd65f084"><td class="memItemLeft" align="right" valign="top">Api&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ac0b81d587a96f6d1fabd02affd65f084">getMinApiTypeRequired</a> ()</td></tr>
<tr class="memdesc:ac0b81d587a96f6d1fabd02affd65f084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum Graphics API type (version) that the user has set. See setMinApiType. <a href="#ac0b81d587a96f6d1fabd02affd65f084">More...</a><br/></td></tr>
<tr class="separator:ac0b81d587a96f6d1fabd02affd65f084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba65d5b8de5089e1b802278389564d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1platform_1_1_shell_o_s.html">ShellOS</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a0ba65d5b8de5089e1b802278389564d3">getOS</a> () const </td></tr>
<tr class="memdesc:a0ba65d5b8de5089e1b802278389564d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classpvr_1_1platform_1_1_shell_o_s.html" title="Implements a lot of the functionality and forwards to the platform from PVRShell. Users don&#39;t use dir...">ShellOS</a> object owned by this shell. <a href="#a0ba65d5b8de5089e1b802278389564d3">More...</a><br/></td></tr>
<tr class="separator:a0ba65d5b8de5089e1b802278389564d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5c86046a025a230c5babba46309a53"><td class="memItemLeft" align="right" valign="top">IPlatformContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#aae5c86046a025a230c5babba46309a53">getPlatformContext</a> ()</td></tr>
<tr class="memdesc:aae5c86046a025a230c5babba46309a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Platform Context class used by this shell. <a href="#aae5c86046a025a230c5babba46309a53">More...</a><br/></td></tr>
<tr class="separator:aae5c86046a025a230c5babba46309a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de6eb150c1f27a1705b8d6335797ad9"><td class="memItemLeft" align="right" valign="top">const IPlatformContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a5de6eb150c1f27a1705b8d6335797ad9">getPlatformContext</a> () const </td></tr>
<tr class="memdesc:a5de6eb150c1f27a1705b8d6335797ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Platform Context class used by this shell. <a href="#a5de6eb150c1f27a1705b8d6335797ad9">More...</a><br/></td></tr>
<tr class="separator:a5de6eb150c1f27a1705b8d6335797ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e107d13fc9f17db04ec1897d09e2ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_pointer_location.html">PointerLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae3e107d13fc9f17db04ec1897d09e2ee">getPointerAbsolutePosition</a> ()</td></tr>
<tr class="memdesc:ae3e107d13fc9f17db04ec1897d09e2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the pointer location in pixels. <a href="#ae3e107d13fc9f17db04ec1897d09e2ee">More...</a><br/></td></tr>
<tr class="separator:ae3e107d13fc9f17db04ec1897d09e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342041abcfdad43330a1dd624840eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1platform_1_1_shell_1_1_pointer_normalised_location.html">PointerNormalisedLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae342041abcfdad43330a1dd624840eae">getPointerNormalisedPosition</a> ()</td></tr>
<tr class="memdesc:ae342041abcfdad43330a1dd624840eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the pointer location in normalised coordinates (0..1). <a href="#ae342041abcfdad43330a1dd624840eae">More...</a><br/></td></tr>
<tr class="separator:ae342041abcfdad43330a1dd624840eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b6766dae2979de1b064cef98734bae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1platform_1_1_shell_1_1_pointing_device_state.html">PointingDeviceState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a01b6766dae2979de1b064cef98734bae">getPointingDeviceState</a> ()</td></tr>
<tr class="memdesc:a01b6766dae2979de1b064cef98734bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the state of the pointing device (Mouse, Touchscreend). <a href="#a01b6766dae2979de1b064cef98734bae">More...</a><br/></td></tr>
<tr class="separator:a01b6766dae2979de1b064cef98734bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724c1c7c09db7518019fc04c57208dd0"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a724c1c7c09db7518019fc04c57208dd0">getPositionX</a> () const </td></tr>
<tr class="memdesc:a724c1c7c09db7518019fc04c57208dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the window position X coordinate. <a href="#a724c1c7c09db7518019fc04c57208dd0">More...</a><br/></td></tr>
<tr class="separator:a724c1c7c09db7518019fc04c57208dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d8b553cd0d30994f5c7029cdfe9ace"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ac3d8b553cd0d30994f5c7029cdfe9ace">getPositionY</a> () const </td></tr>
<tr class="memdesc:ac3d8b553cd0d30994f5c7029cdfe9ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the window position Y coordinate. <a href="#ac3d8b553cd0d30994f5c7029cdfe9ace">More...</a><br/></td></tr>
<tr class="separator:ac3d8b553cd0d30994f5c7029cdfe9ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db93c6f84c791ae661566d2fa015b60"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a3db93c6f84c791ae661566d2fa015b60">getQuitAfterFrame</a> () const </td></tr>
<tr class="memdesc:a3db93c6f84c791ae661566d2fa015b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the frame after which the application is set to automatically quit. If QuitAfterFrame was not set, returns -1 <a href="#a3db93c6f84c791ae661566d2fa015b60">More...</a><br/></td></tr>
<tr class="separator:a3db93c6f84c791ae661566d2fa015b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7494f6cd91116e25a7b98889f0de81fd"><td class="memItemLeft" align="right" valign="top">float32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a7494f6cd91116e25a7b98889f0de81fd">getQuitAfterTime</a> () const </td></tr>
<tr class="memdesc:a7494f6cd91116e25a7b98889f0de81fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time after which the application is set to automatically quit.If QuitAfterTime was not set, returns -1 <a href="#a7494f6cd91116e25a7b98889f0de81fd">More...</a><br/></td></tr>
<tr class="separator:a7494f6cd91116e25a7b98889f0de81fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab074d836de9c0d3287d1d06accb4bdd9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ab074d836de9c0d3287d1d06accb4bdd9">getReadPaths</a> () const </td></tr>
<tr class="memdesc:ab074d836de9c0d3287d1d06accb4bdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all paths that will be tried when looking for loading files. <a href="#ab074d836de9c0d3287d1d06accb4bdd9">More...</a><br/></td></tr>
<tr class="separator:ab074d836de9c0d3287d1d06accb4bdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd79d6cc6d0746d90dd3c479b11e522a"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#acd79d6cc6d0746d90dd3c479b11e522a">getStencilBitsPerPixel</a> () const </td></tr>
<tr class="memdesc:acd79d6cc6d0746d90dd3c479b11e522a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of framebuffer stencil bits per pixel. <a href="#acd79d6cc6d0746d90dd3c479b11e522a">More...</a><br/></td></tr>
<tr class="separator:acd79d6cc6d0746d90dd3c479b11e522a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ee07dbaeb76bc0a9aad320b5088ca7"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a21ee07dbaeb76bc0a9aad320b5088ca7">getSwapChainIndex</a> () const </td></tr>
<tr class="memdesc:a21ee07dbaeb76bc0a9aad320b5088ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the logical framebuffer image that the application currently owns and can render to. OpenGL ES will always return 0 as the backbuffer images imlementation are hidden in the driver and not exposed to the user. <a href="#a21ee07dbaeb76bc0a9aad320b5088ca7">More...</a><br/></td></tr>
<tr class="separator:a21ee07dbaeb76bc0a9aad320b5088ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0609031d1148a2e904c367c10bbec915"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a0609031d1148a2e904c367c10bbec915">getSwapChainLength</a> () const </td></tr>
<tr class="memdesc:a0609031d1148a2e904c367c10bbec915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of explicit, logical framebuffer images accessible to user code. OpenGL ES will always return 1 as the buffer swapping is hidden in the driver and images not explicitly handled by the user.  <a href="#a0609031d1148a2e904c367c10bbec915">More...</a><br/></td></tr>
<tr class="separator:a0609031d1148a2e904c367c10bbec915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081a0fccfeaf4eaaee690743e033a301"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a081a0fccfeaf4eaaee690743e033a301">getTime</a> ()</td></tr>
<tr class="memdesc:a081a0fccfeaf4eaaee690743e033a301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total time (from the same arbitrary starting point as getTimeAtInitApplication ), in milliseconds. <a href="#a081a0fccfeaf4eaaee690743e033a301">More...</a><br/></td></tr>
<tr class="separator:a081a0fccfeaf4eaaee690743e033a301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d416c1470694d9a971ec3ed18d0810"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a59d416c1470694d9a971ec3ed18d0810">getTimeAtInitApplication</a> () const </td></tr>
<tr class="memdesc:a59d416c1470694d9a971ec3ed18d0810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total time (from the same arbitrary starting point as getTime ), in milliseconds. <a href="#a59d416c1470694d9a971ec3ed18d0810">More...</a><br/></td></tr>
<tr class="separator:a59d416c1470694d9a971ec3ed18d0810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128ac0a6346b36e08d133a857ef077e8"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a128ac0a6346b36e08d133a857ef077e8">getTitle</a> () const </td></tr>
<tr class="memdesc:a128ac0a6346b36e08d133a857ef077e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the window title. <a href="#a128ac0a6346b36e08d133a857ef077e8">More...</a><br/></td></tr>
<tr class="separator:a128ac0a6346b36e08d133a857ef077e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d7168d3151eaff02271fcda7a90dc7"><td class="memItemLeft" align="right" valign="top">VsyncMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ab0d7168d3151eaff02271fcda7a90dc7">getVsyncMode</a> () const </td></tr>
<tr class="memdesc:ab0d7168d3151eaff02271fcda7a90dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vertical synchronization mode. <a href="#ab0d7168d3151eaff02271fcda7a90dc7">More...</a><br/></td></tr>
<tr class="separator:ab0d7168d3151eaff02271fcda7a90dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d08ea9694db43bca53e713986e4af4"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae7d08ea9694db43bca53e713986e4af4">getWidth</a> () const </td></tr>
<tr class="memdesc:ae7d08ea9694db43bca53e713986e4af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the width of the application area (window width for windowed, or screen width for full screen).  <a href="#ae7d08ea9694db43bca53e713986e4af4">More...</a><br/></td></tr>
<tr class="separator:ae7d08ea9694db43bca53e713986e4af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789f0558bbd23cdafebdb6909aa14480"><td class="memItemLeft" align="right" valign="top">OSWindow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a789f0558bbd23cdafebdb6909aa14480">getWindow</a> ()</td></tr>
<tr class="memdesc:a789f0558bbd23cdafebdb6909aa14480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying Window object of this shell <a href="#a789f0558bbd23cdafebdb6909aa14480">More...</a><br/></td></tr>
<tr class="separator:a789f0558bbd23cdafebdb6909aa14480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0512b708ed33dd17d56063fa4f9521b1"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a0512b708ed33dd17d56063fa4f9521b1">getWritePath</a> () const </td></tr>
<tr class="memdesc:a0512b708ed33dd17d56063fa4f9521b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the path where any files will be saved. <a href="#a0512b708ed33dd17d56063fa4f9521b1">More...</a><br/></td></tr>
<tr class="separator:a0512b708ed33dd17d56063fa4f9521b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ed6f2ac11d35a4aa2ae0fe1379ac38"><td class="memItemLeft" align="right" valign="top">Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a46ed6f2ac11d35a4aa2ae0fe1379ac38">init</a> (<a class="el" href="structpvr_1_1platform_1_1_shell_data.html">ShellData</a> *data)</td></tr>
<tr class="memdesc:a46ed6f2ac11d35a4aa2ae0fe1379ac38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called at the appropriate time by the state machine. <a href="#a46ed6f2ac11d35a4aa2ae0fe1379ac38">More...</a><br/></td></tr>
<tr class="separator:a46ed6f2ac11d35a4aa2ae0fe1379ac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b862931b196e1c7edba62b57f54ca1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a21b862931b196e1c7edba62b57f54ca1">isApiSupported</a> (Api api)</td></tr>
<tr class="memdesc:a21b862931b196e1c7edba62b57f54ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if a particular Graphics API type/version is supported. <a href="#a21b862931b196e1c7edba62b57f54ca1">More...</a><br/></td></tr>
<tr class="separator:a21b862931b196e1c7edba62b57f54ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bd3203017715795be06b4c9899bda2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#af6bd3203017715795be06b4c9899bda2">isButtonPressed</a> (int8 buttonIndex)</td></tr>
<tr class="memdesc:af6bd3203017715795be06b4c9899bda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a key is pressed. <a href="#af6bd3203017715795be06b4c9899bda2">More...</a><br/></td></tr>
<tr class="separator:af6bd3203017715795be06b4c9899bda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050873597a4aa2219438a3c9847b07b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a050873597a4aa2219438a3c9847b07b2">isForcingFrameTime</a> ()</td></tr>
<tr class="memdesc:a050873597a4aa2219438a3c9847b07b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if frame time is forced (forceFrameTime(true) has been called) <a href="#a050873597a4aa2219438a3c9847b07b2">More...</a><br/></td></tr>
<tr class="separator:a050873597a4aa2219438a3c9847b07b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a6aa614314d7ffc64df613dda69c34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a66a6aa614314d7ffc64df613dda69c34">isFullScreen</a> () const </td></tr>
<tr class="memdesc:a66a6aa614314d7ffc64df613dda69c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get if the application is running in full screen. <a href="#a66a6aa614314d7ffc64df613dda69c34">More...</a><br/></td></tr>
<tr class="separator:a66a6aa614314d7ffc64df613dda69c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2680be831cce7dc6e6c6421e8094761"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ac2680be831cce7dc6e6c6421e8094761">isKeyPressed</a> (<a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a> key)</td></tr>
<tr class="memdesc:ac2680be831cce7dc6e6c6421e8094761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a key is pressed. <a href="#ac2680be831cce7dc6e6c6421e8094761">More...</a><br/></td></tr>
<tr class="separator:ac2680be831cce7dc6e6c6421e8094761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fc6afd43168fa94c71444dfe6cc4db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a00fc6afd43168fa94c71444dfe6cc4db">isPresentingBackBuffer</a> ()</td></tr>
<tr class="memdesc:a00fc6afd43168fa94c71444dfe6cc4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if present backbuffer is enabled <a href="#a00fc6afd43168fa94c71444dfe6cc4db">More...</a><br/></td></tr>
<tr class="separator:a00fc6afd43168fa94c71444dfe6cc4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164a3b661154f8805cc85b3ab829546e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a164a3b661154f8805cc85b3ab829546e">isScreenRotated</a> () const </td></tr>
<tr class="memdesc:a164a3b661154f8805cc85b3ab829546e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if screen is rotated <a href="#a164a3b661154f8805cc85b3ab829546e">More...</a><br/></td></tr>
<tr class="separator:a164a3b661154f8805cc85b3ab829546e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50991a6cef3c6726737a6242d018df3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a50991a6cef3c6726737a6242d018df3c">isShowingFPS</a> () const </td></tr>
<tr class="memdesc:a50991a6cef3c6726737a6242d018df3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if FPS are being printed out. <a href="#a50991a6cef3c6726737a6242d018df3c">More...</a><br/></td></tr>
<tr class="separator:a50991a6cef3c6726737a6242d018df3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e93594310a55610c3b65252726051d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a56e93594310a55610c3b65252726051d">onKeyDown</a> (<a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a> key)</td></tr>
<tr class="memdesc:a56e93594310a55610c3b65252726051d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used externally to signify events to the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. Do not use. <a href="#a56e93594310a55610c3b65252726051d">More...</a><br/></td></tr>
<tr class="separator:a56e93594310a55610c3b65252726051d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cfca84a66074f6bad4ce6d14d60e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#af3cfca84a66074f6bad4ce6d14d60e94">onKeyUp</a> (<a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a> key)</td></tr>
<tr class="memdesc:af3cfca84a66074f6bad4ce6d14d60e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used externally to signify events to the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. Do not use. <a href="#af3cfca84a66074f6bad4ce6d14d60e94">More...</a><br/></td></tr>
<tr class="separator:af3cfca84a66074f6bad4ce6d14d60e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea9778498ede4935e9efee2c3b1088c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a6ea9778498ede4935e9efee2c3b1088c">onPointingDeviceDown</a> (uint8 buttonIdx)</td></tr>
<tr class="memdesc:a6ea9778498ede4935e9efee2c3b1088c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used externally to signify events to the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. Do not use. <a href="#a6ea9778498ede4935e9efee2c3b1088c">More...</a><br/></td></tr>
<tr class="separator:a6ea9778498ede4935e9efee2c3b1088c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990408e55fef68e7ef310c283477aa69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a990408e55fef68e7ef310c283477aa69">onPointingDeviceUp</a> (uint8 buttonIdx)</td></tr>
<tr class="memdesc:a990408e55fef68e7ef310c283477aa69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used externally to signify events to the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. Do not use. <a href="#a990408e55fef68e7ef310c283477aa69">More...</a><br/></td></tr>
<tr class="separator:a990408e55fef68e7ef310c283477aa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1112fb5c192dcab32438f3a7df87febd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a1112fb5c192dcab32438f3a7df87febd">onSystemEvent</a> (<a class="el" href="namespacepvr.html#ae4c92053860fcd90c8ae00f40354965a">SystemEvent</a> systemEvent)</td></tr>
<tr class="memdesc:a1112fb5c192dcab32438f3a7df87febd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used externally to signify events to the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. Do not use. <a href="#a1112fb5c192dcab32438f3a7df87febd">More...</a><br/></td></tr>
<tr class="separator:a1112fb5c192dcab32438f3a7df87febd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2868959c03e02eaf3e764e8f0f04fd8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a2868959c03e02eaf3e764e8f0f04fd8b">setAASamples</a> (uint32 value)</td></tr>
<tr class="memdesc:a2868959c03e02eaf3e764e8f0f04fd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the Anti-Aliasing samples. <a href="#a2868959c03e02eaf3e764e8f0f04fd8b">More...</a><br/></td></tr>
<tr class="separator:a2868959c03e02eaf3e764e8f0f04fd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88eb9ffb5cb1fff4031b3cfcee0c71e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae88eb9ffb5cb1fff4031b3cfcee0c71e">setApiTypeBase</a> (BaseApi contextType)</td></tr>
<tr class="memdesc:ae88eb9ffb5cb1fff4031b3cfcee0c71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. ONLY EFFECTIVE IF PVRAPI IS LINKED DYNAMICALLY. If PVRApi is linked statically, this option is ignored. Sets a specific Graphics API type (version) that the user wants to use. The context creation will fail if this precise version cannot be created. <a href="#ae88eb9ffb5cb1fff4031b3cfcee0c71e">More...</a><br/></td></tr>
<tr class="separator:ae88eb9ffb5cb1fff4031b3cfcee0c71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229647b00e9c5f3639058c8e86deb8cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a229647b00e9c5f3639058c8e86deb8cd">setApiTypeRequired</a> (Api contextType)</td></tr>
<tr class="memdesc:a229647b00e9c5f3639058c8e86deb8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Sets a specific Graphics API type (version) that the user wants to use. The context creation will fail if this precise version cannot be created. <a href="#a229647b00e9c5f3639058c8e86deb8cd">More...</a><br/></td></tr>
<tr class="separator:a229647b00e9c5f3639058c8e86deb8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31570f56ac74ab80f0f46c14d35aa6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#af31570f56ac74ab80f0f46c14d35aa6d">setApplicationName</a> (const char8 *const format,...)</td></tr>
<tr class="memdesc:af31570f56ac74ab80f0f46c14d35aa6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application name. <a href="#af31570f56ac74ab80f0f46c14d35aa6d">More...</a><br/></td></tr>
<tr class="separator:af31570f56ac74ab80f0f46c14d35aa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f01b0f1eac635f4f45ef13f2909c025"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a5f01b0f1eac635f4f45ef13f2909c025">setBackBufferColorspace</a> (types::ColorSpace colorSpace)</td></tr>
<tr class="memdesc:a5f01b0f1eac635f4f45ef13f2909c025"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Specify the colorspace of the backbuffer. Default is a (linear) RGB BackBuffer. Use this to specifically request an sRGB backbuffer. Since the support of backbuffer colorspace is an extension in many implementations, if you use this function, you must call getBackBufferColorspace after initApplication (in initView) to determine the actual backBuffer colorspace that was obtained. <a href="#a5f01b0f1eac635f4f45ef13f2909c025">More...</a><br/></td></tr>
<tr class="separator:a5f01b0f1eac635f4f45ef13f2909c025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab7a79cad01b237a855fd2f03cfb6f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a7ab7a79cad01b237a855fd2f03cfb6f6">setCaptureFrames</a> (uint32 start, uint32 stop)</td></tr>
<tr class="memdesc:a7ab7a79cad01b237a855fd2f03cfb6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Captures the frames between start and stop and saves them as TGA screenshots. <a href="#a7ab7a79cad01b237a855fd2f03cfb6f6">More...</a><br/></td></tr>
<tr class="separator:a7ab7a79cad01b237a855fd2f03cfb6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf803489d44cea8511e321c28d38697f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#acf803489d44cea8511e321c28d38697f">setCaptureFrameScale</a> (uint32 value)</td></tr>
<tr class="memdesc:acf803489d44cea8511e321c28d38697f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Sets the upscale factor of the screenshots. Upscaling only. <a href="#acf803489d44cea8511e321c28d38697f">More...</a><br/></td></tr>
<tr class="separator:acf803489d44cea8511e321c28d38697f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb0243cc20d520a20aa43ca0acbc301"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#aceb0243cc20d520a20aa43ca0acbc301">setColorBitsPerPixel</a> (uint32 r, uint32 g, uint32 b, uint32 a)</td></tr>
<tr class="memdesc:aceb0243cc20d520a20aa43ca0acbc301"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the number of framebuffer color bits per pixel.  <a href="#aceb0243cc20d520a20aa43ca0acbc301">More...</a><br/></td></tr>
<tr class="separator:aceb0243cc20d520a20aa43ca0acbc301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd65557708c43017b4fc1cb5638ab17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#acdd65557708c43017b4fc1cb5638ab17">setContextPriority</a> (uint32 value)</td></tr>
<tr class="memdesc:acdd65557708c43017b4fc1cb5638ab17"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. If supported, sets a ContextPriority that the shell will attempt to use when creating the main Graphics Context used for the window. Initial value:High. <a href="#acdd65557708c43017b4fc1cb5638ab17">More...</a><br/></td></tr>
<tr class="separator:acdd65557708c43017b4fc1cb5638ab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b439ac057b94f0b7587f3f1081e1bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ac4b439ac057b94f0b7587f3f1081e1bd">setDepthBitsPerPixel</a> (uint32 value)</td></tr>
<tr class="memdesc:ac4b439ac057b94f0b7587f3f1081e1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the number of framebuffer Depth bits per pixel.  <a href="#ac4b439ac057b94f0b7587f3f1081e1bd">More...</a><br/></td></tr>
<tr class="separator:ac4b439ac057b94f0b7587f3f1081e1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4163f6fc79b97c88881a233976f13f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ac4163f6fc79b97c88881a233976f13f8">setDesiredConfig</a> (uint32 value)</td></tr>
<tr class="memdesc:ac4163f6fc79b97c88881a233976f13f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. If supported by the platform/API, sets a specific Context Configuration ID to be used. <a href="#ac4163f6fc79b97c88881a233976f13f8">More...</a><br/></td></tr>
<tr class="separator:ac4163f6fc79b97c88881a233976f13f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2d2de897ff9daf9ea483b26c7cfb7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#acf2d2de897ff9daf9ea483b26c7cfb7c">setDeviceQueueTypesRequired</a> (DeviceQueueType queueType)</td></tr>
<tr class="memdesc:acf2d2de897ff9daf9ea483b26c7cfb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Sets the Device Queue types that the user may require (Graphics, Compute etc.). <a href="#acf2d2de897ff9daf9ea483b26c7cfb7c">More...</a><br/></td></tr>
<tr class="separator:acf2d2de897ff9daf9ea483b26c7cfb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36f9674a9ea0fe20cc66535eb582d4a"><td class="memItemLeft" align="right" valign="top">Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ad36f9674a9ea0fe20cc66535eb582d4a">setDimensions</a> (uint32 w, uint32 h)</td></tr>
<tr class="memdesc:ad36f9674a9ea0fe20cc66535eb582d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the window size, or resolution for fullscreen.  <a href="#ad36f9674a9ea0fe20cc66535eb582d4a">More...</a><br/></td></tr>
<tr class="separator:ad36f9674a9ea0fe20cc66535eb582d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c36585df3265610554f3ea256dd229b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a7c36585df3265610554f3ea256dd229b">setExitMessage</a> (const char8 *const format,...)</td></tr>
<tr class="memdesc:a7c36585df3265610554f3ea256dd229b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a message to be displayed on application exit. Normally used to display critical error messages that might be missed if displayed as just logs. <a href="#a7c36585df3265610554f3ea256dd229b">More...</a><br/></td></tr>
<tr class="separator:a7c36585df3265610554f3ea256dd229b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0611a541599bae56123d09e0914f226b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a0611a541599bae56123d09e0914f226b">setFakeFrameTime</a> (uint32 value)</td></tr>
<tr class="memdesc:a0611a541599bae56123d09e0914f226b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a time delta that will be used as frame time to increment the application clock instead of real time. This number will be returned as the frame time. <a href="#a0611a541599bae56123d09e0914f226b">More...</a><br/></td></tr>
<tr class="separator:a0611a541599bae56123d09e0914f226b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221f2df91b95f2c4c84367a4d2fe3c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a221f2df91b95f2c4c84367a4d2fe3c02">setForceFrameTime</a> (const bool value)</td></tr>
<tr class="memdesc:a221f2df91b95f2c4c84367a4d2fe3c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Forces frame time to always be reported as 1/60th of a second. <a href="#a221f2df91b95f2c4c84367a4d2fe3c02">More...</a><br/></td></tr>
<tr class="separator:a221f2df91b95f2c4c84367a4d2fe3c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61ef050b4e5dfd2df56c8a0c0380f0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae61ef050b4e5dfd2df56c8a0c0380f0b">setFullscreen</a> (const bool fullscreen)</td></tr>
<tr class="memdesc:ae61ef050b4e5dfd2df56c8a0c0380f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE AT INIT APPLICATION. Set the application to run at full screen mode. Not all platforms support this option. <a href="#ae61ef050b4e5dfd2df56c8a0c0380f0b">More...</a><br/></td></tr>
<tr class="separator:ae61ef050b4e5dfd2df56c8a0c0380f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eaa16cd2639b2fb56b600585cd17739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a8eaa16cd2639b2fb56b600585cd17739">setMinApiType</a> (Api contextType)</td></tr>
<tr class="memdesc:a8eaa16cd2639b2fb56b600585cd17739"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Sets the minimum Graphics API type (version) that the user intends to use. The context creation will fail if at least this context version cannot be created. The latest context version supported will be created. <a href="#a8eaa16cd2639b2fb56b600585cd17739">More...</a><br/></td></tr>
<tr class="separator:a8eaa16cd2639b2fb56b600585cd17739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40084cf10bdf42631325db22c783ea19"><td class="memItemLeft" align="right" valign="top">Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a40084cf10bdf42631325db22c783ea19">setPosition</a> (uint32 x, uint32 y)</td></tr>
<tr class="memdesc:a40084cf10bdf42631325db22c783ea19"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the window position. Not supported in all platforms.  <a href="#a40084cf10bdf42631325db22c783ea19">More...</a><br/></td></tr>
<tr class="separator:a40084cf10bdf42631325db22c783ea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2031ba1c70cd2abb75ecb86ac0d1a58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#aa2031ba1c70cd2abb75ecb86ac0d1a58">setPreferredSwapChainLength</a> (uint32 swapChainLength)</td></tr>
<tr class="memdesc:aa2031ba1c70cd2abb75ecb86ac0d1a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set a desired number of swap images (number of framebuffers). This number will be clamped between the minimum and the maximum number supported by the platform, so that if a small (0-1) or large (8+) number is requested, the minimum/maximum of the platform will always be providedd <a href="#aa2031ba1c70cd2abb75ecb86ac0d1a58">More...</a><br/></td></tr>
<tr class="separator:aa2031ba1c70cd2abb75ecb86ac0d1a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dea5800df044453c6502655f849273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a34dea5800df044453c6502655f849273">setPresentBackBuffer</a> (const bool value)</td></tr>
<tr class="memdesc:a34dea5800df044453c6502655f849273"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable or disable presenting back-buffer <a href="#a34dea5800df044453c6502655f849273">More...</a><br/></td></tr>
<tr class="separator:a34dea5800df044453c6502655f849273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40f368623a6f17aa04c19ca1530edfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae40f368623a6f17aa04c19ca1530edfe">setQuitAfterFrame</a> (uint32 value)</td></tr>
<tr class="memdesc:ae40f368623a6f17aa04c19ca1530edfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set a frame after which the application will quit.  <a href="#ae40f368623a6f17aa04c19ca1530edfe">More...</a><br/></td></tr>
<tr class="separator:ae40f368623a6f17aa04c19ca1530edfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7352c53f8a783bd17ce391d66317ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a9c7352c53f8a783bd17ce391d66317ba">setQuitAfterTime</a> (float32 value)</td></tr>
<tr class="memdesc:a9c7352c53f8a783bd17ce391d66317ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set a time after which the application will quit.  <a href="#a9c7352c53f8a783bd17ce391d66317ba">More...</a><br/></td></tr>
<tr class="separator:a9c7352c53f8a783bd17ce391d66317ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8304aca84d29e9d2b73de294c5d2141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ad8304aca84d29e9d2b73de294c5d2141">setShowFPS</a> (bool showFPS)</td></tr>
<tr class="memdesc:ad8304aca84d29e9d2b73de294c5d2141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets if the Frames Per Second are to be output periodically. <a href="#ad8304aca84d29e9d2b73de294c5d2141">More...</a><br/></td></tr>
<tr class="separator:ad8304aca84d29e9d2b73de294c5d2141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3a79e4e710049c7ace742a9e52736b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#abb3a79e4e710049c7ace742a9e52736b">setStencilBitsPerPixel</a> (uint32 value)</td></tr>
<tr class="memdesc:abb3a79e4e710049c7ace742a9e52736b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the number of Stencil bits per pixel. <a href="#abb3a79e4e710049c7ace742a9e52736b">More...</a><br/></td></tr>
<tr class="separator:abb3a79e4e710049c7ace742a9e52736b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc070e78f1606c30fa52c3eda612f115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#afc070e78f1606c30fa52c3eda612f115">setTitle</a> (const char8 *const format,...)</td></tr>
<tr class="memdesc:afc070e78f1606c30fa52c3eda612f115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the window title. Will only be actually displayed If used on or before initApplication.  <a href="#afc070e78f1606c30fa52c3eda612f115">More...</a><br/></td></tr>
<tr class="separator:afc070e78f1606c30fa52c3eda612f115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac463c721743516e42c0df1df1b2a9a4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ac463c721743516e42c0df1df1b2a9a4d">setVsyncMode</a> (VsyncMode mode)</td></tr>
<tr class="memdesc:ac463c721743516e42c0df1df1b2a9a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the Vertical Syncchronization mode(vertical sync). Default is On(Fifo). <a href="#ac463c721743516e42c0df1df1b2a9a4d">More...</a><br/></td></tr>
<tr class="separator:ac463c721743516e42c0df1df1b2a9a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bb9e4fe157fd5752bae827ab1f2b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a30bb9e4fe157fd5752bae827ab1f2b29">showOutputInfo</a> ()</td></tr>
<tr class="memdesc:a30bb9e4fe157fd5752bae827ab1f2b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out general information about this <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> (application name, sdk version, cmd line etc. <a href="#a30bb9e4fe157fd5752bae827ab1f2b29">More...</a><br/></td></tr>
<tr class="separator:a30bb9e4fe157fd5752bae827ab1f2b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621f7f15872e3573d2f005e010227658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a621f7f15872e3573d2f005e010227658">takeScreenshot</a> () const </td></tr>
<tr class="memdesc:a621f7f15872e3573d2f005e010227658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a screenshot of the current display. <a href="#a621f7f15872e3573d2f005e010227658">More...</a><br/></td></tr>
<tr class="separator:a621f7f15872e3573d2f005e010227658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6a422ab4f8017a483551e097e4c0f825"><td class="memItemLeft" align="right" valign="top">static const char8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a6a422ab4f8017a483551e097e4c0f825">getSDKVersion</a> ()</td></tr>
<tr class="memdesc:a6a422ab4f8017a483551e097e4c0f825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current version of the PowerVR SDK. <a href="#a6a422ab4f8017a483551e097e4c0f825">More...</a><br/></td></tr>
<tr class="separator:a6a422ab4f8017a483551e097e4c0f825"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ace40c1791026bfb17d90ae9e005f28d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ace40c1791026bfb17d90ae9e005f28d8">eventButtonDown</a> (int buttonIdx)</td></tr>
<tr class="memdesc:ace40c1791026bfb17d90ae9e005f28d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override in your class to handle the initial press (down) of the main input device (mouse, touchscreen).  <a href="#ace40c1791026bfb17d90ae9e005f28d8">More...</a><br/></td></tr>
<tr class="separator:ace40c1791026bfb17d90ae9e005f28d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f59b78bb6d0da1da9339b87b695f1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#af7f59b78bb6d0da1da9339b87b695f1d">eventButtonUp</a> (int buttonIdx)</td></tr>
<tr class="memdesc:af7f59b78bb6d0da1da9339b87b695f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override in your class to handle the release (up) of the main input device (mouse, touchscreen).  <a href="#af7f59b78bb6d0da1da9339b87b695f1d">More...</a><br/></td></tr>
<tr class="separator:af7f59b78bb6d0da1da9339b87b695f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb36fe97c5f88408421c601fbbe2698"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a8bb36fe97c5f88408421c601fbbe2698">eventClick</a> (int buttonIdx, <a class="el" href="classpvr_1_1_pointer_location.html">PointerLocation</a> location)</td></tr>
<tr class="memdesc:a8bb36fe97c5f88408421c601fbbe2698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override in your class to handle the "Click" or "Touch" event of the main input device (mouse or touchscreen). <a href="#a8bb36fe97c5f88408421c601fbbe2698">More...</a><br/></td></tr>
<tr class="separator:a8bb36fe97c5f88408421c601fbbe2698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216861873786dda96e1cd44a8d49c1d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a216861873786dda96e1cd44a8d49c1d8">eventDragFinished</a> (<a class="el" href="classpvr_1_1_pointer_location.html">PointerLocation</a> location)</td></tr>
<tr class="memdesc:a216861873786dda96e1cd44a8d49c1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override in your class to handle the finish of a "Drag" event of the main input device (mouse, touchscreen). <a href="#a216861873786dda96e1cd44a8d49c1d8">More...</a><br/></td></tr>
<tr class="separator:a216861873786dda96e1cd44a8d49c1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5d3ccde2d3dae7f799212f2b5be7c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a3f5d3ccde2d3dae7f799212f2b5be7c4">eventDragStart</a> (int buttonIdx, <a class="el" href="classpvr_1_1_pointer_location.html">PointerLocation</a> location)</td></tr>
<tr class="memdesc:a3f5d3ccde2d3dae7f799212f2b5be7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override in your class to handle the start of a "Drag" event of the main input device (mouse, touchscreen). <a href="#a3f5d3ccde2d3dae7f799212f2b5be7c4">More...</a><br/></td></tr>
<tr class="separator:a3f5d3ccde2d3dae7f799212f2b5be7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e933adb4460841204b58b36bb79d79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a35e933adb4460841204b58b36bb79d79">eventKeyDown</a> (<a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a> key)</td></tr>
<tr class="memdesc:a35e933adb4460841204b58b36bb79d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override in your class to handle the press of a key of the keyboard. <a href="#a35e933adb4460841204b58b36bb79d79">More...</a><br/></td></tr>
<tr class="separator:a35e933adb4460841204b58b36bb79d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4c6f24ff198e9d2b2772cbd00da007"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#afe4c6f24ff198e9d2b2772cbd00da007">eventKeyStroke</a> (<a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a> key)</td></tr>
<tr class="memdesc:afe4c6f24ff198e9d2b2772cbd00da007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override in your class to handle a keystroke of the keyboard. <a href="#afe4c6f24ff198e9d2b2772cbd00da007">More...</a><br/></td></tr>
<tr class="separator:afe4c6f24ff198e9d2b2772cbd00da007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd1296cb45dffdac831bfff5bd9c730"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a7fd1296cb45dffdac831bfff5bd9c730">eventKeyUp</a> (<a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a> key)</td></tr>
<tr class="memdesc:a7fd1296cb45dffdac831bfff5bd9c730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override in your class to handle the release (up) of a key of of the keyboard. <a href="#a7fd1296cb45dffdac831bfff5bd9c730">More...</a><br/></td></tr>
<tr class="separator:a7fd1296cb45dffdac831bfff5bd9c730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9a69685418d9328fa2415476319f06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a5e9a69685418d9328fa2415476319f06">eventMappedInput</a> (<a class="el" href="namespacepvr.html#a9a6da56806c568a6f9833d118c5c8083">SimplifiedInput</a> key)</td></tr>
<tr class="memdesc:a5e9a69685418d9328fa2415476319f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override in your class to handle a unified interface for input across different platforms and devices.  <a href="#a5e9a69685418d9328fa2415476319f06">More...</a><br/></td></tr>
<tr class="separator:a5e9a69685418d9328fa2415476319f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e68c454485cea2c5af4a2701e3078f"><td class="memItemLeft" align="right" valign="top">virtual Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a82e68c454485cea2c5af4a2701e3078f">initApplication</a> ()=0</td></tr>
<tr class="memdesc:a82e68c454485cea2c5af4a2701e3078f"><td class="mdescLeft">&#160;</td><td class="mdescRight">IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event represents application start. <a href="#a82e68c454485cea2c5af4a2701e3078f">More...</a><br/></td></tr>
<tr class="separator:a82e68c454485cea2c5af4a2701e3078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490e8314c751dff53ce6b9049bc59f33"><td class="memItemLeft" align="right" valign="top">virtual Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a490e8314c751dff53ce6b9049bc59f33">initView</a> ()=0</td></tr>
<tr class="memdesc:a490e8314c751dff53ce6b9049bc59f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event is called after successful window/context aquisition. <a href="#a490e8314c751dff53ce6b9049bc59f33">More...</a><br/></td></tr>
<tr class="separator:a490e8314c751dff53ce6b9049bc59f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c09cd21a42a07fc26d38d63d4df9b0"><td class="memItemLeft" align="right" valign="top">virtual Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a83c09cd21a42a07fc26d38d63d4df9b0">quitApplication</a> ()=0</td></tr>
<tr class="memdesc:a83c09cd21a42a07fc26d38d63d4df9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event represents application exit. <a href="#a83c09cd21a42a07fc26d38d63d4df9b0">More...</a><br/></td></tr>
<tr class="separator:a83c09cd21a42a07fc26d38d63d4df9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b25c8aa3c7cfa1d8841b23ed663345"><td class="memItemLeft" align="right" valign="top">virtual Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#a13b25c8aa3c7cfa1d8841b23ed663345">releaseView</a> ()=0</td></tr>
<tr class="memdesc:a13b25c8aa3c7cfa1d8841b23ed663345"><td class="mdescLeft">&#160;</td><td class="mdescRight">IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event represents graphics context released.  <a href="#a13b25c8aa3c7cfa1d8841b23ed663345">More...</a><br/></td></tr>
<tr class="separator:a13b25c8aa3c7cfa1d8841b23ed663345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04c377cf200a2c68cbc9c7145066f1b"><td class="memItemLeft" align="right" valign="top">virtual Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1platform_1_1_shell.html#ae04c377cf200a2c68cbc9c7145066f1b">renderFrame</a> ()=0</td></tr>
<tr class="memdesc:ae04c377cf200a2c68cbc9c7145066f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event is called every frame. <a href="#ae04c377cf200a2c68cbc9c7145066f1b">More...</a><br/></td></tr>
<tr class="separator:ae04c377cf200a2c68cbc9c7145066f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The PowerVR <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> (pvr::Shell) is the main class that the user will inherit his application from. </p>
<p>This class abstracts the platform for the user and provides a unified interface to it. The user will normally write his application as a class inheriting from the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. This way the user can have specific and easy to use places to write his code - Application start, window initialisation, per frame, cleanup. All platform queries and settings can be done on the shell (set the required Graphics API required, window size etc.). Specific callbacks and queries are provided for system events (keyboard, mouse, touch) as well as a unified simplified input interface provided such abstracted input events as "Left", "Right", "Action1", "Quit" across different platforms.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8823ff36848a13ebad921e9d3b2aedeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::platform::Shell::Shell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. Do not instantiate a <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> class directly - extend as your application and then provide the <a class="el" href="namespacepvr.html#aacdfd9cc3d99a51f4b534c2b75f40920" title="—IMPLEMENT THIS FUNCTION IN YOUR MAIN CODE FILE TO POWER YOUR APPLICATION—">newDemo()</a> function returning your application instance. See bottom of this file.</p>

</div>
</div>
<a class="anchor" id="ad53e03eb253c06ad0977e07f7b53c938"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pvr::platform::Shell::~Shell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a91a970a5e3e4389dfb11d9fbd860c9d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GraphicsContext&amp; pvr::platform::Shell::context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the GraphicsContext utilized by this shell. If operating without a context, it will be empty. </p>
<dl class="section return"><dt>Returns</dt><dd>The GraphicsContext utilized by this shell.</dd></dl>

</div>
</div>
<a class="anchor" id="adcd146a5f05d11ca3146e07b86f83991"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const GraphicsContext&amp; pvr::platform::Shell::context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the GraphicsContext utilized by this shell. If operating without a context, it will be empty. </p>
<dl class="section return"><dt>Returns</dt><dd>The GraphicsContext utilized by this shell.</dd></dl>

</div>
</div>
<a class="anchor" id="ace40c1791026bfb17d90ae9e005f28d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::platform::Shell::eventButtonDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override in your class to handle the initial press (down) of the main input device (mouse, touchscreen). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonIdx</td><td>The index of the button (LMB:0, RMB:1, MMB:2, Touch:0)</td></tr>
  </table>
  </dd>
</dl>
<p>This event will be fired on pressing any button.</p>

</div>
</div>
<a class="anchor" id="af7f59b78bb6d0da1da9339b87b695f1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::platform::Shell::eventButtonUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override in your class to handle the release (up) of the main input device (mouse, touchscreen). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonIdx</td><td>The index of the button (LMB:0, RMB:1, MMB:2, Touch:0)</td></tr>
  </table>
  </dd>
</dl>
<p>This event will be fired on releasing any button.</p>

</div>
</div>
<a class="anchor" id="a8bb36fe97c5f88408421c601fbbe2698"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::platform::Shell::eventClick </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_pointer_location.html">PointerLocation</a>&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override in your class to handle the "Click" or "Touch" event of the main input device (mouse or touchscreen).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonIdx</td><td>The index of the button (LMB:0, RMB:1, MMB:2, Touch:0)</td></tr>
    <tr><td class="paramname">location</td><td>The location of the click.</td></tr>
  </table>
  </dd>
</dl>
<p>This event will be fired on releasing the button, when the mouse pointer has not moved more than a few pixels since the button was pressed (otherwise a drag will register instead of a click).</p>

</div>
</div>
<a class="anchor" id="a216861873786dda96e1cd44a8d49c1d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::platform::Shell::eventDragFinished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_pointer_location.html">PointerLocation</a>&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override in your class to handle the finish of a "Drag" event of the main input device (mouse, touchscreen).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the click.</td></tr>
  </table>
  </dd>
</dl>
<p>This event will be fired on releasing the button, and the mouse pointer has not moved more than a few pixels since the button was pressed.</p>

</div>
</div>
<a class="anchor" id="a3f5d3ccde2d3dae7f799212f2b5be7c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::platform::Shell::eventDragStart </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_pointer_location.html">PointerLocation</a>&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override in your class to handle the start of a "Drag" event of the main input device (mouse, touchscreen).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonIdx</td><td>The index of the button (LMB:0, RMB:1, MMB:2, Touch:0).</td></tr>
    <tr><td class="paramname">location</td><td>The location of the click.</td></tr>
  </table>
  </dd>
</dl>
<p>This event will be fired after a movement of more than a few pixels is detected with a button down. </p>

</div>
</div>
<a class="anchor" id="a35e933adb4460841204b58b36bb79d79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::platform::Shell::eventKeyDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override in your class to handle the press of a key of the keyboard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key pressed</td></tr>
  </table>
  </dd>
</dl>
<p>This event will be fired on pressing any key.</p>

</div>
</div>
<a class="anchor" id="afe4c6f24ff198e9d2b2772cbd00da007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::platform::Shell::eventKeyStroke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override in your class to handle a keystroke of the keyboard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key pressed</td></tr>
  </table>
  </dd>
</dl>
<p>This event will normally be fired multiple times during a key press, as controlled by the key repeat of the operating system.</p>

</div>
</div>
<a class="anchor" id="a7fd1296cb45dffdac831bfff5bd9c730"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::platform::Shell::eventKeyUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override in your class to handle the release (up) of a key of of the keyboard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key released</td></tr>
  </table>
  </dd>
</dl>
<p>This event will be fired once, when releasing a key.</p>

</div>
</div>
<a class="anchor" id="a5e9a69685418d9328fa2415476319f06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pvr::platform::Shell::eventMappedInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a9a6da56806c568a6f9833d118c5c8083">SimplifiedInput</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override in your class to handle a unified interface for input across different platforms and devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The Simplified Unified Event</td></tr>
  </table>
  </dd>
</dl>
<p>This event abstracts, maps and unifies several input devices, in a way with a mind to unify several platforms and input devices. The Left/Right/Up/Down keyboard key, Swipe Left/Right/Up/Down both cause Left/Right/Up/Down events. Left Click at Center, Space key, Enter key, Touch at Center cause Action1. Left Click at Left, Right Click, One Key, Touch at the Left cause Action2. Left Click at Right, Middle Click, Two Key, Touch at the Right cause Action3. Escape, Q key, Back button cause Quit. Default behaviour is Quit action calls exitShell. In order to retain Quit button functionality, this behaviour should be mirrored (exitShell called on ActionClose).</p>

</div>
</div>
<a class="anchor" id="a4167538c72b7eae18d00a73f9f72a753"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::exitShell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signifies the application to clean up and exit. Will go through the normal <a class="el" href="classpvr_1_1platform_1_1_state_machine.html" title="The StateMachine controlling the PowerVR Shell. Provides the application main loop and callbacks...">StateMachine</a> cycle and exit cleanly, exactly like returning ExitRenderFrame from RenderFrame. Will skip the next RenderFrame execution. </p>

</div>
</div>
<a class="anchor" id="ae07b1caa59d76f1e46b4f8061e2ba6c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::forceReinitView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EFFECTIVE IF CALLED DURING RenderFrame. Force the shell to ReleaseView and then InitView again after this frame.</p>

</div>
</div>
<a class="anchor" id="ab2eb1cae4e8d14a89c02bbc1c119a3df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getAASamples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of anti-aliasing samples.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of anti-aliasing samples.</dd></dl>

</div>
</div>
<a class="anchor" id="a3fc1a0807e40d972b546137d91aec6c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Api pvr::platform::Shell::getApiType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT VIEW OR AFTER. Get the actual API version created.</p>
<dl class="section return"><dt>Returns</dt><dd>Return the actual API level of the existing Graphics Context. If called before initView, results are undefined.</dd></dl>

</div>
</div>
<a class="anchor" id="a694831dd042c23a0f558f4edb0f5881f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseApi pvr::platform::Shell::getApiTypeBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the context type/version (if any) that will be/was requested. Before init view, returns the requested base api type (OpenGL ES/ Vulkan). After init application, it returns the Created api type. This only makes sense if the PVRApi library is loaded Dynamically (in which case it controls the PVRApi library that the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> will attempt to load, otherwise the Base api type is fixed to the linked-in library. Default: BaseApi::Unspecified. If unspecified, the application will try Vulkan first, then OpenGL ES, then will set it to whichever one succeeded first.</p>
<dl class="section return"><dt>Returns</dt><dd>The context type that will be requested from PVRApi, OR the context that was created (if it was unspecified.</dd></dl>

</div>
</div>
<a class="anchor" id="af5e445a570eeb47d780682102a63c62f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Api pvr::platform::Shell::getApiTypeRequired </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the context type/version (if any) that will be requested</p>
<dl class="section return"><dt>Returns</dt><dd>The context type that will be requested from PVRApi.</dd></dl>

</div>
</div>
<a class="anchor" id="ae636d636efc52d5975692490186c4bed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; pvr::platform::Shell::getApplicationName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get application name.</p>
<dl class="section return"><dt>Returns</dt><dd>The application name.</dd></dl>

</div>
</div>
<a class="anchor" id="a40ec603b5cbc6f40e8c1dcd7649dd2b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stream::ptr_type pvr::platform::Shell::getAssetStream </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>logFileNotFound</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a Stream object for a specific filename. Uses platform dependent lookup rules to create the stream from the filesystem or a platform-specific store (Windows resources, Android .apk assets) etc. Will first try the filesystem (if available) and then the built-in stores, in order to allow the user to easily override built-in assets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to load. Is usually a raw filename, but may contain a path. </td></tr>
    <tr><td class="paramname">logFileNotFound</td><td>Set this to false if file-not-found are expected and should not be logged as errors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique pointer to the Stream returned if successful, an Empty unique pointer if failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a478955ee7e0d4af18f047e14a4536472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">types::ColorSpace pvr::platform::Shell::getBackBufferColorspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Colorspace of the main window framebuffer (linear RGB or sRGB).</p>
<dl class="section return"><dt>Returns</dt><dd>The Colorspace of the main window framebuffer (linear RGB or sRGB).</dd></dl>

</div>
</div>
<a class="anchor" id="ae9a2ce302d8aa51534fe6726efd2c4ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getCaptureFrameStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If capturing frames, get the first frame to be captured.</p>
<dl class="section return"><dt>Returns</dt><dd>If capturing frames, the first frame to be captured.</dd></dl>

</div>
</div>
<a class="anchor" id="a30e9d72f396bad01589c4aa0f1839bdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getCaptureFrameStop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If capturing frames, get the last frame to be captured.</p>
<dl class="section return"><dt>Returns</dt><dd>If capturing frames, the last frame to be captured.</dd></dl>

</div>
</div>
<a class="anchor" id="a49c77934b5e22e606f9aa4e962ebabec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getColorBitsPerPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Get the total number of color bits per pixel (sum of all channels' bits per pixel)</p>
<p class="enddd">The number of total color bits per pixel.</p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9a9607ec52c4262f8ca2f9f341f1edea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1platform_1_1_command_line_parser_1_1_parsed_command_line.html">platform::CommandLineParser::ParsedCommandLine</a>&amp; pvr::platform::Shell::getCommandLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the command line options that were passed at application launch.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpvr_1_1platform_1_1_command_line_parser_1_1_parsed_command_line.html" title="This class provides access to the command line arguments of a CommandLineParser. Its lifecycle is tie...">pvr::platform::CommandLineParser::ParsedCommandLine</a> object containing all options passed at app launch.</dd></dl>

</div>
</div>
<a class="anchor" id="ad0edfc58e438752960a5172af253326d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getContextPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the requested context priority.0=Low,1=Medium, 2+ = High. Initial value: High.</p>
<dl class="section return"><dt>Returns</dt><dd>If supported, the priority of the main Graphics Context used by the application.</dd></dl>

</div>
</div>
<a class="anchor" id="a34c345be69760b5902cc24740ba22095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; pvr::platform::Shell::getDefaultReadPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default read path.</p>
<dl class="section return"><dt>Returns</dt><dd>The first (default) read path. Normally, current directory.</dd></dl>

</div>
</div>
<a class="anchor" id="a92c58cf0d8f870a438f08849b5ee312d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getDepthBitsPerPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of framebuffer depth bits per pixel.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of depth bits per pixel.</dd></dl>

</div>
</div>
<a class="anchor" id="ae909ba5e257bff6d2008928e54a89ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getDesiredConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If setDesiredConfig was called, get the desired ConfigID.</p>
<dl class="section return"><dt>Returns</dt><dd>If setDesiredConfig was called, the desired ConfigID.</dd></dl>

</div>
</div>
<a class="anchor" id="aa70dde0ad120cda0c7c35c81d0a4c675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DeviceQueueType pvr::platform::Shell::getDeviceQueueTypesRequired </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the DeviceQueueTypes that have been set as required.</p>
<dl class="section return"><dt>Returns</dt><dd>The DeviceQueueTypes that have been set as required.</dd></dl>

</div>
</div>
<a class="anchor" id="ad9e13da25122536b19408761a0a70dad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSDisplay pvr::platform::Shell::getDisplay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the underlying Display object of this shell</p>
<dl class="section return"><dt>Returns</dt><dd>The underlying Display object of this shell</dd></dl>
<p>OSManager interface implementation.</p>

</div>
</div>
<a class="anchor" id="aa7d80f476079f36afb8b8a2f6245a6ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DisplayAttributes&amp; pvr::platform::Shell::getDisplayAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the display attributes (width, height, bpp, AA, etc) of this pvr::Shell</p>
<dl class="section return"><dt>Returns</dt><dd>The display attributes (width, height, bpp, AA, etc) of this pvr::Shell</dd></dl>
<p>OSManager interface implementation.</p>

</div>
</div>
<a class="anchor" id="a0d68ff773c8298caf65664ba57708285"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; pvr::platform::Shell::getExitMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the exit message set by the user.</p>
<dl class="section return"><dt>Returns</dt><dd>The exit message set by the user.</dd></dl>

</div>
</div>
<a class="anchor" id="a0720fc590a4e1b3d6c1e1ebc1389a014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getFakeFrameTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the artificial frame time that has been set. 0 means unset.</p>
<dl class="section return"><dt>Returns</dt><dd>The artificial frame time that has been set. 0 means unset.</dd></dl>

</div>
</div>
<a class="anchor" id="a4c2fbebe378e7b93953dbe2b801f7689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pvr::platform::Shell::getFPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an FPS calculation of the last frame.</p>
<dl class="section return"><dt>Returns</dt><dd>An Frames-Per-Second value calculated periodically by the application.</dd></dl>

</div>
</div>
<a class="anchor" id="a2235132400a63d495f48a1b24ce3daf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 pvr::platform::Shell::getFrameTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The duration of the last frame to pass, in milliseconds. This is the time to use to advance app logic.</p>
<dl class="section return"><dt>Returns</dt><dd>The duration of the last frame, in milliseconds.</dd></dl>

</div>
</div>
<a class="anchor" id="a816cb36e28cff45dfaf925027f386608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GraphicsContext&amp; pvr::platform::Shell::getGraphicsContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the GraphicsContext utilized by this shell. If operating without a context, it will be empty. </p>
<dl class="section return"><dt>Returns</dt><dd>The GraphicsContext utilized by this shell.</dd></dl>

</div>
</div>
<a class="anchor" id="aa9ff7d4bc499f4630dc89075599fe988"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GraphicsContext&amp; pvr::platform::Shell::getGraphicsContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the GraphicsContext utilized by this shell. If operating without a context, it will be empty. </p>
<dl class="section return"><dt>Returns</dt><dd>The GraphicsContext utilized by this shell.</dd></dl>

</div>
</div>
<a class="anchor" id="acdc29050d03645b8cbde647aa658a90e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the height of the application area (window height for windowed, or screen height for full screen).</p>
<dl class="section return"><dt>Returns</dt><dd>The height of the application area.</dd></dl>

</div>
</div>
<a class="anchor" id="a00fac01f919fec264e9535714290c20e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Api pvr::platform::Shell::getMaxApiLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the maximum supported Graphics API type.</p>
<dl class="section return"><dt>Returns</dt><dd>The api type and maximum version that the implementation can provide.</dd></dl>

</div>
</div>
<a class="anchor" id="ac0b81d587a96f6d1fabd02affd65f084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Api pvr::platform::Shell::getMinApiTypeRequired </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the minimum Graphics API type (version) that the user has set. See setMinApiType.</p>
<dl class="section return"><dt>Returns</dt><dd>The api type and version that the user has set as the minimum acceptable.</dd></dl>

</div>
</div>
<a class="anchor" id="a0ba65d5b8de5089e1b802278389564d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1platform_1_1_shell_o_s.html">ShellOS</a>&amp; pvr::platform::Shell::getOS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classpvr_1_1platform_1_1_shell_o_s.html" title="Implements a lot of the functionality and forwards to the platform from PVRShell. Users don&#39;t use dir...">ShellOS</a> object owned by this shell.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classpvr_1_1platform_1_1_shell_o_s.html" title="Implements a lot of the functionality and forwards to the platform from PVRShell. Users don&#39;t use dir...">ShellOS</a> object owned by this shell.</dd></dl>

</div>
</div>
<a class="anchor" id="aae5c86046a025a230c5babba46309a53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IPlatformContext&amp; pvr::platform::Shell::getPlatformContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Platform Context class used by this shell.</p>
<dl class="section return"><dt>Returns</dt><dd>The Platform Context class used by this shell.</dd></dl>

</div>
</div>
<a class="anchor" id="a5de6eb150c1f27a1705b8d6335797ad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IPlatformContext&amp; pvr::platform::Shell::getPlatformContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Platform Context class used by this shell.</p>
<dl class="section return"><dt>Returns</dt><dd>The Platform Context class used by this shell.</dd></dl>

</div>
</div>
<a class="anchor" id="ae3e107d13fc9f17db04ec1897d09e2ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_pointer_location.html">PointerLocation</a> pvr::platform::Shell::getPointerAbsolutePosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the pointer location in pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>The location of the pointer in pixels.</dd></dl>

</div>
</div>
<a class="anchor" id="ae342041abcfdad43330a1dd624840eae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1platform_1_1_shell_1_1_pointer_normalised_location.html">PointerNormalisedLocation</a> pvr::platform::Shell::getPointerNormalisedPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the pointer location in normalised coordinates (0..1).</p>
<dl class="section return"><dt>Returns</dt><dd>The location of the pointer in normalised coordinates (0..1).</dd></dl>

</div>
</div>
<a class="anchor" id="a01b6766dae2979de1b064cef98734bae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1platform_1_1_shell_1_1_pointing_device_state.html">PointingDeviceState</a>&amp; pvr::platform::Shell::getPointingDeviceState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the state of the pointing device (Mouse, Touchscreend).</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structpvr_1_1platform_1_1_shell_1_1_pointing_device_state.html" title="Contains the state of a pointing device (mouse, touch screen).">PointingDeviceState</a> struct containing the state of the pointing device.</dd></dl>

</div>
</div>
<a class="anchor" id="a724c1c7c09db7518019fc04c57208dd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getPositionX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the window position X coordinate.</p>
<dl class="section return"><dt>Returns</dt><dd>The window position X coordinate. (0 for fullscreen)</dd></dl>

</div>
</div>
<a class="anchor" id="ac3d8b553cd0d30994f5c7029cdfe9ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getPositionY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the window position Y coordinate.</p>
<dl class="section return"><dt>Returns</dt><dd>The window position Y coordinate. (0 for fullscreen)</dd></dl>

</div>
</div>
<a class="anchor" id="a3db93c6f84c791ae661566d2fa015b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 pvr::platform::Shell::getQuitAfterFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the frame after which the application is set to automatically quit. If QuitAfterFrame was not set, returns -1</p>
<dl class="section return"><dt>Returns</dt><dd>The frame after which the application is set to quit. If not set, returns -1</dd></dl>

</div>
</div>
<a class="anchor" id="a7494f6cd91116e25a7b98889f0de81fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float32 pvr::platform::Shell::getQuitAfterTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time after which the application is set to automatically quit.If QuitAfterTime was not set, returns -1</p>
<dl class="section return"><dt>Returns</dt><dd>The time after which the application will quit. If not set, returns -1</dd></dl>

</div>
</div>
<a class="anchor" id="ab074d836de9c0d3287d1d06accb4bdd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;string&gt;&amp; pvr::platform::Shell::getReadPaths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of all paths that will be tried when looking for loading files.</p>
<dl class="section return"><dt>Returns</dt><dd>The a list of all the read paths that will successively be tried when looking to read a file. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a422ab4f8017a483551e097e4c0f825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char8* pvr::platform::Shell::getSDKVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current version of the PowerVR SDK.</p>
<dl class="section return"><dt>Returns</dt><dd>The current version of the PowerVR SDK.</dd></dl>

</div>
</div>
<a class="anchor" id="acd79d6cc6d0746d90dd3c479b11e522a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getStencilBitsPerPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of framebuffer stencil bits per pixel.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of stencil bits per pixel.</dd></dl>

</div>
</div>
<a class="anchor" id="a21ee07dbaeb76bc0a9aad320b5088ca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getSwapChainIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the logical framebuffer image that the application currently owns and can render to. OpenGL ES will always return 0 as the backbuffer images imlementation are hidden in the driver and not exposed to the user.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the logical backbuffer image that the application currently owns and should render to. It is undefined behaviour to render to an Off Screen FBO that points to any swap image other than the one whose index is this number.</dd></dl>

</div>
</div>
<a class="anchor" id="a0609031d1148a2e904c367c10bbec915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getSwapChainLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of explicit, logical framebuffer images accessible to user code. OpenGL ES will always return 1 as the buffer swapping is hidden in the driver and images not explicitly handled by the user. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of logical swap chain images. This number is one greater than the max number returned by <a class="el" href="classpvr_1_1platform_1_1_shell.html#a21ee07dbaeb76bc0a9aad320b5088ca7" title="Get the logical framebuffer image that the application currently owns and can render to...">getSwapChainIndex()</a>.</dd></dl>

</div>
</div>
<a class="anchor" id="a081a0fccfeaf4eaaee690743e033a301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 pvr::platform::Shell::getTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total time (from the same arbitrary starting point as getTimeAtInitApplication ), in milliseconds.</p>
<dl class="section return"><dt>Returns</dt><dd>The total time in milliseconds.</dd></dl>

</div>
</div>
<a class="anchor" id="a59d416c1470694d9a971ec3ed18d0810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 pvr::platform::Shell::getTimeAtInitApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total time (from the same arbitrary starting point as getTime ), in milliseconds.</p>
<dl class="section return"><dt>Returns</dt><dd>The time at init application, in milliseconds.</dd></dl>

</div>
</div>
<a class="anchor" id="a128ac0a6346b36e08d133a857ef077e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; pvr::platform::Shell::getTitle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the window title.</p>
<dl class="section return"><dt>Returns</dt><dd>The window title.</dd></dl>

</div>
</div>
<a class="anchor" id="ab0d7168d3151eaff02271fcda7a90dc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VsyncMode pvr::platform::Shell::getVsyncMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the vertical synchronization mode.</p>
<dl class="section return"><dt>Returns</dt><dd>The vertical synchronisation mode.</dd></dl>

</div>
</div>
<a class="anchor" id="ae7d08ea9694db43bca53e713986e4af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::platform::Shell::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the width of the application area (window width for windowed, or screen width for full screen). </p>
<dl class="section return"><dt>Returns</dt><dd>The width of the application area.</dd></dl>

</div>
</div>
<a class="anchor" id="a789f0558bbd23cdafebdb6909aa14480"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSWindow pvr::platform::Shell::getWindow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the underlying Window object of this shell</p>
<dl class="section return"><dt>Returns</dt><dd>The underlying Window object of this shell</dd></dl>
<p>OSManager interface implementation.</p>

</div>
</div>
<a class="anchor" id="a0512b708ed33dd17d56063fa4f9521b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; pvr::platform::Shell::getWritePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the path where any files will be saved.</p>
<dl class="section return"><dt>Returns</dt><dd>The path where any files saved (screenshots, logs) will be output to.</dd></dl>

</div>
</div>
<a class="anchor" id="a46ed6f2ac11d35a4aa2ae0fe1379ac38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result pvr::platform::Shell::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpvr_1_1platform_1_1_shell_data.html">ShellData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called at the appropriate time by the state machine.</p>

</div>
</div>
<a class="anchor" id="a82e68c454485cea2c5af4a2701e3078f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Result pvr::platform::Shell::initApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event represents application start.</p>
<dl class="section return"><dt>Returns</dt><dd>When implementing, return a suitable error code to signify failure. If pvr::Result::Success is not returned , the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> will detect that, clean up, and exit.</dd></dl>
<p>This function must be implemented in the user's application class. It will be fired once, on start, before any other callback and before Graphics Context aquisition. It is suitable to do per-run initialisation, load assets files and similar tasks. A context does not exist yet, hence if the user tries to create API objects, they will fail and the behaviour is undefined.</p>

</div>
</div>
<a class="anchor" id="a490e8314c751dff53ce6b9049bc59f33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Result pvr::platform::Shell::initView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event is called after successful window/context aquisition.</p>
<dl class="section return"><dt>Returns</dt><dd>When implementing, return a suitable error code to signify failure. If pvr::Result::Success is not returned , the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> will detect that, clean up, and exit.</dd></dl>
<p>This function must be implemented in the user's application class. It will be fired once after every time the main Graphics Context (the one the Application Window is using) is initialized. This is usually once per application run, but in some cases (context lost) it may be called more than once. If the context is lost, the <a class="el" href="classpvr_1_1platform_1_1_shell.html#a13b25c8aa3c7cfa1d8841b23ed663345" title="IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event represents graphics context released...">releaseView()</a> callback will be fired, and if it is reaquired this function will be called again. This callback is suitable to do all do-once tasks that require a graphics context, such as creating an On-Screen FBO, and for simple applications creating the graphics objects.</p>

</div>
</div>
<a class="anchor" id="a21b862931b196e1c7edba62b57f54ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::platform::Shell::isApiSupported </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries if a particular Graphics API type/version is supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">api</td><td>The context type queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if api is supported</dd></dl>

</div>
</div>
<a class="anchor" id="af6bd3203017715795be06b4c9899bda2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::platform::Shell::isButtonPressed </td>
          <td>(</td>
          <td class="paramtype">int8&#160;</td>
          <td class="paramname"><em>buttonIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if a key is pressed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonIndex</td><td>The number of the button to check (LMB:0, RMB:1, MMB:2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a mouse/touchscreen exists and the button with this is index pressed. Simple touch is 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a050873597a4aa2219438a3c9847b07b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::platform::Shell::isForcingFrameTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if frame time is forced (forceFrameTime(true) has been called)</p>
<dl class="section return"><dt>Returns</dt><dd>True if forcing frame time.</dd></dl>

</div>
</div>
<a class="anchor" id="a66a6aa614314d7ffc64df613dda69c34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::platform::Shell::isFullScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get if the application is running in full screen.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the application is running in full screen. False otherwise.</dd></dl>

</div>
</div>
<a class="anchor" id="ac2680be831cce7dc6e6c6421e8094761"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::platform::Shell::isKeyPressed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if a key is pressed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a keyboard exists and the key is pressed</dd></dl>

</div>
</div>
<a class="anchor" id="a00fc6afd43168fa94c71444dfe6cc4db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::platform::Shell::isPresentingBackBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return true if present backbuffer is enabled</p>
<dl class="section return"><dt>Returns</dt><dd>true if presenting backbuffer</dd></dl>

</div>
</div>
<a class="anchor" id="a164a3b661154f8805cc85b3ab829546e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::platform::Shell::isScreenRotated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if screen is rotated</p>
<dl class="section return"><dt>Returns</dt><dd>True if screen is Landscape (height &gt; width), false otherwise</dd></dl>

</div>
</div>
<a class="anchor" id="a50991a6cef3c6726737a6242d018df3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::platform::Shell::isShowingFPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if FPS are being printed out.</p>
<dl class="section return"><dt>Returns</dt><dd>True if FPS are being printed out.</dd></dl>

</div>
</div>
<a class="anchor" id="a56e93594310a55610c3b65252726051d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::onKeyDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used externally to signify events to the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. Do not use.</p>

</div>
</div>
<a class="anchor" id="af3cfca84a66074f6bad4ce6d14d60e94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::onKeyUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#af625e736c31479793aa44c254ee30f34">Keys</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used externally to signify events to the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. Do not use.</p>

</div>
</div>
<a class="anchor" id="a6ea9778498ede4935e9efee2c3b1088c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::onPointingDeviceDown </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>buttonIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used externally to signify events to the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. Do not use.</p>

</div>
</div>
<a class="anchor" id="a990408e55fef68e7ef310c283477aa69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::onPointingDeviceUp </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>buttonIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used externally to signify events to the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. Do not use.</p>

</div>
</div>
<a class="anchor" id="a1112fb5c192dcab32438f3a7df87febd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::onSystemEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#ae4c92053860fcd90c8ae00f40354965a">SystemEvent</a>&#160;</td>
          <td class="paramname"><em>systemEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used externally to signify events to the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a>. Do not use.</p>

</div>
</div>
<a class="anchor" id="a83c09cd21a42a07fc26d38d63d4df9b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Result pvr::platform::Shell::quitApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event represents application exit.</p>
<dl class="section return"><dt>Returns</dt><dd>When implementing, return a suitable error code to signify a failure that will be logged.</dd></dl>
<p>This function must be implemented in the user's application class. It will be fired once before the application exits, after the Graphics Context is torn down. The user should use this callback as his main callback to release all objects that need to. The application will exit shortly after this callback is fired. In effect, the user should release all objects that were acquired during initApplication. Do NOT use this to release API objects - these should already have been released during releaseView.</p>

</div>
</div>
<a class="anchor" id="a13b25c8aa3c7cfa1d8841b23ed663345"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Result pvr::platform::Shell::releaseView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event represents graphics context released. </p>
<dl class="section return"><dt>Returns</dt><dd>When implementing, return a suitable error code to signify failure. If pvr::Result::Success is not returned, the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> will detect that, clean up, and exit. If the shell was exiting, this will happen anyway. </dd></dl>
<p>This function must be implemented in the user's application class. It will be fired once before the main Graphics Context is lost. The user should use this callback as his main callback to release all API objects as they will be invalid afterwards. In simple applications where all objects are created in initView, it should release all objects acquired in initView. This callback will be called when the application is exiting, but not only then - losing (and later re-acquiring) the Graphics Context will lead to this callback being fired, followed by an initView callback, renderFrame etc.</p>

</div>
</div>
<a class="anchor" id="ae04c377cf200a2c68cbc9c7145066f1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Result pvr::platform::Shell::renderFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IMPLEMENT THIS FUNCTION IN YOUR APPLICATION CLASS. This event is called every frame.</p>
<dl class="section return"><dt>Returns</dt><dd>When implementing, return a suitable error code to signify failure. Return pvr::Success to signify success and allow the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> to do all actions necessary to render the frame (swap buffers etc.). If pvr::Result::Success is not returned, the <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> will detect that, clean up, and exit. Return pvr::Result::ExitRenderFrame to signify a clean, non-error exit for the application. Any other error code will be logged.</dd></dl>
<p>This function must be implemented in the user's application class. It will be fired once every frame. The user should use this callback as his main callback to start rendering and per-frame code. This callback is suitable to do all per-frame task. In multithreaded environments, it should be used to mark the start and signal the end of frames.</p>

</div>
</div>
<a class="anchor" id="a2868959c03e02eaf3e764e8f0f04fd8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setAASamples </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the Anti-Aliasing samples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The anti-aliasing samples.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae88eb9ffb5cb1fff4031b3cfcee0c71e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setApiTypeBase </td>
          <td>(</td>
          <td class="paramtype">BaseApi&#160;</td>
          <td class="paramname"><em>contextType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. ONLY EFFECTIVE IF PVRAPI IS LINKED DYNAMICALLY. If PVRApi is linked statically, this option is ignored. Sets a specific Graphics API type (version) that the user wants to use. The context creation will fail if this precise version cannot be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contextType</td><td>The context type requested.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a229647b00e9c5f3639058c8e86deb8cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setApiTypeRequired </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>contextType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Sets a specific Graphics API type (version) that the user wants to use. The context creation will fail if this precise version cannot be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contextType</td><td>The context type requested.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af31570f56ac74ab80f0f46c14d35aa6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setApplicationName </td>
          <td>(</td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the application name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A printf-style format string</td></tr>
    <tr><td class="paramname">...</td><td>Printf-style variable parameters</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f01b0f1eac635f4f45ef13f2909c025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setBackBufferColorspace </td>
          <td>(</td>
          <td class="paramtype">types::ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Specify the colorspace of the backbuffer. Default is a (linear) RGB BackBuffer. Use this to specifically request an sRGB backbuffer. Since the support of backbuffer colorspace is an extension in many implementations, if you use this function, you must call getBackBufferColorspace after initApplication (in initView) to determine the actual backBuffer colorspace that was obtained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorSpace</td><td>the desired framebuffer colorspace (either lRgb or sRgb)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ab7a79cad01b237a855fd2f03cfb6f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setCaptureFrames </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Captures the frames between start and stop and saves them as TGA screenshots.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>First frame to be captured</td></tr>
    <tr><td class="paramname">stop</td><td>Last frame to be captured</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf803489d44cea8511e321c28d38697f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setCaptureFrameScale </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Sets the upscale factor of the screenshots. Upscaling only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Upscaling of the screenshots</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aceb0243cc20d520a20aa43ca0acbc301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setColorBitsPerPixel </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the number of framebuffer color bits per pixel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The Red framebuffer channel color bits</td></tr>
    <tr><td class="paramname">g</td><td>The Green framebuffer channel color bits</td></tr>
    <tr><td class="paramname">b</td><td>The Blue framebuffer channel color bits</td></tr>
    <tr><td class="paramname">a</td><td>The Alpha framebuffer channel color bits</td></tr>
  </table>
  </dd>
</dl>
<p>Actual number obtained may vary per implementation. Query with getColorBitsPerPixel after initView to check the actual number obtained</p>

</div>
</div>
<a class="anchor" id="acdd65557708c43017b4fc1cb5638ab17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setContextPriority </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. If supported, sets a ContextPriority that the shell will attempt to use when creating the main Graphics Context used for the window. Initial value:High.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The context priority requested. 0=Low, 1=Medium, 2+=High.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4b439ac057b94f0b7587f3f1081e1bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setDepthBitsPerPixel </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the number of framebuffer Depth bits per pixel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The desired framebuffer Depth channel bits.</td></tr>
  </table>
  </dd>
</dl>
<p>Actual number obtained may vary per implementation. Query with getDepthBitsPerPixel after initView to check the actual number obtained</p>

</div>
</div>
<a class="anchor" id="ac4163f6fc79b97c88881a233976f13f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setDesiredConfig </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. If supported by the platform/API, sets a specific Context Configuration ID to be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The ConfigID that will be requested.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf2d2de897ff9daf9ea483b26c7cfb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setDeviceQueueTypesRequired </td>
          <td>(</td>
          <td class="paramtype">DeviceQueueType&#160;</td>
          <td class="paramname"><em>queueType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Sets the Device Queue types that the user may require (Graphics, Compute etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueType</td><td>The DeviceQueueType requested.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad36f9674a9ea0fe20cc66535eb582d4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result pvr::platform::Shell::setDimensions </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the window size, or resolution for fullscreen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The width of the window / horizontal resolution</td></tr>
    <tr><td class="paramname">h</td><td>The height of the window / vertical resolution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pvr::Result::Success if successful. pvr::Result::UnsupportedRequest if unsuccessful.</dd></dl>

</div>
</div>
<a class="anchor" id="a7c36585df3265610554f3ea256dd229b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setExitMessage </td>
          <td>(</td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a message to be displayed on application exit. Normally used to display critical error messages that might be missed if displayed as just logs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A printf-style format string</td></tr>
    <tr><td class="paramname">...</td><td>Printf-style variable arguments</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0611a541599bae56123d09e0914f226b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setFakeFrameTime </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a time delta that will be used as frame time to increment the application clock instead of real time. This number will be returned as the frame time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The number of milliseconds of the frame.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a221f2df91b95f2c4c84367a4d2fe3c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setForceFrameTime </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Forces frame time to always be reported as 1/60th of a second.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>True to force frame time, false to use real frame time.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae61ef050b4e5dfd2df56c8a0c0380f0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setFullscreen </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fullscreen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE AT INIT APPLICATION. Set the application to run at full screen mode. Not all platforms support this option.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullscreen</td><td>Set to true for fullscreen, false for windowed</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8eaa16cd2639b2fb56b600585cd17739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setMinApiType </td>
          <td>(</td>
          <td class="paramtype">Api&#160;</td>
          <td class="paramname"><em>contextType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Sets the minimum Graphics API type (version) that the user intends to use. The context creation will fail if at least this context version cannot be created. The latest context version supported will be created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contextType</td><td>The context type requested.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40084cf10bdf42631325db22c783ea19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result pvr::platform::Shell::setPosition </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the window position. Not supported in all platforms. </p>
<dl class="section return"><dt>Returns</dt><dd>pvr::Result::Success if successful. pvr::Result::UnsupportedRequest if unsuccessful.</dd></dl>

</div>
</div>
<a class="anchor" id="aa2031ba1c70cd2abb75ecb86ac0d1a58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setPreferredSwapChainLength </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapChainLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set a desired number of swap images (number of framebuffers). This number will be clamped between the minimum and the maximum number supported by the platform, so that if a small (0-1) or large (8+) number is requested, the minimum/maximum of the platform will always be providedd</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapChainLength</td><td>The desired number of swap images. Default is 3 for Mailbox, 2 for On.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34dea5800df044453c6502655f849273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setPresentBackBuffer </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enable or disable presenting back-buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Set to true to present, false to disable actual backbuffer swapping/presentation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae40f368623a6f17aa04c19ca1530edfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setQuitAfterFrame </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set a frame after which the application will quit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The frame after which the application is set to quit. Set to -1 to disable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c7352c53f8a783bd17ce391d66317ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setQuitAfterTime </td>
          <td>(</td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set a time after which the application will quit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The time (seconds) after which the application will quit. Set to -1 to disable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8304aca84d29e9d2b73de294c5d2141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setShowFPS </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showFPS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets if the Frames Per Second are to be output periodically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">showFPS</td><td>Set to true to output fps, false otherwise.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb3a79e4e710049c7ace742a9e52736b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setStencilBitsPerPixel </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the number of Stencil bits per pixel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The Stencil channel bits.</td></tr>
  </table>
  </dd>
</dl>
<p>Actual number obtained may vary per implementation. Query with getStencilBitsPerPixel after initView to check the actual number obtained</p>

</div>
</div>
<a class="anchor" id="afc070e78f1606c30fa52c3eda612f115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setTitle </td>
          <td>(</td>
          <td class="paramtype">const char8 *const&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the window title. Will only be actually displayed If used on or before initApplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A printf-style format string</td></tr>
    <tr><td class="paramname">...</td><td>Printf-style variable parameters</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac463c721743516e42c0df1df1b2a9a4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::setVsyncMode </td>
          <td>(</td>
          <td class="paramtype">VsyncMode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ONLY EFFECTIVE IF CALLED AT INIT APPLICATION. Set the Vertical Syncchronization mode(vertical sync). Default is On(Fifo).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The Vertical Synchronization mode. </td></tr>
  </table>
  </dd>
</dl>
<p>On : VerticalSync (no tearing, some possible input lag</p>
<p>Off : no synchronization. Little lag, bad tearing.</p>
<p>Mailbox: If supported, what was commonly known as triple-buffering - the app uses the latest full image. Little lag, no tearing.</p>
<p>Relaxed: If supported, the presentation engine will only synchronize if framerate is greater than refresh. Some lag, minimal tearing.</p>
<p>Half The application will present once per two refresh intervals (usually to preserve power). Much lag, no tearing.</p>

</div>
</div>
<a class="anchor" id="a30bb9e4fe157fd5752bae827ab1f2b29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::showOutputInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out general information about this <a class="el" href="classpvr_1_1platform_1_1_shell.html" title="The PowerVR Shell (pvr::Shell) is the main class that the user will inherit his application from...">Shell</a> (application name, sdk version, cmd line etc.</p>

</div>
</div>
<a class="anchor" id="a621f7f15872e3573d2f005e010227658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::platform::Shell::takeScreenshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a screenshot of the current display.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVRShell/<a class="el" href="_shell_8h_source.html">Shell.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
