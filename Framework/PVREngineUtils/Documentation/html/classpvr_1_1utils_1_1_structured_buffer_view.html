<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVREngineUtils: pvr::utils::StructuredBufferView Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVREngineUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html">StructuredBufferView</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1utils_1_1_structured_buffer_view-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils::StructuredBufferView Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A structured buffer view is a class that can be used to define an explicit structure to an object that is usually accessed as raw memory. For example, a GPU-side buffer is mapped to a void pointer, but a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a> can be used to create a runtime structure for it, and set its entries one by one. Normal use: a) Create a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a>. b) Populate it using the function addEntryPacked(...) which adds information about the variables that will be used c) When done, call setUpArray or setUpDynamic if it is possible to use this for DynamicUniform, DynamicStorage, or any other case where the entries only represent an array member and the buffer is an array of them. d) Create or Connect to a buffer d1) Create a buffer using createConnectedBuffer(...) OR d2) Create a buffer using createBufferAsTemplate(...) and use connectWithBuffer(...) OR d3) Create a buffer externally and to connect it with connectWithBuffer(...) OR e) Map the connected buffer or, if you are not using a buffer, point to the memory you wish to set e1) Map with map(...), mapArrayIndex(...) or mapMultipleArrayIndices(...) OR e2) Use pointToMemory(...), to set a custom pointer as the destination of your set... operations f) Set any values you wish to set using the methods: setValue(...), setArrayValue(...). The value you provide will be transformed if necessary (adding necessary paddings etc. if such are required), and copied onto the designaded point in the buffer g) Unmap the connected buffer. 
 <a href="classpvr_1_1utils_1_1_structured_buffer_view.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72590090482e9b08dce38672b4b4756a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a72590090482e9b08dce38672b4b4756a">StructuredBufferView</a> ()</td></tr>
<tr class="memdesc:a72590090482e9b08dce38672b4b4756a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor. Creates an empty <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a>. <a href="#a72590090482e9b08dce38672b4b4756a">More...</a><br/></td></tr>
<tr class="separator:a72590090482e9b08dce38672b4b4756a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff6421d697e929a0c6ae66b45c84873"><td class="memTemplParams" colspan="2">template&lt;types::GpuDatatypes::Standard _standard_ = types::GpuDatatypes::Standard::std140&gt; </td></tr>
<tr class="memitem:afff6421d697e929a0c6ae66b45c84873"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#afff6421d697e929a0c6ae66b45c84873">addEntriesPacked</a> (const std::pair&lt; StringHash, types::GpuDatatypes::Enum &gt; *const entries, pvr::uint32 numEntries)</td></tr>
<tr class="memdesc:afff6421d697e929a0c6ae66b45c84873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add multiple entries to the end of the list, in order, each packed on the minimum valid offset that the specified packing standard allows. <a href="#afff6421d697e929a0c6ae66b45c84873">More...</a><br/></td></tr>
<tr class="separator:afff6421d697e929a0c6ae66b45c84873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1f4f9d4fa99051d61fc680340b95a6"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a2c1f4f9d4fa99051d61fc680340b95a6">addEntryAtOffset</a> (const StringHash &amp;name, types::GpuDatatypes::Enum type, uint32 offset, uint32 arrayElements=1)</td></tr>
<tr class="memdesc:a2c1f4f9d4fa99051d61fc680340b95a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a variable entry to the specified byte offset of the buffer. Order is implicit based on the offset. <a href="#a2c1f4f9d4fa99051d61fc680340b95a6">More...</a><br/></td></tr>
<tr class="separator:a2c1f4f9d4fa99051d61fc680340b95a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d84adbb33049a165ad4139f59cc776"><td class="memTemplParams" colspan="2">template&lt;types::GpuDatatypes::Standard _standard_ = types::GpuDatatypes::Standard::std140&gt; </td></tr>
<tr class="memitem:a98d84adbb33049a165ad4139f59cc776"><td class="memTemplItemLeft" align="right" valign="top">uint32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a98d84adbb33049a165ad4139f59cc776">addEntryPacked</a> (const StringHash &amp;name, types::GpuDatatypes::Enum type, uint32 arrayElements=1)</td></tr>
<tr class="memdesc:a98d84adbb33049a165ad4139f59cc776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an entry to the end of the list, packed on the minimum valid offset that the specified packing standard allows. <a href="#a98d84adbb33049a165ad4139f59cc776">More...</a><br/></td></tr>
<tr class="separator:a98d84adbb33049a165ad4139f59cc776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8943b677ab04c5e7de6768bb206afcab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a8943b677ab04c5e7de6768bb206afcab">connectWithBuffer</a> (uint32 swapIdx, const api::BufferView &amp;buffer, types::MapBufferFlags mapDefaultFlags=types::MapBufferFlags::Write, uint32 mapDefaultOffset=0)</td></tr>
<tr class="memdesc:a8943b677ab04c5e7de6768bb206afcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect a buffer to this object, so that the methods map... setValue... unMap... be called directly. The buffer must be mappable and (obviously) be large enough to contain the data written. Using this function and calling map/set/unmap would be similar to calling pointToMemory(buffer-&gt;map), setValue, buffer-&gt;unmap, pointToMemory(null). Swap indexes can be set separately to facilitate multibuffering setups. <a href="#a8943b677ab04c5e7de6768bb206afcab">More...</a><br/></td></tr>
<tr class="separator:a8943b677ab04c5e7de6768bb206afcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a79572349b830d0f249d9e2f4543d9"><td class="memItemLeft" align="right" valign="top">api::BufferView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#ad1a79572349b830d0f249d9e2f4543d9">createBufferAsTemplate</a> (GraphicsContext &amp;ctx, bool mappable=true)</td></tr>
<tr class="memdesc:ad1a79572349b830d0f249d9e2f4543d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using this object as a template, create a buffer suitable for exactly holding the information represented by this object. <a href="#ad1a79572349b830d0f249d9e2f4543d9">More...</a><br/></td></tr>
<tr class="separator:ad1a79572349b830d0f249d9e2f4543d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f62d46c54525339691b001183025ed"><td class="memItemLeft" align="right" valign="top">api::BufferView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#af8f62d46c54525339691b001183025ed">createBufferAsTemplate</a> (GraphicsContext &amp;ctx, types::BufferBindingUse bufferAllowedUses, bool mappable=true)</td></tr>
<tr class="memdesc:af8f62d46c54525339691b001183025ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using this object as a template, create a buffer suitable for exactly holding the information represented by this object. <a href="#af8f62d46c54525339691b001183025ed">More...</a><br/></td></tr>
<tr class="separator:af8f62d46c54525339691b001183025ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1994b1320175a2087aa387c0bcb7ed79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a1994b1320175a2087aa387c0bcb7ed79">createConnectedBuffer</a> (uint32 swapIdx, GraphicsContext &amp;ctx, types::MapBufferFlags mapDefaultFlags=types::MapBufferFlags::Write)</td></tr>
<tr class="memdesc:a1994b1320175a2087aa387c0bcb7ed79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the structure of this object as a template, create a buffer suitable for its contents. The buffer will be created with exactly the correct size and with the flags passed. It is in all respects the same as calling createBufferAsTemplate and then connectWithBuffer. <a href="#a1994b1320175a2087aa387c0bcb7ed79">More...</a><br/></td></tr>
<tr class="separator:a1994b1320175a2087aa387c0bcb7ed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfac282dde8fa696b32b4369e14fb6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a0cfac282dde8fa696b32b4369e14fb6a">createConnectedBuffer</a> (uint32 swapIdx, GraphicsContext &amp;ctx, types::BufferBindingUse bufferAllowedUses, types::MapBufferFlags mapDefaultFlags=types::MapBufferFlags::Write)</td></tr>
<tr class="memdesc:a0cfac282dde8fa696b32b4369e14fb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the structure of this object as a template, create a buffer suitable for its contents. The buffer will be created with exactly the correct size and with the flags passed. It is in all respects the same as calling createBufferAsTemplate and then connectWithBuffer. <a href="#a0cfac282dde8fa696b32b4369e14fb6a">More...</a><br/></td></tr>
<tr class="separator:a0cfac282dde8fa696b32b4369e14fb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d7d484c504388d8bbf6fde1b1fe900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a95d7d484c504388d8bbf6fde1b1fe900">createConnectedBuffers</a> (uint32 numberOfSwapIdxs, GraphicsContext &amp;ctx, types::MapBufferFlags mapDefaultFlags=types::MapBufferFlags::Write)</td></tr>
<tr class="memdesc:a95d7d484c504388d8bbf6fde1b1fe900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the structure of this object as a template, create a set of buffers suitable for its contents. The buffer will be created with exactly the correct size and with the flags passed. Same as calling createConnectedBuffers once for each number from zero to numberOfSwapIdxs-1 <a href="#a95d7d484c504388d8bbf6fde1b1fe900">More...</a><br/></td></tr>
<tr class="separator:a95d7d484c504388d8bbf6fde1b1fe900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8bb23c7be7bc35fe6a1677d49aaaf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#abd8bb23c7be7bc35fe6a1677d49aaaf6">createConnectedBuffers</a> (uint32 numberOfSwapIdxs, GraphicsContext &amp;ctx, types::BufferBindingUse bufferAllowedUses, types::MapBufferFlags mapDefaultFlags=types::MapBufferFlags::Write)</td></tr>
<tr class="memdesc:abd8bb23c7be7bc35fe6a1677d49aaaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the structure of this object as a template, create a set of buffers suitable for its contents. The buffer will be created with exactly the correct size and with the flags passed. Same as calling createConnectedBuffers once for each number from zero to numberOfSwapIdxs-1 <a href="#abd8bb23c7be7bc35fe6a1677d49aaaf6">More...</a><br/></td></tr>
<tr class="separator:abd8bb23c7be7bc35fe6a1677d49aaaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc90e44c849c6d8478d399e8381bc40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a3fc90e44c849c6d8478d399e8381bc40">finalize</a> (const GraphicsContext &amp;context, uint32 elementCount, types::BufferBindingUse bufferAllowedUses, bool allowedUboDynamic=false, bool allowedSsboDynamic=false)</td></tr>
<tr class="memdesc:a3fc90e44c849c6d8478d399e8381bc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function in order to set this object up properly to represent an array of elements, i.e. the information that has been added represents only an array member or dynamic slice of the buffer and not its entire contents. This function must be called for dynamic uniform/storage buffers before calling any of the createConnectedBuffer and similar functions as it affects the total size AND alignment of items. <a href="#a3fc90e44c849c6d8478d399e8381bc40">More...</a><br/></td></tr>
<tr class="separator:a3fc90e44c849c6d8478d399e8381bc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea7c4481bf9ea2993b88638d13c5dfb"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#abea7c4481bf9ea2993b88638d13c5dfb">getAlignedElementArrayOffset</a> (uint32 index) const </td></tr>
<tr class="memdesc:abea7c4481bf9ea2993b88638d13c5dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the offset of an element (a dynamic "slice" or array element) of the buffer. Same as <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#ac3211e154516559bf4253cedb5fd7c9f" title="Get the aligned size of an single element. &quot;Aligned&quot; here means the space that each element of this b...">getAlignedElementSize()</a> * index. <a href="#abea7c4481bf9ea2993b88638d13c5dfb">More...</a><br/></td></tr>
<tr class="separator:abea7c4481bf9ea2993b88638d13c5dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3211e154516559bf4253cedb5fd7c9f"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#ac3211e154516559bf4253cedb5fd7c9f">getAlignedElementSize</a> () const </td></tr>
<tr class="memdesc:ac3211e154516559bf4253cedb5fd7c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the aligned size of an single element. "Aligned" here means the space that each element of this buffer would take if it was a member of an array or dynamic buffer. If the buffer is not dynamic or an array, it is the same as the unaligned size. If the buffer is dynamic, it is the unaligned size rounded up to an integer multiple of the minimum alignment for a dynamic buffer of the correct type the platform allows.  <a href="#ac3211e154516559bf4253cedb5fd7c9f">More...</a><br/></td></tr>
<tr class="separator:ac3211e154516559bf4253cedb5fd7c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93aad09db99e4e54536e155116be6c88"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a93aad09db99e4e54536e155116be6c88">getAlignedTotalSize</a> () const </td></tr>
<tr class="memdesc:a93aad09db99e4e54536e155116be6c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the buffer, padded for alignement. <a href="#a93aad09db99e4e54536e155116be6c88">More...</a><br/></td></tr>
<tr class="separator:a93aad09db99e4e54536e155116be6c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4248f296357eda1d026f7a9952d54e"><td class="memItemLeft" align="right" valign="top">api::BufferView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a7c4248f296357eda1d026f7a9952d54e">getConnectedBuffer</a> (uint32 swapIdx) const </td></tr>
<tr class="memdesc:a7c4248f296357eda1d026f7a9952d54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the connected buffer for the specified swap index. <a href="#a7c4248f296357eda1d026f7a9952d54e">More...</a><br/></td></tr>
<tr class="separator:a7c4248f296357eda1d026f7a9952d54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba1fbd6b8e7286d1006cd3f2813a5e4"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#aeba1fbd6b8e7286d1006cd3f2813a5e4">getDynamicOffset</a> (const StringHash &amp;variableName, uint32 dynamicIndex, uint32 entryArrayIndex=0) const </td></tr>
<tr class="memdesc:aeba1fbd6b8e7286d1006cd3f2813a5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a dynamic buffer or an array of structs buffer, get the byte offset from the start of the buffer, of the specified variable by name, for a specified dynamic or array 'slice' of the buffer <a href="#aeba1fbd6b8e7286d1006cd3f2813a5e4">More...</a><br/></td></tr>
<tr class="separator:aeba1fbd6b8e7286d1006cd3f2813a5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cea9f58b393a6a8716a0910cb9228cb"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a0cea9f58b393a6a8716a0910cb9228cb">getDynamicOffset</a> (uint32 variableIndex, uint32 dynamicIndex, uint32 entryArrayIndex=0) const </td></tr>
<tr class="memdesc:a0cea9f58b393a6a8716a0910cb9228cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a dynamic buffer or an array of structs buffer, get the byte offset from the start of the buffer, of the specified variable by entry index, for a specified dynamic or array 'slice' of the buffer <a href="#a0cea9f58b393a6a8716a0910cb9228cb">More...</a><br/></td></tr>
<tr class="separator:a0cea9f58b393a6a8716a0910cb9228cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9b79e866befe84eb04e16a6eb21d75"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a4d9b79e866befe84eb04e16a6eb21d75">getElementCount</a> () const </td></tr>
<tr class="memdesc:a4d9b79e866befe84eb04e16a6eb21d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of array or dynamic buffer elements <a href="#a4d9b79e866befe84eb04e16a6eb21d75">More...</a><br/></td></tr>
<tr class="separator:a4d9b79e866befe84eb04e16a6eb21d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c876f548186b035f0882e86c853b4c7"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a7c876f548186b035f0882e86c853b4c7">getIndex</a> (const StringHash &amp;name) const </td></tr>
<tr class="memdesc:a7c876f548186b035f0882e86c853b4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the index of a variable entry by its name <a href="#a7c876f548186b035f0882e86c853b4c7">More...</a><br/></td></tr>
<tr class="separator:a7c876f548186b035f0882e86c853b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab54b1da0a040041b9ffb95320a95aab"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#aab54b1da0a040041b9ffb95320a95aab">getMemoryPointer</a> ()</td></tr>
<tr class="memdesc:aab54b1da0a040041b9ffb95320a95aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to which any setValue...(...) operation called will be writing to. Normally set when performing the map...(...) operations, or directly by the user with pointToMemory(...) <a href="#aab54b1da0a040041b9ffb95320a95aab">More...</a><br/></td></tr>
<tr class="separator:aab54b1da0a040041b9ffb95320a95aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3571efe0221afe7c1b34584bbfc37f4f"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a3571efe0221afe7c1b34584bbfc37f4f">getMemoryPointer</a> () const </td></tr>
<tr class="memdesc:a3571efe0221afe7c1b34584bbfc37f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to which any setValue...(...) operation called will be writing to. Normally set when performing the map...(...) operations, or directly by the user with pointToMemory(...) <a href="#a3571efe0221afe7c1b34584bbfc37f4f">More...</a><br/></td></tr>
<tr class="separator:a3571efe0221afe7c1b34584bbfc37f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf966c08e1e94a3059c23564a577034"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a9cf966c08e1e94a3059c23564a577034">getMultibufferCount</a> ()</td></tr>
<tr class="memdesc:a9cf966c08e1e94a3059c23564a577034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of connected buffers. <a href="#a9cf966c08e1e94a3059c23564a577034">More...</a><br/></td></tr>
<tr class="separator:a9cf966c08e1e94a3059c23564a577034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da195bb183b7df2cb6db72e287b7f6"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#af1da195bb183b7df2cb6db72e287b7f6">getOffset</a> (const StringHash &amp;name, uint32 entryArrayIndex=0) const </td></tr>
<tr class="memdesc:af1da195bb183b7df2cb6db72e287b7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte offset of the specified variable by name <a href="#af1da195bb183b7df2cb6db72e287b7f6">More...</a><br/></td></tr>
<tr class="separator:af1da195bb183b7df2cb6db72e287b7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f87d9a136bf85335cc9140f2baa83b"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a26f87d9a136bf85335cc9140f2baa83b">getOffset</a> (uint32 variableIndex, uint32 entryArrayIndex=0) const </td></tr>
<tr class="memdesc:a26f87d9a136bf85335cc9140f2baa83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte offset of the specified variable by entry index <a href="#a26f87d9a136bf85335cc9140f2baa83b">More...</a><br/></td></tr>
<tr class="separator:a26f87d9a136bf85335cc9140f2baa83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae813fb480f1f4e5ed693f3a5ec09fe4c"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#ae813fb480f1f4e5ed693f3a5ec09fe4c">getUnalignedElementSize</a> () const </td></tr>
<tr class="memdesc:ae813fb480f1f4e5ed693f3a5ec09fe4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (unaligned) size of an single element. "Element" here means an entire definition of the buffer, but if the buffer is a Dynamic buffer or an array of structures, it contains multiple "slices" of that definition. Otherwise, the element size is the size of the entire buffer. <a href="#ae813fb480f1f4e5ed693f3a5ec09fe4c">More...</a><br/></td></tr>
<tr class="separator:ae813fb480f1f4e5ed693f3a5ec09fe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf37e669f0ac851df24b242821b7c9e5"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; StructuredMemoryTableEntry &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#aaf37e669f0ac851df24b242821b7c9e5">getVariableList</a> () const </td></tr>
<tr class="memdesc:aaf37e669f0ac851df24b242821b7c9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full variable entry list in raw format. Const overload. <a href="#aaf37e669f0ac851df24b242821b7c9e5">More...</a><br/></td></tr>
<tr class="separator:aaf37e669f0ac851df24b242821b7c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d080cf787a9e0fdad78e5e35bfd463b"><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; StructuredMemoryTableEntry &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a2d080cf787a9e0fdad78e5e35bfd463b">getVariableList</a> ()</td></tr>
<tr class="memdesc:a2d080cf787a9e0fdad78e5e35bfd463b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full variable entry list in raw format. Non-const overload. <a href="#a2d080cf787a9e0fdad78e5e35bfd463b">More...</a><br/></td></tr>
<tr class="separator:a2d080cf787a9e0fdad78e5e35bfd463b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2214fe4b869b7717b35710b988b6cea3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a2214fe4b869b7717b35710b988b6cea3">isFinalized</a> () const </td></tr>
<tr class="memdesc:a2214fe4b869b7717b35710b988b6cea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the structured memory view has been finalized. <a href="#a2214fe4b869b7717b35710b988b6cea3">More...</a><br/></td></tr>
<tr class="separator:a2214fe4b869b7717b35710b988b6cea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbd2a5b4d95c7c10c75d346fe4a10aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a0bbd2a5b4d95c7c10c75d346fe4a10aa">isMapped</a> (uint32 swapIdx)</td></tr>
<tr class="memdesc:a0bbd2a5b4d95c7c10c75d346fe4a10aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is already mapped for a given swapchain index. <a href="#a0bbd2a5b4d95c7c10c75d346fe4a10aa">More...</a><br/></td></tr>
<tr class="separator:a0bbd2a5b4d95c7c10c75d346fe4a10aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838a2001625761e79678cece0342b1f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a838a2001625761e79678cece0342b1f2">isMultiBuffered</a> ()</td></tr>
<tr class="memdesc:a838a2001625761e79678cece0342b1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the connected buffer is a multibuffered object. <a href="#a838a2001625761e79678cece0342b1f2">More...</a><br/></td></tr>
<tr class="separator:a838a2001625761e79678cece0342b1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335fe2834c3c3b5cde440d81f42dd52d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a335fe2834c3c3b5cde440d81f42dd52d">map</a> (uint32 swapIdx, types::MapBufferFlags flags=types::MapBufferFlags::Write, uint32 offset=0xFFFFFFFFu)</td></tr>
<tr class="memdesc:a335fe2834c3c3b5cde440d81f42dd52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the buffer connected to the specified swap index. After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer. Maps the entire buffer. <a href="#a335fe2834c3c3b5cde440d81f42dd52d">More...</a><br/></td></tr>
<tr class="separator:a335fe2834c3c3b5cde440d81f42dd52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ceb2251117e56edf83da1c58760f32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#af3ceb2251117e56edf83da1c58760f32">mapArrayIndex</a> (uint32 swapIdx, uint32 arrayIndex=0, types::MapBufferFlags flags=types::MapBufferFlags::Write)</td></tr>
<tr class="memdesc:af3ceb2251117e56edf83da1c58760f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map multiple a single array/dynamic element of the buffer connected to the specified swap index. Identical as calling mapMultipleArrayElements(index, 1,...) After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer for this swap index. <a href="#af3ceb2251117e56edf83da1c58760f32">More...</a><br/></td></tr>
<tr class="separator:af3ceb2251117e56edf83da1c58760f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99c3b6f92ba47ebe982f006d4b351b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#af99c3b6f92ba47ebe982f006d4b351b6">mapMultipleArrayElements</a> (uint32 swapIdx, uint32 arrayStartIndex, uint32 numElementsToMap, types::MapBufferFlags flags=types::MapBufferFlags::Write, uint32 offset=0xFFFFFFFFu)</td></tr>
<tr class="memdesc:af99c3b6f92ba47ebe982f006d4b351b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map multiple consecutive array/dynamic elements of the buffer connected to the specified swap index. After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer for that swap index. <a href="#af99c3b6f92ba47ebe982f006d4b351b6">More...</a><br/></td></tr>
<tr class="separator:af99c3b6f92ba47ebe982f006d4b351b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556d1602aba1f17b1807dfaa34f43790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a556d1602aba1f17b1807dfaa34f43790">pointToMemory</a> (void *memoryToPointTo)</td></tr>
<tr class="memdesc:a556d1602aba1f17b1807dfaa34f43790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instead of connecting this object to an actual buffer, directly provide a pointer to some kind of memory. This memory will be used when the setValue(...), setArrayValue(...) methods are called <a href="#a556d1602aba1f17b1807dfaa34f43790">More...</a><br/></td></tr>
<tr class="separator:a556d1602aba1f17b1807dfaa34f43790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace48180ff8c81e7732ddcd4b0ba3a40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#ace48180ff8c81e7732ddcd4b0ba3a40d">setMultibufferCount</a> (uint32 size)</td></tr>
<tr class="memdesc:ace48180ff8c81e7732ddcd4b0ba3a40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the connected buffers as a multibuffered object <a href="#ace48180ff8c81e7732ddcd4b0ba3a40d">More...</a><br/></td></tr>
<tr class="separator:ace48180ff8c81e7732ddcd4b0ba3a40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bd065d79395966255e04be38168e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#aa9bd065d79395966255e04be38168e04">unmap</a> (uint32 swapIdx)</td></tr>
<tr class="memdesc:aa9bd065d79395966255e04be38168e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap the mapped buffer at a specified swap index. After calling this function, calling setValue() is no longer valid for that swap index. <a href="#aa9bd065d79395966255e04be38168e04">More...</a><br/></td></tr>
<tr class="separator:aa9bd065d79395966255e04be38168e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A structured buffer view is a class that can be used to define an explicit structure to an object that is usually accessed as raw memory. For example, a GPU-side buffer is mapped to a void pointer, but a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a> can be used to create a runtime structure for it, and set its entries one by one. Normal use: a) Create a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a>. b) Populate it using the function addEntryPacked(...) which adds information about the variables that will be used c) When done, call setUpArray or setUpDynamic if it is possible to use this for DynamicUniform, DynamicStorage, or any other case where the entries only represent an array member and the buffer is an array of them. d) Create or Connect to a buffer d1) Create a buffer using createConnectedBuffer(...) OR d2) Create a buffer using createBufferAsTemplate(...) and use connectWithBuffer(...) OR d3) Create a buffer externally and to connect it with connectWithBuffer(...) OR e) Map the connected buffer or, if you are not using a buffer, point to the memory you wish to set e1) Map with map(...), mapArrayIndex(...) or mapMultipleArrayIndices(...) OR e2) Use pointToMemory(...), to set a custom pointer as the destination of your set... operations f) Set any values you wish to set using the methods: setValue(...), setArrayValue(...). The value you provide will be transformed if necessary (adding necessary paddings etc. if such are required), and copied onto the designaded point in the buffer g) Unmap the connected buffer.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a72590090482e9b08dce38672b4b4756a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::utils::StructuredBufferView::StructuredBufferView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor. Creates an empty <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afff6421d697e929a0c6ae66b45c84873"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;types::GpuDatatypes::Standard _standard_ = types::GpuDatatypes::Standard::std140&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::addEntriesPacked </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; StringHash, types::GpuDatatypes::Enum &gt; *const&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>numEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add multiple entries to the end of the list, in order, each packed on the minimum valid offset that the specified packing standard allows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>A c-style array of pairs of Names and Datatypes, that will be added (As if addEntryPacked was called for each sequentially</td></tr>
    <tr><td class="paramname">numEntries</td><td>The number of entries contained in the array 'entries'</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">standard</td><td>The packing standard to use. Currently, only std140 is supported.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c1f4f9d4fa99051d61fc680340b95a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::addEntryAtOffset </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::GpuDatatypes::Enum&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>arrayElements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a variable entry to the specified byte offset of the buffer. Order is implicit based on the offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new variable</td></tr>
    <tr><td class="paramname">type</td><td>The datatype of the new variable</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset (number of bytes from the beginning of the buffer) to which to add the new variable</td></tr>
    <tr><td class="paramname">arrayElements</td><td>If greater than one, the entry will be an array (type[arrayElements])</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index into which the array was inserted. If it is not the last element, will change the indexes of other array elements.</dd></dl>

</div>
</div>
<a class="anchor" id="a98d84adbb33049a165ad4139f59cc776"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;types::GpuDatatypes::Standard _standard_ = types::GpuDatatypes::Standard::std140&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::addEntryPacked </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::GpuDatatypes::Enum&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>arrayElements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an entry to the end of the list, packed on the minimum valid offset that the specified packing standard allows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new variable</td></tr>
    <tr><td class="paramname">type</td><td>The datatype of the new variable</td></tr>
    <tr><td class="paramname">arrayElements</td><td>If greater than one, the entry will be an array (type[arrayElements])</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">standard</td><td>The packing standard to use. Currently, only std140 is supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index into which the array was inserted. Since the entry is added to the end of the list, it does not affect the indexes of any array elements that are already added.</dd></dl>

</div>
</div>
<a class="anchor" id="a8943b677ab04c5e7de6768bb206afcab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::connectWithBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const api::BufferView &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::MapBufferFlags&#160;</td>
          <td class="paramname"><em>mapDefaultFlags</em> = <code>types::MapBufferFlags::Write</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mapDefaultOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect a buffer to this object, so that the methods map... setValue... unMap... be called directly. The buffer must be mappable and (obviously) be large enough to contain the data written. Using this function and calling map/set/unmap would be similar to calling pointToMemory(buffer-&gt;map), setValue, buffer-&gt;unmap, pointToMemory(null). Swap indexes can be set separately to facilitate multibuffering setups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIdx</td><td>Set a buffer for this swap index. For non-multibuffering setups, use 0. Only one buffer will be set per index. Setting another buffer discards the reference to the previous one.</td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to connect to this object.</td></tr>
    <tr><td class="paramname">mapDefaultFlags</td><td>The flags to use by default when mapping. Can be overriden in the mapping command. Default is Write.</td></tr>
    <tr><td class="paramname">mapDefaultOffset</td><td>A custom offset to apply by default to any <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a335fe2834c3c3b5cde440d81f42dd52d" title="Map the buffer connected to the specified swap index. After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer. Maps the entire buffer.">map()</a> methods called for this buffer. Default is 0.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1a79572349b830d0f249d9e2f4543d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">api::BufferView pvr::utils::StructuredBufferView::createBufferAsTemplate </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mappable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Using this object as a template, create a buffer suitable for exactly holding the information represented by this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The graphics context to create the buffer on</td></tr>
    <tr><td class="paramname">mappable</td><td>The created buffer can be mapped. Default true.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8f62d46c54525339691b001183025ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">api::BufferView pvr::utils::StructuredBufferView::createBufferAsTemplate </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::BufferBindingUse&#160;</td>
          <td class="paramname"><em>bufferAllowedUses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mappable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Using this object as a template, create a buffer suitable for exactly holding the information represented by this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The graphics context to create the buffer on</td></tr>
    <tr><td class="paramname">bufferAllowedUses</td><td>The uses the buffer can be used for. Will affect the alignment of each element of this object, so must be respected. This usage must be a subset of the uses set out in the call made to finalize.</td></tr>
    <tr><td class="paramname">mappable</td><td>The created buffer can be mapped. Default true.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1994b1320175a2087aa387c0bcb7ed79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::createConnectedBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::MapBufferFlags&#160;</td>
          <td class="paramname"><em>mapDefaultFlags</em> = <code>types::MapBufferFlags::Write</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Using the structure of this object as a template, create a buffer suitable for its contents. The buffer will be created with exactly the correct size and with the flags passed. It is in all respects the same as calling createBufferAsTemplate and then connectWithBuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIdx</td><td>The swap index to assign this buffer to (i.e. the index that will be used in mapConnectedBuffer to map this buffer).</td></tr>
    <tr><td class="paramname">ctx</td><td>The graphics context to create the buffer on</td></tr>
    <tr><td class="paramname">mapDefaultFlags</td><td>The mapping flags used as default when calling <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a335fe2834c3c3b5cde440d81f42dd52d" title="Map the buffer connected to the specified swap index. After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer. Maps the entire buffer.">map()</a>. Default: Write</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cfac282dde8fa696b32b4369e14fb6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::createConnectedBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::BufferBindingUse&#160;</td>
          <td class="paramname"><em>bufferAllowedUses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::MapBufferFlags&#160;</td>
          <td class="paramname"><em>mapDefaultFlags</em> = <code>types::MapBufferFlags::Write</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Using the structure of this object as a template, create a buffer suitable for its contents. The buffer will be created with exactly the correct size and with the flags passed. It is in all respects the same as calling createBufferAsTemplate and then connectWithBuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIdx</td><td>The swap index to assign this buffer to (i.e. the index that will be used in mapConnectedBuffer to map this buffer).</td></tr>
    <tr><td class="paramname">ctx</td><td>The graphics context to create the buffer on</td></tr>
    <tr><td class="paramname">bufferAllowedUses</td><td>The uses the buffer can be used for. Will affect the alignment of each element of this object, so must be respected. This usage must be a subset of the uses set out in the call made to finalize.</td></tr>
    <tr><td class="paramname">mapDefaultFlags</td><td>The mapping flags used as default when calling <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a335fe2834c3c3b5cde440d81f42dd52d" title="Map the buffer connected to the specified swap index. After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer. Maps the entire buffer.">map()</a>. Default: Write</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95d7d484c504388d8bbf6fde1b1fe900"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::createConnectedBuffers </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numberOfSwapIdxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::MapBufferFlags&#160;</td>
          <td class="paramname"><em>mapDefaultFlags</em> = <code>types::MapBufferFlags::Write</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Using the structure of this object as a template, create a set of buffers suitable for its contents. The buffer will be created with exactly the correct size and with the flags passed. Same as calling createConnectedBuffers once for each number from zero to numberOfSwapIdxs-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberOfSwapIdxs</td><td>Set up multibuffering: one buffer will be created per swapIdx.</td></tr>
    <tr><td class="paramname">ctx</td><td>The graphics context to create the buffers on</td></tr>
    <tr><td class="paramname">mapDefaultFlags</td><td>The mapping flags used as default when calling <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a335fe2834c3c3b5cde440d81f42dd52d" title="Map the buffer connected to the specified swap index. After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer. Maps the entire buffer.">map()</a>. Default: Write</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd8bb23c7be7bc35fe6a1677d49aaaf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::createConnectedBuffers </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numberOfSwapIdxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::BufferBindingUse&#160;</td>
          <td class="paramname"><em>bufferAllowedUses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::MapBufferFlags&#160;</td>
          <td class="paramname"><em>mapDefaultFlags</em> = <code>types::MapBufferFlags::Write</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Using the structure of this object as a template, create a set of buffers suitable for its contents. The buffer will be created with exactly the correct size and with the flags passed. Same as calling createConnectedBuffers once for each number from zero to numberOfSwapIdxs-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberOfSwapIdxs</td><td>Set up multibuffering: one buffer will be created per swapIdx.</td></tr>
    <tr><td class="paramname">ctx</td><td>The graphics context to create the buffers on</td></tr>
    <tr><td class="paramname">bufferAllowedUses</td><td>The uses the specific set of buffers can be used for. Will affect the alignment of each element of this object, so must be respected. This usage must be a subset of the uses set out in the call made to finalize.</td></tr>
    <tr><td class="paramname">mapDefaultFlags</td><td>The mapping flags used as default when calling <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#a335fe2834c3c3b5cde440d81f42dd52d" title="Map the buffer connected to the specified swap index. After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer. Maps the entire buffer.">map()</a>. Default: Write</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fc90e44c849c6d8478d399e8381bc40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::finalize </td>
          <td>(</td>
          <td class="paramtype">const GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>elementCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::BufferBindingUse&#160;</td>
          <td class="paramname"><em>bufferAllowedUses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowedUboDynamic</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowedSsboDynamic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function in order to set this object up properly to represent an array of elements, i.e. the information that has been added represents only an array member or dynamic slice of the buffer and not its entire contents. This function must be called for dynamic uniform/storage buffers before calling any of the createConnectedBuffer and similar functions as it affects the total size AND alignment of items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The graphics context to query for alignment restrictions</td></tr>
    <tr><td class="paramname">elementCount</td><td>The number of dynamic elements or array elements (i.e. the number of array members) of the buffer</td></tr>
    <tr><td class="paramname">bufferAllowedUses</td><td>The types of buffers that this object will be able to be used with. Will affect the alignment/padding of each element of this object, so must be respected. If in doubt, add both UniformBuffer and StorageBufer in order to ensure the strictest alignment requirements are enforced.</td></tr>
    <tr><td class="paramname">allowedUboDynamic</td><td>Allow this object to be bound as a Dynamic Ubo. WARNING: If this flag is not set and the object is used as a DynamicUbo, errors may occur as the buffer may be more packed than the API may support</td></tr>
    <tr><td class="paramname">allowedSssboDynamic</td><td>Allow this object to be bound as a Dynamic SSBO. WARNING: If this flag is not set and the object is later used as a DynamicUbo, errors may occur as the buffer may be more packed than the API may support</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abea7c4481bf9ea2993b88638d13c5dfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getAlignedElementArrayOffset </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the offset of an element (a dynamic "slice" or array element) of the buffer. Same as <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html#ac3211e154516559bf4253cedb5fd7c9f" title="Get the aligned size of an single element. &quot;Aligned&quot; here means the space that each element of this b...">getAlignedElementSize()</a> * index.</p>
<dl class="section return"><dt>Returns</dt><dd>The offset in a buffer of an array/dynamic element.</dd></dl>

</div>
</div>
<a class="anchor" id="ac3211e154516559bf4253cedb5fd7c9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getAlignedElementSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the aligned size of an single element. "Aligned" here means the space that each element of this buffer would take if it was a member of an array or dynamic buffer. If the buffer is not dynamic or an array, it is the same as the unaligned size. If the buffer is dynamic, it is the unaligned size rounded up to an integer multiple of the minimum alignment for a dynamic buffer of the correct type the platform allows. </p>
<dl class="section return"><dt>Returns</dt><dd>Return The Aligned Size</dd></dl>

</div>
</div>
<a class="anchor" id="a93aad09db99e4e54536e155116be6c88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getAlignedTotalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total size of the buffer, padded for alignement.</p>
<dl class="section return"><dt>Returns</dt><dd>Return The Aligned Size</dd></dl>

</div>
</div>
<a class="anchor" id="a7c4248f296357eda1d026f7a9952d54e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">api::BufferView pvr::utils::StructuredBufferView::getConnectedBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the connected buffer for the specified swap index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIdx</td><td>A swap index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer that has been created or connected to the specified swap index</dd></dl>

</div>
</div>
<a class="anchor" id="aeba1fbd6b8e7286d1006cd3f2813a5e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getDynamicOffset </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>variableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dynamicIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>entryArrayIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a dynamic buffer or an array of structs buffer, get the byte offset from the start of the buffer, of the specified variable by name, for a specified dynamic or array 'slice' of the buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableName</td><td>The name of the variable entry to get the byte offset of</td></tr>
    <tr><td class="paramname">dynamicIndex</td><td>The index of the buffer dynamic or array slice for which to perform the calculations</td></tr>
    <tr><td class="paramname">entryArrayIndex</td><td>If the variable is an array, which member of the array to return the offset to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte offset of the entry at position 'variableIndex' of the slice 'dynamicIndex'</dd></dl>

</div>
</div>
<a class="anchor" id="a0cea9f58b393a6a8716a0910cb9228cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getDynamicOffset </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>variableIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dynamicIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>entryArrayIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a dynamic buffer or an array of structs buffer, get the byte offset from the start of the buffer, of the specified variable by entry index, for a specified dynamic or array 'slice' of the buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableIndex</td><td>The index of the entry to get the byte offset of</td></tr>
    <tr><td class="paramname">dynamicIndex</td><td>The index of the buffer dynamic or array slice for which to perform the calculations</td></tr>
    <tr><td class="paramname">entryArrayIndex</td><td>If the variable is an array, which member of the array to return the offset to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte offset of the entry at position 'variableIndex' of the slice 'dynamicIndex'</dd></dl>

</div>
</div>
<a class="anchor" id="a4d9b79e866befe84eb04e16a6eb21d75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getElementCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of array or dynamic buffer elements</p>
<dl class="section return"><dt>Returns</dt><dd>Return number of array or dynamic buffer elements</dd></dl>

</div>
</div>
<a class="anchor" id="a7c876f548186b035f0882e86c853b4c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getIndex </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the index of a variable entry by its name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of a variable entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of a variable entry</dd></dl>

</div>
</div>
<a class="anchor" id="aab54b1da0a040041b9ffb95320a95aab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* pvr::utils::StructuredBufferView::getMemoryPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to which any setValue...(...) operation called will be writing to. Normally set when performing the map...(...) operations, or directly by the user with pointToMemory(...)</p>

</div>
</div>
<a class="anchor" id="a3571efe0221afe7c1b34584bbfc37f4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* pvr::utils::StructuredBufferView::getMemoryPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to which any setValue...(...) operation called will be writing to. Normally set when performing the map...(...) operations, or directly by the user with pointToMemory(...)</p>

</div>
</div>
<a class="anchor" id="a9cf966c08e1e94a3059c23564a577034"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getMultibufferCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of connected buffers.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of connected buffers.</dd></dl>

</div>
</div>
<a class="anchor" id="af1da195bb183b7df2cb6db72e287b7f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getOffset </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>entryArrayIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the byte offset of the specified variable by name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the entry variable</td></tr>
    <tr><td class="paramname">entryArrayIndex</td><td>If the variable is an array, which member of the array to return the offset to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte offset of the entry with name 'name'</dd></dl>

</div>
</div>
<a class="anchor" id="a26f87d9a136bf85335cc9140f2baa83b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getOffset </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>variableIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>entryArrayIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the byte offset of the specified variable by entry index</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableIndex</td><td>The index of the entry to get the byte offset of</td></tr>
    <tr><td class="paramname">entryArrayIndex</td><td>If the variable is an array, which member of the array to return the offset to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte offset of the entry at position 'variableIndex'</dd></dl>

</div>
</div>
<a class="anchor" id="ae813fb480f1f4e5ed693f3a5ec09fe4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::utils::StructuredBufferView::getUnalignedElementSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the (unaligned) size of an single element. "Element" here means an entire definition of the buffer, but if the buffer is a Dynamic buffer or an array of structures, it contains multiple "slices" of that definition. Otherwise, the element size is the size of the entire buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Return The Aligned Size</dd></dl>

</div>
</div>
<a class="anchor" id="aaf37e669f0ac851df24b242821b7c9e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;StructuredMemoryTableEntry&gt;&amp; pvr::utils::StructuredBufferView::getVariableList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the full variable entry list in raw format. Const overload.</p>
<dl class="section return"><dt>Returns</dt><dd>The full variable entry list, as a std::vector of entries.</dd></dl>

</div>
</div>
<a class="anchor" id="a2d080cf787a9e0fdad78e5e35bfd463b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;StructuredMemoryTableEntry&gt;&amp; pvr::utils::StructuredBufferView::getVariableList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the full variable entry list in raw format. Non-const overload.</p>
<dl class="section return"><dt>Returns</dt><dd>The full variable entry list, as a std::vector of entries.</dd></dl>

</div>
</div>
<a class="anchor" id="a2214fe4b869b7717b35710b988b6cea3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::StructuredBufferView::isFinalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the structured memory view has been finalized.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether finalize has been called for the structured memory view.</dd></dl>

</div>
</div>
<a class="anchor" id="a0bbd2a5b4d95c7c10c75d346fe4a10aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::StructuredBufferView::isMapped </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if it is already mapped for a given swapchain index.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the buffer for <em>swapIdx</em> is mapped, otherwise false</dd></dl>

</div>
</div>
<a class="anchor" id="a838a2001625761e79678cece0342b1f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::StructuredBufferView::isMultiBuffered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the connected buffer is a multibuffered object.</p>
<dl class="section return"><dt>Returns</dt><dd>Return true if the connected buffer is a multibuffered object.</dd></dl>

</div>
</div>
<a class="anchor" id="a335fe2834c3c3b5cde440d81f42dd52d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::map </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::MapBufferFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>types::MapBufferFlags::Write</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0xFFFFFFFFu</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map the buffer connected to the specified swap index. After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer. Maps the entire buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIdx</td><td>A swap index</td></tr>
    <tr><td class="paramname">flags</td><td>The Mapping flags to use. Default:Write.</td></tr>
    <tr><td class="paramname">offset</td><td>A custom offset, from the beginneing of this buffer, to apply to the mapping operation. This offset overrides the default offset defined when calling connectWithBuffer. Default: The default offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3ceb2251117e56edf83da1c58760f32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::mapArrayIndex </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>arrayIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::MapBufferFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>types::MapBufferFlags::Write</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map multiple a single array/dynamic element of the buffer connected to the specified swap index. Identical as calling mapMultipleArrayElements(index, 1,...) After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer for this swap index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIdx</td><td>A swap index</td></tr>
    <tr><td class="paramname">arrayIndex</td><td>The element (array slice) to map</td></tr>
    <tr><td class="paramname">flags</td><td>The Mapping flags to use. Default:Write.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af99c3b6f92ba47ebe982f006d4b351b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::mapMultipleArrayElements </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>arrayStartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numElementsToMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::MapBufferFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>types::MapBufferFlags::Write</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0xFFFFFFFFu</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map multiple consecutive array/dynamic elements of the buffer connected to the specified swap index. After performing this operation, the setValue(...) setArrayValue(...) and similar commands become valid and actually set values on the buffer for that swap index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIdx</td><td>A swap index</td></tr>
    <tr><td class="paramname">arrayStartIndex</td><td>The first element (array slice) to map</td></tr>
    <tr><td class="paramname">numElementsToMap</td><td>The number of elements to map.</td></tr>
    <tr><td class="paramname">flags</td><td>The Mapping flags to use. Default:Write.</td></tr>
    <tr><td class="paramname">offset</td><td>A custom offset, from the beginneing of this buffer, to apply to the mapping operation. This offset overrides the default offset defined when calling connectWithBuffer. Default: The default offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a556d1602aba1f17b1807dfaa34f43790"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::pointToMemory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memoryToPointTo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instead of connecting this object to an actual buffer, directly provide a pointer to some kind of memory. This memory will be used when the setValue(...), setArrayValue(...) methods are called</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoryToPointTo</td><td>A pointer to memory that is assumed to follow the structure defined by this object.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace48180ff8c81e7732ddcd4b0ba3a40d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::setMultibufferCount </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the connected buffers as a multibuffered object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of buffers to set</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9bd065d79395966255e04be38168e04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::StructuredBufferView::unmap </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmap the mapped buffer at a specified swap index. After calling this function, calling setValue() is no longer valid for that swap index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIdx</td><td>A swap index</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVREngineUtils/<a class="el" href="_structured_memory_8h_source.html">StructuredMemory.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
