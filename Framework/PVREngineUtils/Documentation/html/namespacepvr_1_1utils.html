<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVREngineUtils: pvr::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVREngineUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains functionality (especially free-standing functions) used to facilitate and simplify common tasks, such as automated generation of VBOs for specific meshes, or tying together Effects and Meshes to automate Pipeline creation. 
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html">AssetStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages scene assets. Use this class to easily load assets without needing to worry about duplicates. This class keeps references to assets, so remember to release them if they are no longer required. <a href="classpvr_1_1utils_1_1_asset_store.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_render_manager.html">RenderManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1utils_1_1_render_manager.html" title="The RenderManager is a rendering automation class, with class responsibilities such as: - Putting tog...">RenderManager</a> is a rendering automation class, with class responsibilities such as: - Putting together PFX files (Effects) with POD models (Models) to render - Creating Graphics Pipelines, Descriptor Sets, VBOs, IBOs, UBOs, etc. - Creating and configuring render - to - texture targets - Automatically generate command buffers for rendering - Automatically update textures/uniforms/buffers in the rendering api with info provided by the the model (textures, matrices etc) <a href="classpvr_1_1utils_1_1_render_manager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_buffer_binding.html">RendermanBufferBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information to bind a buffer to a specific pipeline's descriptor sets. <a href="structpvr_1_1utils_1_1_renderman_buffer_binding.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_buffer_definition.html">RendermanBufferDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to store buffers such as ubo and ssbo <a href="structpvr_1_1utils_1_1_renderman_buffer_definition.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html">RendermanEffect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of RendermanStructure. This class contains the different passes, exactly mirroring the PFX effect. Contains the original EffectApi. <a href="structpvr_1_1utils_1_1_renderman_effect.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_material.html">RendermanMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to store a material. <a href="structpvr_1_1utils_1_1_renderman_material.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_mesh.html">RendermanMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of RendermanStructure. This class is used to store VBOs/IBOs. Unique per mesh RendermanNodes inside passes/subpasses reference these items by pointer. <a href="structpvr_1_1utils_1_1_renderman_mesh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_model.html">RendermanModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of RendermanStructure. This class is used to store RendermanMeshes. Unique per model RendermanModelEffects inside passes/subpasses reference these items by pointer. <a href="structpvr_1_1utils_1_1_renderman_model.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html">RendermanPipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of RendermanStructure. This class is a cooked EffectPipeline, exactly mirroring the PFX pipelines. It is affected on creation time by the meshes that use it (for the Vertex Input configuration) but after that it is used for rendering directly when traversing the scene. <a href="structpvr_1_1utils_1_1_renderman_pipeline.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_subpass_group_model.html">RendermanSubpassGroupModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part of RendermanStructure. This class stores RendermanNodes and RendermanMaterialEffects The list of nodes here references the list of materials. It references the Models in the original RendermanModelStore list.  <a href="structpvr_1_1utils_1_1_renderman_subpass_group_model.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html">StructuredBufferView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structured buffer view is a class that can be used to define an explicit structure to an object that is usually accessed as raw memory. For example, a GPU-side buffer is mapped to a void pointer, but a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a> can be used to create a runtime structure for it, and set its entries one by one. Normal use: a) Create a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a>. b) Populate it using the function addEntryPacked(...) which adds information about the variables that will be used c) When done, call setUpArray or setUpDynamic if it is possible to use this for DynamicUniform, DynamicStorage, or any other case where the entries only represent an array member and the buffer is an array of them. d) Create or Connect to a buffer d1) Create a buffer using createConnectedBuffer(...) OR d2) Create a buffer using createBufferAsTemplate(...) and use connectWithBuffer(...) OR d3) Create a buffer externally and to connect it with connectWithBuffer(...) OR e) Map the connected buffer or, if you are not using a buffer, point to the memory you wish to set e1) Map with map(...), mapArrayIndex(...) or mapMultipleArrayIndices(...) OR e2) Use pointToMemory(...), to set a custom pointer as the destination of your set... operations f) Set any values you wish to set using the methods: setValue(...), setArrayValue(...). The value you provide will be transformed if necessary (adding necessary paddings etc. if such are required), and copied onto the designaded point in the buffer g) Unmap the connected buffer. <a href="classpvr_1_1utils_1_1_structured_buffer_view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Explicit binding, tying a Semantic name to an Attribute Index. <a href="structpvr_1_1utils_1_1_vertex_bindings.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name. <a href="structpvr_1_1utils_1_1_vertex_bindings___name.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5ee552a08543cb9df91c8b9aa50e376"><td class="memTemplParams" colspan="2">template&lt;typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:ae5ee552a08543cb9df91c8b9aa50e376"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae5ee552a08543cb9df91c8b9aa50e376">appendSingleBuffersFromModel</a> (GraphicsContext &amp;context, const assets::Model &amp;model, VboContainer_ &amp;vbos, IboContainer_ &amp;ibos)</td></tr>
<tr class="memdesc:ae5ee552a08543cb9df91c8b9aa50e376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user. <a href="#ae5ee552a08543cb9df91c8b9aa50e376">More...</a><br/></td></tr>
<tr class="separator:ae5ee552a08543cb9df91c8b9aa50e376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6201dfb94919344e2470887e7da9d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6a6201dfb94919344e2470887e7da9d4">createInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a> *bindingMap, uint16 numBindings, api::GraphicsPipelineCreateParam &amp;inoutDesc, uint16 *outNumBuffers=NULL)</td></tr>
<tr class="memdesc:a6a6201dfb94919344e2470887e7da9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a assets::Mesh object and a list of Attribute Semantics mapping to binding points to generate the Input Assembly into a GraphicsPipelineCreateParam object. <a href="#a6a6201dfb94919344e2470887e7da9d4">More...</a><br/></td></tr>
<tr class="separator:a6a6201dfb94919344e2470887e7da9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc90bb1fd5aeaab4dc435a45ffcd2c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acc90bb1fd5aeaab4dc435a45ffcd2c59">createInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a> *bindingMap, uint16 numBindings, api::GraphicsPipelineCreateParam &amp;inoutDesc, uint16 *outNumBuffers=NULL)</td></tr>
<tr class="memdesc:acc90bb1fd5aeaab4dc435a45ffcd2c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a assets::Mesh object and a list of Attribute Semantics mapping to shader variable names to generate the Input Assembly into a GraphicsPipelineCreateParam object. <a href="#acc90bb1fd5aeaab4dc435a45ffcd2c59">More...</a><br/></td></tr>
<tr class="separator:acc90bb1fd5aeaab4dc435a45ffcd2c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970a422c3d6ad225fb60116d41ed0b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a970a422c3d6ad225fb60116d41ed0b6b">createInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a> *bindingMap, uint16 numBindings, api::VertexRayPipelineCreateParam &amp;inoutDesc, uint16 *outNumBuffers=NULL)</td></tr>
<tr class="memdesc:a970a422c3d6ad225fb60116d41ed0b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a assets::Mesh object and a list of Attribute Semantics mapping to binding points to generate the Input Assembly into a VertexRayPipelineCreateParam object. <a href="#a970a422c3d6ad225fb60116d41ed0b6b">More...</a><br/></td></tr>
<tr class="separator:a970a422c3d6ad225fb60116d41ed0b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7facdbc44093ac50bbab7de65aa66e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac7facdbc44093ac50bbab7de65aa66e1">createInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a> *bindingMap, uint16 numBindings, api::VertexRayPipelineCreateParam &amp;inoutDesc, uint16 *outNumBuffers=NULL)</td></tr>
<tr class="memdesc:ac7facdbc44093ac50bbab7de65aa66e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a assets::Mesh object and a list of Attribute Semantics mapping to shader variable names to generate the Input Assembly into a VertexRayPipelineCreateParam object. <a href="#ac7facdbc44093ac50bbab7de65aa66e1">More...</a><br/></td></tr>
<tr class="separator:ac7facdbc44093ac50bbab7de65aa66e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8422cc2313780b8b024b0ce706e74047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8422cc2313780b8b024b0ce706e74047">createInputAssemblyFromMeshAndEffect</a> (const assets::Mesh &amp;mesh, assets::Effect effect, api::GraphicsPipelineCreateParam &amp;inoutDesc, uint16 *outNumBuffers=NULL)</td></tr>
<tr class="memdesc:a8422cc2313780b8b024b0ce706e74047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a assets::Mesh object and a assets::Effect object to generate the Input Assembly information for a pipeline object. <a href="#a8422cc2313780b8b024b0ce706e74047">More...</a><br/></td></tr>
<tr class="separator:a8422cc2313780b8b024b0ce706e74047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87b0c61478cf697ec2583d36841500e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac87b0c61478cf697ec2583d36841500e">createMultipleBuffersFromMesh</a> (GraphicsContext &amp;context, const assets::Mesh &amp;mesh, std::vector&lt; api::Buffer &gt; &amp;outVbos, api::Buffer &amp;outIbo)</td></tr>
<tr class="memdesc:ac87b0c61478cf697ec2583d36841500e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh. <a href="#ac87b0c61478cf697ec2583d36841500e">More...</a><br/></td></tr>
<tr class="separator:ac87b0c61478cf697ec2583d36841500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197a9b52b2f471414c34e27bdf111e06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a197a9b52b2f471414c34e27bdf111e06">createSingleBuffersFromMesh</a> (GraphicsContext &amp;context, const assets::Mesh &amp;mesh, api::Buffer &amp;outVbo, api::Buffer &amp;outIbo)</td></tr>
<tr class="memdesc:a197a9b52b2f471414c34e27bdf111e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a single VBO and a single IBO from all the vertex data of a mesh. <a href="#a197a9b52b2f471414c34e27bdf111e06">More...</a><br/></td></tr>
<tr class="separator:a197a9b52b2f471414c34e27bdf111e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b08e475f397bd20d6d1ea49c24494f"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a77b08e475f397bd20d6d1ea49c24494f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a77b08e475f397bd20d6d1ea49c24494f">createSingleBuffersFromMeshes</a> (GraphicsContext &amp;context, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboInsertIterator_ outVbos, IboInsertIterator_ outIbos)</td></tr>
<tr class="memdesc:a77b08e475f397bd20d6d1ea49c24494f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container. <a href="#a77b08e475f397bd20d6d1ea49c24494f">More...</a><br/></td></tr>
<tr class="separator:a77b08e475f397bd20d6d1ea49c24494f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfc2ee737d8141a795e855a2f5ffc6e"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:a2dfc2ee737d8141a795e855a2f5ffc6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2dfc2ee737d8141a795e855a2f5ffc6e">createSingleBuffersFromMeshes</a> (GraphicsContext &amp;context, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboContainer_ &amp;outVbos, typename VboContainer_::iterator vbos_where, IboContainer_ &amp;outIbos, typename IboContainer_::iterator ibos_where)</td></tr>
<tr class="memdesc:a2dfc2ee737d8141a795e855a2f5ffc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container. <a href="#a2dfc2ee737d8141a795e855a2f5ffc6e">More...</a><br/></td></tr>
<tr class="separator:a2dfc2ee737d8141a795e855a2f5ffc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe79a94fc65e95490b9da43ec68421b3"><td class="memTemplParams" colspan="2">template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:abe79a94fc65e95490b9da43ec68421b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abe79a94fc65e95490b9da43ec68421b3">createSingleBuffersFromModel</a> (GraphicsContext &amp;context, const assets::Model &amp;model, VboInsertIterator_ vbos, IboInsertIterator_ ibos)</td></tr>
<tr class="memdesc:abe79a94fc65e95490b9da43ec68421b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters. <a href="#abe79a94fc65e95490b9da43ec68421b3">More...</a><br/></td></tr>
<tr class="separator:abe79a94fc65e95490b9da43ec68421b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains functionality (especially free-standing functions) used to facilitate and simplify common tasks, such as automated generation of VBOs for specific meshes, or tying together Effects and Meshes to automate Pipeline creation.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae5ee552a08543cb9df91c8b9aa50e376"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VboContainer_ , typename IboContainer_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::appendSingleBuffersFromModel </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>vbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>ibos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The device context where the buffers will be generated on</td></tr>
    <tr><td class="paramname">model</td><td>The model whose meshes will be used to generate the Buffers</td></tr>
    <tr><td class="paramname">vbos</td><td>A container of api::Buffer handles. The VBOs will be inserted at the end of this container.</td></tr>
    <tr><td class="paramname">ibos</td><td>A container of api::Buffer handles. The IBOs will be inserted at the end of this container.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the VBO. It is usually preferred for meshes meshes containing a single set of interleaved data. If multiple data elements (i.e. sets of interleaved data), each block will be successively placed after the other.</p>

</div>
</div>
<a class="anchor" id="a6a6201dfb94919344e2470887e7da9d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexBindings *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::GraphicsPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>inoutDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>outNumBuffers</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a assets::Mesh object and a list of Attribute Semantics mapping to binding points to generate the Input Assembly into a GraphicsPipelineCreateParam object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh object</td></tr>
    <tr><td class="paramname">bindingMap</td><td>A user provided list that maps Attribute Semantic names (strings) to shader Binding Points(ints)</td></tr>
    <tr><td class="paramname">numBindings</td><td>number of binding map in array</td></tr>
    <tr><td class="paramname">inoutDesc</td><td>The GraphicsPipelineCreateParam object. Only the vertexInput and InputAssembler objects are modified.</td></tr>
    <tr><td class="paramname">outNumBuffers</td><td>OPTIONAL. Return the number of buffers used by the mesh</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the user to automatically generate the Input Assembly data that a Pipeline object requires from the semantic info of a Mesh and an list of explicit bindings. These bindings are usually created by the user, who needs to corellate the Attribute Semantics of the Mesh with the explicit Binding Points of these attributes into a shader. This function will then create suitable input bindings into the provided GraphicsPipelineCreateParam object. The user then does not need to set the Vertex Attributes, Input Bindings and Primitive Topology of this object. The rest of the GraphicsPipelineCreateParam must be set normally. </p>

</div>
</div>
<a class="anchor" id="acc90bb1fd5aeaab4dc435a45ffcd2c59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexBindings_Name *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::GraphicsPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>inoutDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>outNumBuffers</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a assets::Mesh object and a list of Attribute Semantics mapping to shader variable names to generate the Input Assembly into a GraphicsPipelineCreateParam object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh</td></tr>
    <tr><td class="paramname">bindingMap</td><td>A user-provided list that maps Attribute Semantics (strings) to shader Variable Names(strings)</td></tr>
    <tr><td class="paramname">numBindings</td><td>number of bindings in the array</td></tr>
    <tr><td class="paramname">inoutDesc</td><td>The GraphicsPipelineCreateParam object. Only the vertexInput and InputAssembler objects are modified.</td></tr>
    <tr><td class="paramname">outNumBuffers</td><td>OPTIONAL. Return the number of buffers used by the mesh</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the user to automatically generate the Input Assembly data that a Pipeline object requires from the semantic info of a Mesh and an list that connects Semantics from the mesh to attribute (input) variables in the vertext shader. These bindings are usually created by the user, who needs to corellate the Attribute Semantics of the Mesh with the shader vertex attributes. This function will then create suitable input bindings into the provided GraphicsPipelineCreateParam object. The user then does not need to set the Vertex Attributes, Input Bindings and Primitive Topology of this object. The rest of the GraphicsPipelineCreateParam must be set normally.</p>

</div>
</div>
<a class="anchor" id="a970a422c3d6ad225fb60116d41ed0b6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexBindings *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::VertexRayPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>inoutDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>outNumBuffers</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a assets::Mesh object and a list of Attribute Semantics mapping to binding points to generate the Input Assembly into a VertexRayPipelineCreateParam object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh object</td></tr>
    <tr><td class="paramname">bindingMap</td><td>A user provided list that maps Attribute Semantic names (strings) to shader Binding Points(ints)</td></tr>
    <tr><td class="paramname">numBindings</td><td>number of binding map in array</td></tr>
    <tr><td class="paramname">inoutDesc</td><td>The VertexRayPipelineCreateParam object. Only the vertexInput and InputAssembler objects are modified.</td></tr>
    <tr><td class="paramname">outNumBuffers</td><td>OPTIONAL. Return the number of buffers used by the mesh</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the user to automatically generate the Input Assembly data that a Pipeline object requires from the semantic info of a Mesh and an list of explicit bindings. These bindings are usually created by the user, who needs to corellate the Attribute Semantics of the Mesh with the explicit Binding Points of these attributes into a shader. This function will then create suitable input bindings into the provided VertexRayPipelineCreateParam object. The user then does not need to set the Vertex Attributes, Input Bindings and Primitive Topology of this object. The rest of the VertexRayPipelineCreateParam must be set normally. </p>

</div>
</div>
<a class="anchor" id="ac7facdbc44093ac50bbab7de65aa66e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexBindings_Name *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::VertexRayPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>inoutDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>outNumBuffers</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a assets::Mesh object and a list of Attribute Semantics mapping to shader variable names to generate the Input Assembly into a VertexRayPipelineCreateParam object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh</td></tr>
    <tr><td class="paramname">bindingMap</td><td>A user-provided list that maps Attribute Semantics (strings) to shader Variable Names(strings)</td></tr>
    <tr><td class="paramname">numBindings</td><td>number of bindings in the array</td></tr>
    <tr><td class="paramname">inoutDesc</td><td>The VertexRayPipelineCreateParam object. Only the vertexInput and InputAssembler objects are modified.</td></tr>
    <tr><td class="paramname">outNumBuffers</td><td>OPTIONAL. Return the number of buffers used by the mesh</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the user to automatically generate the Input Assembly data that a Pipeline object requires from the semantic info of a Mesh and an list that connects Semantics from the mesh to attribute (input) variables in the vertext shader. These bindings are usually created by the user, who needs to corellate the Attribute Semantics of the Mesh with the shader vertex attributes. This function will then create suitable input bindings into the provided VertexRayPipelineCreateParam object. The user then does not need to set the Vertex Attributes, Input Bindings and Primitive Topology of this object. The rest of the VertexRayPipelineCreateParam must be set normally.</p>

</div>
</div>
<a class="anchor" id="a8422cc2313780b8b024b0ce706e74047"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createInputAssemblyFromMeshAndEffect </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::Effect&#160;</td>
          <td class="paramname"><em>effect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::GraphicsPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>inoutDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>outNumBuffers</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a assets::Mesh object and a assets::Effect object to generate the Input Assembly information for a pipeline object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh object</td></tr>
    <tr><td class="paramname">effect</td><td>The effect object</td></tr>
    <tr><td class="paramname">inoutDesc</td><td>The GraphicsPipelineCreateParam object. Only the vertexInput and InputAssembler objects are modified.</td></tr>
    <tr><td class="paramname">outNumBuffers</td><td>OPTIONAL. Return the number of buffers used by the mesh</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the user to automatically generate the Input Assembly data that a Pipeline object requires from the semantic info of a Mesh and an Effect. It will corellate the Attribute Semantics provided by the Mesh with the Attribute Semantics required by the Effect, and create suitable input bindings into the provided GraphicsPipelineCreateParam object. The user then does not need to set the Vertex Attributes, Input Bindings and Primitive Topology of this object manually. The rest of the GraphicsPipelineCreateParam must be set normally.</p>

</div>
</div>
<a class="anchor" id="ac87b0c61478cf697ec2583d36841500e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createMultipleBuffersFromMesh </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; api::Buffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outIbo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The device context where the buffers will be generated on</td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh whose data will populate the buffers</td></tr>
    <tr><td class="paramname">outVbos</td><td>Reference to a std::vector of VBO handles where the data will be put. Buffers will be appended at the end.</td></tr>
    <tr><td class="paramname">outIbo</td><td>The IBO handle where the data will be put. No buffer needs to have been created on the handle. If no face data is present on the mesh, the handle will be null.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the mesh and create one Buffer for each data element (block of interleaved data) in the mesh. It is thus commonly used for for meshes containing multiple sets of interleaved data (for example, a VBO with static and a VBO with streaming data).</p>

</div>
</div>
<a class="anchor" id="a197a9b52b2f471414c34e27bdf111e06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMesh </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outVbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outIbo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a single VBO and a single IBO from all the vertex data of a mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The device context where the buffers will be generated on</td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh whose data will populate the buffers</td></tr>
    <tr><td class="paramname">outVbo</td><td>The VBO handle where the data will be put. No buffer needs to have been created on the handle</td></tr>
    <tr><td class="paramname">outIbo</td><td>The IBO handle where the data will be put. No buffer needs to have been created on the handle. If no face data is present on the mesh, the handle will be null.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data. If data are not interleaved, they will be packed on the same VBO, each interleaved block (Data element on the mesh) will be appended at the end of the buffer, and the offsets will need to be calculated by the user when binding the buffer.</p>

</div>
</div>
<a class="anchor" id="a77b08e475f397bd20d6d1ea49c24494f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMeshes </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboInsertIterator_&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboInsertIterator_&#160;</td>
          <td class="paramname"><em>outIbos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The device context where the buffers will be generated on</td></tr>
    <tr><td class="paramname">meshIter</td><td>Iterator for a collection of meshes.</td></tr>
    <tr><td class="paramname">meshIterEnd</td><td>End Iterator for meshIter.</td></tr>
    <tr><td class="paramname">outVbos</td><td>std::inserter for a collection of api::Buffer handles. It will be used to insert one VBO per mesh. </td></tr>
    <tr><td class="paramname">outIbos</td><td>std::inserter for a collection of api::Buffer handles. It will be used to insert one IBO per mesh. If face data is not present on the mesh, a null handle will be inserted.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data (mesh.getNumDataElements() == 1). If more data elements are present (i.e. more than a single interleaved data element) , they will be packed in the sameVBO, with each interleaved block (Data element ) appended at the end of the buffer. It is then the user's responsibility to use the buffer correctly with the API (for example use bindbufferbase and similar) with the correct offsets. The std::inserter this function requires can be created from any container with an insert() function with (for example, for insertion at the end of a vector) std::inserter(std::vector, std::vector::end()) .</p>

</div>
</div>
<a class="anchor" id="a2dfc2ee737d8141a795e855a2f5ffc6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMeshes </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename VboContainer_::iterator&#160;</td>
          <td class="paramname"><em>vbos_where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>outIbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IboContainer_::iterator&#160;</td>
          <td class="paramname"><em>ibos_where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The device context where the buffers will be generated on</td></tr>
    <tr><td class="paramname">meshIter</td><td>Iterator for a collection of meshes.</td></tr>
    <tr><td class="paramname">meshIterEnd</td><td>End Iterator for meshIter.</td></tr>
    <tr><td class="paramname">outVbos</td><td>Collection of api::Buffer handles. It will be used to insert one VBO per mesh.</td></tr>
    <tr><td class="paramname">outIbos</td><td>Collection of api::Buffer handles. It will be used to insert one IBO per mesh. If face data is not present on the mesh, a null handle will be inserted.</td></tr>
    <tr><td class="paramname">vbos_where</td><td>Iterator on outVbos - the position where the insertion will happen.</td></tr>
    <tr><td class="paramname">ibos_where</td><td>Iterator on outIbos - the position where the insertion will happen.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data (mesh.getNumDataElements() == 1). If more data elements are present (i.e. more than a single interleaved data element) , they will be packed in the sameVBO, with each interleaved block (Data element ) appended at the end of the buffer. It is then the user's responsibility to use the buffer correctly with the API (for example use bindbufferbase and similar) with the correct offsets.</p>

</div>
</div>
<a class="anchor" id="abe79a94fc65e95490b9da43ec68421b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromModel </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboInsertIterator_&#160;</td>
          <td class="paramname"><em>vbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboInsertIterator_&#160;</td>
          <td class="paramname"><em>ibos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The device context where the buffers will be generated on</td></tr>
    <tr><td class="paramname">model</td><td>The model whose meshes will be used to generate the Buffers</td></tr>
    <tr><td class="paramname">vbos</td><td>An insert iterator to a std::Buffer container for the VBOs. Vbos will be inserted using this iterator.</td></tr>
    <tr><td class="paramname">ibos</td><td>An insert iterator to an std::Buffer container for the IBOs. Ibos will be inserted using this iterator.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the VBO. It is usually preferred for meshes meshes containing a single set of interleaved data. If multiple data elements (i.e. sets of interleaved data), each block will be successively placed after the other. The std::inserter this function requires can be created from any container with an insert() function with (for example, for insertion at the end of a vector) std::inserter(std::vector, std::vector::end()) .</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
