<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVREngineUtils: pvr::utils::AssetStore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVREngineUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html">AssetStore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1utils_1_1_asset_store-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils::AssetStore Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages scene assets. Use this class to easily load assets without needing to worry about duplicates. This class keeps references to assets, so remember to release them if they are no longer required. 
 <a href="classpvr_1_1utils_1_1_asset_store.html#details">More...</a></p>

<p>Inherits AssetLoadingDelegate.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89f5f9f05b056020efb34f8c8db79014"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#a89f5f9f05b056020efb34f8c8db79014">AssetStore</a> (ErrorLogger logger=&amp;Logger::static_output)</td></tr>
<tr class="memdesc:a89f5f9f05b056020efb34f8c8db79014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <a href="#a89f5f9f05b056020efb34f8c8db79014">More...</a><br/></td></tr>
<tr class="separator:a89f5f9f05b056020efb34f8c8db79014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab071f6a2e16fd5b6fc4c01514a5210d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#ab071f6a2e16fd5b6fc4c01514a5210d6">effectOnLoadTexture</a> (const string &amp;textureName, api::TextureView &amp;outTex2d)</td></tr>
<tr class="memdesc:ab071f6a2e16fd5b6fc4c01514a5210d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the AssetLoadingDelegate. Allows this class to be passed to the EffectApi constructor as the effectDelegate to automate loading and uploading of textures. <a href="#ab071f6a2e16fd5b6fc4c01514a5210d6">More...</a><br/></td></tr>
<tr class="separator:ab071f6a2e16fd5b6fc4c01514a5210d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f0c02d1345b21d6099937fa6463c71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#ae9f0c02d1345b21d6099937fa6463c71">findAndReleaseModel</a> (assets::ModelHandle model)</td></tr>
<tr class="memdesc:ae9f0c02d1345b21d6099937fa6463c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any references to a specified Model object that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding. <a href="#ae9f0c02d1345b21d6099937fa6463c71">More...</a><br/></td></tr>
<tr class="separator:ae9f0c02d1345b21d6099937fa6463c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b2400795b3fb1c72975c3022ff7e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#a17b2400795b3fb1c72975c3022ff7e95">findAndReleaseTexture</a> (api::TextureView texture)</td></tr>
<tr class="memdesc:a17b2400795b3fb1c72975c3022ff7e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any references to a specified Texture object that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding. <a href="#a17b2400795b3fb1c72975c3022ff7e95">More...</a><br/></td></tr>
<tr class="separator:a17b2400795b3fb1c72975c3022ff7e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe081d7a9ec90e6941da9ddcd5e7f8b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#afe081d7a9ec90e6941da9ddcd5e7f8b9">forceLoadTexture</a> (GraphicsContext &amp;context, const StringHash &amp;filename, TextureFileFormat format)</td></tr>
<tr class="memdesc:afe081d7a9ec90e6941da9ddcd5e7f8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture from the asset store and cache it and for later use (through getTextureWithCaching). If the texture already exists, it is re-loaded from disk anyway (see loadTexture, where, if a texture is found, it is returned instead of reloaded) <a href="#afe081d7a9ec90e6941da9ddcd5e7f8b9">More...</a><br/></td></tr>
<tr class="separator:afe081d7a9ec90e6941da9ddcd5e7f8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3bd73158f1996f663371f0f6525015"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#a8b3bd73158f1996f663371f0f6525015">forceLoadTexture</a> (GraphicsContext &amp;context, const StringHash &amp;filename)</td></tr>
<tr class="memdesc:a8b3bd73158f1996f663371f0f6525015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture from the asset store and cache it and for later use (through getTextureWithCaching). If the texture already exists, it is re-loaded from disk anyway (see loadTexture, where, if a texture is found, it is returned instead of reloaded). Texture format is inferred from the filename. <a href="#a8b3bd73158f1996f663371f0f6525015">More...</a><br/></td></tr>
<tr class="separator:a8b3bd73158f1996f663371f0f6525015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968dc39d1d4745711059eca863467b68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#a968dc39d1d4745711059eca863467b68">getTextureWithCaching</a> (GraphicsContext &amp;context, const StringHash &amp;filename, api::TextureView *outTexture, TextureHeader *outDescriptor)</td></tr>
<tr class="memdesc:a968dc39d1d4745711059eca863467b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture from the asset store, cache it and return a Texture object and/or Descriptor. If the texture is already loaded, return the cached information without loading from disc. <a href="#a968dc39d1d4745711059eca863467b68">More...</a><br/></td></tr>
<tr class="separator:a968dc39d1d4745711059eca863467b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fae9ed954265070d3ee03dec06e0b07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#a7fae9ed954265070d3ee03dec06e0b07">getTextureWithCaching</a> (GraphicsContext &amp;context, const StringHash &amp;filename, TextureFileFormat format, api::TextureView *outTexture, TextureHeader *outDescriptor)</td></tr>
<tr class="memdesc:a7fae9ed954265070d3ee03dec06e0b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture from the asset store, cache it and return a Texture object and/or Descriptor. If the texture is already loaded, return the cached information without loading from disc. <a href="#a7fae9ed954265070d3ee03dec06e0b07">More...</a><br/></td></tr>
<tr class="separator:a7fae9ed954265070d3ee03dec06e0b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708ca41cca22e042ab8fdd63af4a6786"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#a708ca41cca22e042ab8fdd63af4a6786">init</a> (pvr::IPlatformProvider &amp;theShell)</td></tr>
<tr class="memdesc:a708ca41cca22e042ab8fdd63af4a6786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize with the application class (the Shell, hence the Application, is-a IPlatformProvider <a href="#a708ca41cca22e042ab8fdd63af4a6786">More...</a><br/></td></tr>
<tr class="separator:a708ca41cca22e042ab8fdd63af4a6786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba25924df962617fa1914fd4385384c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#aba25924df962617fa1914fd4385384c2">init</a> (IAssetProvider &amp;assetProvider, OSManager &amp;contextProvider)</td></tr>
<tr class="memdesc:aba25924df962617fa1914fd4385384c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize with separate Context and Asset providers. Prefer the other overload if you want to just pass the application. <a href="#aba25924df962617fa1914fd4385384c2">More...</a><br/></td></tr>
<tr class="separator:aba25924df962617fa1914fd4385384c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ea41954003d1bab55d4c9a34a35c14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#a23ea41954003d1bab55d4c9a34a35c14">loadModel</a> (const char *filename, assets::ModelHandle &amp;outModel, bool force=false)</td></tr>
<tr class="memdesc:a23ea41954003d1bab55d4c9a34a35c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load model from file. <a href="#a23ea41954003d1bab55d4c9a34a35c14">More...</a><br/></td></tr>
<tr class="separator:a23ea41954003d1bab55d4c9a34a35c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65126643b2f1dd3f9177e11129319d39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#a65126643b2f1dd3f9177e11129319d39">loadPfx</a> (const char *filename, legacyPfx::EffectApi &amp;outPfx, bool force=false)</td></tr>
<tr class="memdesc:a65126643b2f1dd3f9177e11129319d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pfx. <a href="#a65126643b2f1dd3f9177e11129319d39">More...</a><br/></td></tr>
<tr class="separator:a65126643b2f1dd3f9177e11129319d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f917aada5c6a3d58ac8f9ae53870471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#a7f917aada5c6a3d58ac8f9ae53870471">releaseAll</a> ()</td></tr>
<tr class="memdesc:a7f917aada5c6a3d58ac8f9ae53870471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all assets held by this AssetManager. Best practice is to always call this function in ReleaseView, as any resources held by the AssetManager will be invalid anyway. Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them. <a href="#a7f917aada5c6a3d58ac8f9ae53870471">More...</a><br/></td></tr>
<tr class="separator:a7f917aada5c6a3d58ac8f9ae53870471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbe79bda7e5916a22ffeef3bbf65ebb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#acbbe79bda7e5916a22ffeef3bbf65ebb">releaseModel</a> (const StringHash &amp;modelName)</td></tr>
<tr class="memdesc:acbbe79bda7e5916a22ffeef3bbf65ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any references to a specified Model object that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding. <a href="#acbbe79bda7e5916a22ffeef3bbf65ebb">More...</a><br/></td></tr>
<tr class="separator:acbbe79bda7e5916a22ffeef3bbf65ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18b8c939c132e114a2c2a71e4a7da41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_asset_store.html#ab18b8c939c132e114a2c2a71e4a7da41">releaseTexture</a> (const StringHash &amp;textureName)</td></tr>
<tr class="memdesc:ab18b8c939c132e114a2c2a71e4a7da41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any references to a specified Texture object that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding. <a href="#ab18b8c939c132e114a2c2a71e4a7da41">More...</a><br/></td></tr>
<tr class="separator:ab18b8c939c132e114a2c2a71e4a7da41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manages scene assets. Use this class to easily load assets without needing to worry about duplicates. This class keeps references to assets, so remember to release them if they are no longer required.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a89f5f9f05b056020efb34f8c8db79014"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::utils::AssetStore::AssetStore </td>
          <td>(</td>
          <td class="paramtype">ErrorLogger&#160;</td>
          <td class="paramname"><em>logger</em> = <code>&amp;Logger::static_output</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>A printf-style function pointer which will be used by the class to record errors that happen during any operation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab071f6a2e16fd5b6fc4c01514a5210d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::AssetStore::effectOnLoadTexture </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>outTex2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the AssetLoadingDelegate. Allows this class to be passed to the EffectApi constructor as the effectDelegate to automate loading and uploading of textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureName</td><td>A texture filename to load from a file.</td></tr>
    <tr><td class="paramname">outTex2d</td><td>A handle where the loaded and uploaded texture will be saved.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9f0c02d1345b21d6099937fa6463c71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::AssetStore::findAndReleaseModel </td>
          <td>(</td>
          <td class="paramtype">assets::ModelHandle&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release any references to a specified Model object that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>A handle to the model.</td></tr>
  </table>
  </dd>
</dl>
<p>Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them.</p>

</div>
</div>
<a class="anchor" id="a17b2400795b3fb1c72975c3022ff7e95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::AssetStore::findAndReleaseTexture </td>
          <td>(</td>
          <td class="paramtype">api::TextureView&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release any references to a specified Texture object that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>A texture</td></tr>
  </table>
  </dd>
</dl>
<p>Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them.</p>

</div>
</div>
<a class="anchor" id="afe081d7a9ec90e6941da9ddcd5e7f8b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::AssetStore::forceLoadTexture </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TextureFileFormat&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a texture from the asset store and cache it and for later use (through getTextureWithCaching). If the texture already exists, it is re-loaded from disk anyway (see loadTexture, where, if a texture is found, it is returned instead of reloaded)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context on which the Texture object will be created.</td></tr>
    <tr><td class="paramname">filename</td><td>texture file name</td></tr>
    <tr><td class="paramname">format</td><td>A TextureFileFormat symbolising the file format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful, false if any error occurs.</dd></dl>
<p>This function will look for a previously loaded texture with the specified filename. Texture format is explicit. If the texture is found in the cache, it will be returned from there, otherwise it will be loaded from the platform specific asset store (android asset, windows resource, filesystem etc.). Errors are logged in the AssetManager logger.</p>

</div>
</div>
<a class="anchor" id="a8b3bd73158f1996f663371f0f6525015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::AssetStore::forceLoadTexture </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a texture from the asset store and cache it and for later use (through getTextureWithCaching). If the texture already exists, it is re-loaded from disk anyway (see loadTexture, where, if a texture is found, it is returned instead of reloaded). Texture format is inferred from the filename.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context on which the Texture object will be created.</td></tr>
    <tr><td class="paramname">filename</td><td>texture file name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful, false if any error occurs.</dd></dl>
<p>This function will look for a previously loaded texture with the specified filename. Texture format is explicit. If the texture is found in the cache, it will be returned from there, otherwise it will be loaded from the platform specific asset store (android asset, windows resource, filesystem etc.). Errors are logged in the AssetManager logger.</p>

</div>
</div>
<a class="anchor" id="a968dc39d1d4745711059eca863467b68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::AssetStore::getTextureWithCaching </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::TextureView *&#160;</td>
          <td class="paramname"><em>outTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TextureHeader *&#160;</td>
          <td class="paramname"><em>outDescriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a texture from the asset store, cache it and return a Texture object and/or Descriptor. If the texture is already loaded, return the cached information without loading from disc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context on which the Texture object will be created.</td></tr>
    <tr><td class="paramname">filename</td><td>texture file name</td></tr>
    <tr><td class="paramname">outTexture</td><td>Optional (set NULL to ignore) : A api::Texture2D object into which the texture object is returned</td></tr>
    <tr><td class="paramname">outDescriptor</td><td>Optional (set NULL to ignore) : A TextureHeader object into which the texture metadata is returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful, false if any error occurs.</dd></dl>
<p>This function will look for a previously loaded texture with the specified filename. Texture format is inferred from the filename. If the texture is found in the cache, it will be returned from there, otherwise it will be loaded from the platform specific asset store. Errors are logged in the AssetManager logger. </p>

</div>
</div>
<a class="anchor" id="a7fae9ed954265070d3ee03dec06e0b07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::AssetStore::getTextureWithCaching </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TextureFileFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::TextureView *&#160;</td>
          <td class="paramname"><em>outTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TextureHeader *&#160;</td>
          <td class="paramname"><em>outDescriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a texture from the asset store, cache it and return a Texture object and/or Descriptor. If the texture is already loaded, return the cached information without loading from disc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context on which the Texture object will be created.</td></tr>
    <tr><td class="paramname">filename</td><td>texture file name</td></tr>
    <tr><td class="paramname">format</td><td>A TextureFileFormat symbolising the file format.</td></tr>
    <tr><td class="paramname">outTexture</td><td>Optional (set NULL to ignore) : A api::Texture2D object into which the texture object is returned</td></tr>
    <tr><td class="paramname">outDescriptor</td><td>Optional (set NULL to ignore) : A TextureHeader object into which the texture metadata is returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful, false if any error occurs.</dd></dl>
<p>This function will look for a previously loaded texture with the specified filename. Texture format is explicit. If the texture is found in the cache, it will be returned from there, otherwise it will be loaded from the platform specific asset store (android asset, windows resource, filesystem etc.). Errors are logged in the AssetManager logger.</p>

</div>
</div>
<a class="anchor" id="a708ca41cca22e042ab8fdd63af4a6786"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::AssetStore::init </td>
          <td>(</td>
          <td class="paramtype">pvr::IPlatformProvider &amp;&#160;</td>
          <td class="paramname"><em>theShell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize with the application class (the Shell, hence the Application, is-a IPlatformProvider</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theShell</td><td>The IAssetProvider that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> will use to load the requested assets from disk. pvr::Shell implements the <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> interface, so normally the instance of the Application Class will be passed here.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba25924df962617fa1914fd4385384c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::AssetStore::init </td>
          <td>(</td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OSManager &amp;&#160;</td>
          <td class="paramname"><em>contextProvider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize with separate Context and Asset providers. Prefer the other overload if you want to just pass the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assetProvider</td><td>The IAssetProvider that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> will use to load the requested assets from disk. pvr::Shell implements the <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> interface, so normally the instance of the Application Class will be passed here.</td></tr>
    <tr><td class="paramname">contextProvider</td><td>The ContextProvider that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> will use to get a graphics context when required.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23ea41954003d1bab55d4c9a34a35c14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::AssetStore::loadModel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::ModelHandle &amp;&#160;</td>
          <td class="paramname"><em>outModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load model from file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Model file name</td></tr>
    <tr><td class="paramname">outModel</td><td>A reference to a ModelHandle object. The model will be loaded there.</td></tr>
    <tr><td class="paramname">force</td><td>(Default false) If true, will force loading the asset from the file, even if it is already cached by the <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful, false if any error occurs.</dd></dl>

</div>
</div>
<a class="anchor" id="a65126643b2f1dd3f9177e11129319d39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::AssetStore::loadPfx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">legacyPfx::EffectApi &amp;&#160;</td>
          <td class="paramname"><em>outPfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load pfx.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename of the pfx.</td></tr>
    <tr><td class="paramname">outPfx</td><td>The PFX effect will be loaded into this Effect object.</td></tr>
    <tr><td class="paramname">force</td><td>(Default false) If true, will force loading the asset from the file, even if it is already cached by the <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return true if load success, else error</dd></dl>

</div>
</div>
<a class="anchor" id="a7f917aada5c6a3d58ac8f9ae53870471"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::AssetStore::releaseAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release all assets held by this AssetManager. Best practice is to always call this function in ReleaseView, as any resources held by the AssetManager will be invalid anyway. Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them.</p>

</div>
</div>
<a class="anchor" id="acbbe79bda7e5916a22ffeef3bbf65ebb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::AssetStore::releaseModel </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>modelName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release any references to a specified Model object that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modelName</td><td>The filename of the model to release.</td></tr>
  </table>
  </dd>
</dl>
<p>Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them.</p>

</div>
</div>
<a class="anchor" id="ab18b8c939c132e114a2c2a71e4a7da41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::AssetStore::releaseTexture </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>textureName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release any references to a specified Texture object that this <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureName</td><td>The filename of a texture</td></tr>
  </table>
  </dd>
</dl>
<p>Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1utils_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVREngineUtils/<a class="el" href="_asset_store_8h_source.html">AssetStore.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
