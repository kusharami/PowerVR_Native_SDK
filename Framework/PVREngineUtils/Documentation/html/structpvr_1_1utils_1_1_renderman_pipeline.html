<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVREngineUtils: pvr::utils::RendermanPipeline Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVREngineUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html">RendermanPipeline</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structpvr_1_1utils_1_1_renderman_pipeline-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils::RendermanPipeline Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Part of RendermanStructure. This class is a cooked EffectPipeline, exactly mirroring the PFX pipelines. It is affected on creation time by the meshes that use it (for the Vertex Input configuration) but after that it is used for rendering directly when traversing the scene. 
 <a href="structpvr_1_1utils_1_1_renderman_pipeline.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a76e28b05a02effe9f82fb88d86d7df2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html">RendermanEffect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a76e28b05a02effe9f82fb88d86d7df2d">backToRendermanEffect</a> ()</td></tr>
<tr class="memdesc:a76e28b05a02effe9f82fb88d86d7df2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate (in the Rendering structure) to the Renderman Effect this object belongs to <a href="#a76e28b05a02effe9f82fb88d86d7df2d">More...</a><br/></td></tr>
<tr class="separator:a76e28b05a02effe9f82fb88d86d7df2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72fa0887675b06b33d79bcefd4dc6c1"><td class="memItemLeft" align="right" valign="top">RendermanSubpass &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#aa72fa0887675b06b33d79bcefd4dc6c1">backToSubpass</a> ()</td></tr>
<tr class="memdesc:aa72fa0887675b06b33d79bcefd4dc6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate (in the Rendering structure) to the Renderman Pass this object belongs to <a href="#aa72fa0887675b06b33d79bcefd4dc6c1">More...</a><br/></td></tr>
<tr class="separator:aa72fa0887675b06b33d79bcefd4dc6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e43f3b9f495bc962e008691d3bb3919"><td class="memItemLeft" align="right" valign="top">RendermanSubpassGroup &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a8e43f3b9f495bc962e008691d3bb3919">backToSubpassGroup</a> ()</td></tr>
<tr class="memdesc:a8e43f3b9f495bc962e008691d3bb3919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate (in the Rendering structure) to the Renderman Subpass this object belongs to <a href="#a8e43f3b9f495bc962e008691d3bb3919">More...</a><br/></td></tr>
<tr class="separator:a8e43f3b9f495bc962e008691d3bb3919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fd7d71c49e529bb69e08b20e61903a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#ac3fd7d71c49e529bb69e08b20e61903a">createAutomaticModelSemantics</a> (uint32 useMainModelId=0)</td></tr>
<tr class="memdesc:ac3fd7d71c49e529bb69e08b20e61903a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a list of all the semantics that this pipeline requires, that are defined per-Model (e.g. V/VP matrices, light positions etc). Then, searches the connected asset Model for these semantics, and creates connections between them so that when updateAutomaticSemantics is called, the new values are updated in the semantics so that they can be read (with setUniformPtr, or updating buffers etc.). <a href="#ac3fd7d71c49e529bb69e08b20e61903a">More...</a><br/></td></tr>
<tr class="separator:ac3fd7d71c49e529bb69e08b20e61903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ba72d56559ad41d44057f5ae768b39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a96ba72d56559ad41d44057f5ae768b39">recordUpdateAllUniformEffectSemantics</a> (api::CommandBufferBase cbuff)</td></tr>
<tr class="memdesc:a96ba72d56559ad41d44057f5ae768b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform updating commands (setUniformPtr) for all Effect scope uniform semantics The commands will read the values from the built-in Semantics objects. <a href="#a96ba72d56559ad41d44057f5ae768b39">More...</a><br/></td></tr>
<tr class="separator:a96ba72d56559ad41d44057f5ae768b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637e67cabb67580398565cf5636bd2d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a637e67cabb67580398565cf5636bd2d4">recordUpdateAllUniformModelSemantics</a> (api::CommandBufferBase cbuff)</td></tr>
<tr class="memdesc:a637e67cabb67580398565cf5636bd2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform updating commands (setUniformPtr) for all Model scope uniform semantics The commands will read the values from the built-in Semantics objects. <a href="#a637e67cabb67580398565cf5636bd2d4">More...</a><br/></td></tr>
<tr class="separator:a637e67cabb67580398565cf5636bd2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee6a6116e29f1b9b2ac3ca7bd25f4d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#afee6a6116e29f1b9b2ac3ca7bd25f4d9">recordUpdateAllUniformNodeSemantics</a> (api::CommandBufferBase cbuff, RendermanNode &amp;node)</td></tr>
<tr class="memdesc:afee6a6116e29f1b9b2ac3ca7bd25f4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform updating commands (setUniformPtr) for a specific Node The commands will read the values from the built-in Semantics objects. <a href="#afee6a6116e29f1b9b2ac3ca7bd25f4d9">More...</a><br/></td></tr>
<tr class="separator:afee6a6116e29f1b9b2ac3ca7bd25f4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4482403743f141ee9e7d0ad79c6017e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#aa4482403743f141ee9e7d0ad79c6017e">recordUpdateAllUniformSemantics</a> (api::CommandBufferBase cbuff)</td></tr>
<tr class="memdesc:aa4482403743f141ee9e7d0ad79c6017e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform updating commands (setUniformPtr) for all the uniform semantics of this pipeline, including Effect and Model semantics, but excluding node semantics. The commands will read the values from the built-in Semantics objects. <a href="#aa4482403743f141ee9e7d0ad79c6017e">More...</a><br/></td></tr>
<tr class="separator:aa4482403743f141ee9e7d0ad79c6017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e504aa4b3f16405ab303bdbe0a3955e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a4e504aa4b3f16405ab303bdbe0a3955e">recordUpdateUniformCommandsEffectSemantic</a> (api::CommandBufferBase cbuff, const StringHash &amp;semantic)</td></tr>
<tr class="memdesc:a4e504aa4b3f16405ab303bdbe0a3955e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform update commands (setUniformPtr) for a specific Effect semantic The commands will read the values from the built-in Semantics objects. <a href="#a4e504aa4b3f16405ab303bdbe0a3955e">More...</a><br/></td></tr>
<tr class="separator:a4e504aa4b3f16405ab303bdbe0a3955e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abdf24ab0fcf33e3d501c99589e8064"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a7abdf24ab0fcf33e3d501c99589e8064">recordUpdateUniformCommandsModelSemantic</a> (api::CommandBufferBase cbuff, const StringHash &amp;semantic)</td></tr>
<tr class="memdesc:a7abdf24ab0fcf33e3d501c99589e8064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform update commands (setUniformPtr) for a specific Model semantic The commands will read the values from the built-in Semantics objects. <a href="#a7abdf24ab0fcf33e3d501c99589e8064">More...</a><br/></td></tr>
<tr class="separator:a7abdf24ab0fcf33e3d501c99589e8064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bd1e598899d27bd0a815113b20e7d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a31bd1e598899d27bd0a815113b20e7d3">recordUpdateUniformCommandsNodeSemantic</a> (api::CommandBufferBase cbuff, const StringHash &amp;semantic, RendermanNode &amp;node)</td></tr>
<tr class="memdesc:a31bd1e598899d27bd0a815113b20e7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Uniform update commands (setUniformPtr) for a specific Node semantic <a href="#a31bd1e598899d27bd0a815113b20e7d3">More...</a><br/></td></tr>
<tr class="separator:a31bd1e598899d27bd0a815113b20e7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507bf08cf242dc1e23e109e4173cdef4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a507bf08cf242dc1e23e109e4173cdef4">updateAutomaticModelSemantics</a> (uint32 swapIdx)</td></tr>
<tr class="memdesc:a507bf08cf242dc1e23e109e4173cdef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of all automatic per-Model semantics. The values are updated immediately in the corresponding buffer, and where the Uniform values are located, but Uniform values will only be visible in rendering when the recorded update uniform commands are executed (i.e. the commands generated by recordUpdateUniformCommandsXXXXX) <a href="#a507bf08cf242dc1e23e109e4173cdef4">More...</a><br/></td></tr>
<tr class="separator:a507bf08cf242dc1e23e109e4173cdef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5df2fff3ae0a75bac9e24032e4cd27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a2f5df2fff3ae0a75bac9e24032e4cd27">updateBufferEntryEffectSemantic</a> (const StringHash &amp;semantic, const FreeValue &amp;value, uint32 swapid, uint32 dynamicClientId=0)</td></tr>
<tr class="memdesc:a2f5df2fff3ae0a75bac9e24032e4cd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update buffer entry effect semantic.  <a href="#a2f5df2fff3ae0a75bac9e24032e4cd27">More...</a><br/></td></tr>
<tr class="separator:a2f5df2fff3ae0a75bac9e24032e4cd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3759c7e0fb2f519eed1260eff83ebc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a8f3759c7e0fb2f519eed1260eff83ebc">updateBufferEntryEffectSemantics</a> (const StringHash *semantics, const FreeValue *values, uint32 numSemantics, uint32 swapid, uint32 dynamicClientId=0)</td></tr>
<tr class="memdesc:a8f3759c7e0fb2f519eed1260eff83ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of multiple per-Effect Buffer Entry semantic. The values is updated immediately in the corresponding buffer. The dynamic client id of the buffer (i.e. the Offset into the dynamic buffer) is automatically retrieved from the Node. <a href="#a8f3759c7e0fb2f519eed1260eff83ebc">More...</a><br/></td></tr>
<tr class="separator:a8f3759c7e0fb2f519eed1260eff83ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900670346e30e8adf35453a4b3fcd8d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a900670346e30e8adf35453a4b3fcd8d1">updateBufferEntryModelSemantic</a> (const StringHash &amp;semantic, const FreeValue &amp;value, uint32 swapid, uint32 dynamicClientId=0)</td></tr>
<tr class="memdesc:a900670346e30e8adf35453a4b3fcd8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a per-Model Buffer Entry semantic. The value is updated immediately in the corresponding buffer. <a href="#a900670346e30e8adf35453a4b3fcd8d1">More...</a><br/></td></tr>
<tr class="separator:a900670346e30e8adf35453a4b3fcd8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27792ef6836185b6d43e684ac946d2f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a27792ef6836185b6d43e684ac946d2f6">updateBufferEntryModelSemantics</a> (const StringHash *semantics, const FreeValue *values, uint32 numSemantics, uint32 swapid, uint32 dynamicClientId)</td></tr>
<tr class="memdesc:a27792ef6836185b6d43e684ac946d2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of multiple per-Effect Buffer Entry semantics. The values are updated immediately in the corresponding buffer. <a href="#a27792ef6836185b6d43e684ac946d2f6">More...</a><br/></td></tr>
<tr class="separator:a27792ef6836185b6d43e684ac946d2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1455ca010c14baa5c61075ea1b00da5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#af1455ca010c14baa5c61075ea1b00da5">updateBufferEntryNodeSemantic</a> (const StringHash &amp;semantic, const FreeValue &amp;value, uint32 swapid, RendermanNode &amp;node)</td></tr>
<tr class="memdesc:af1455ca010c14baa5c61075ea1b00da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a per-Node Buffer Entry semantic. The value is updated immediately in the corresponding buffer. The dynamic client id of the buffer (i.e. the Offset into the dynamic buffer) is automatically retrieved from the Node. <a href="#af1455ca010c14baa5c61075ea1b00da5">More...</a><br/></td></tr>
<tr class="separator:af1455ca010c14baa5c61075ea1b00da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c03bc0a49ac38f989a80d1a9d7d588d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a0c03bc0a49ac38f989a80d1a9d7d588d">updateBufferEntrySemantic</a> (const StringHash &amp;semantic, const FreeValue &amp;value, uint32 swapid, uint32 dynamicClientId=0)</td></tr>
<tr class="memdesc:a0c03bc0a49ac38f989a80d1a9d7d588d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a per-Effect or Per-Model Buffer Entry semantic. The value is updated immediately in the corresponding buffer. <a href="#a0c03bc0a49ac38f989a80d1a9d7d588d">More...</a><br/></td></tr>
<tr class="separator:a0c03bc0a49ac38f989a80d1a9d7d588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad8a898577f0a8d0bc27769b95b1c44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#adad8a898577f0a8d0bc27769b95b1c44">updateUniformEffectSemantic</a> (const StringHash &amp;semantic, const TypedMem &amp;value)</td></tr>
<tr class="memdesc:adad8a898577f0a8d0bc27769b95b1c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of an Effect Uniform semantic (the updated value will be read when the corresponding recorded update command is executed). <a href="#adad8a898577f0a8d0bc27769b95b1c44">More...</a><br/></td></tr>
<tr class="separator:adad8a898577f0a8d0bc27769b95b1c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58445a5ef6ad908c74e918eba705c61c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a58445a5ef6ad908c74e918eba705c61c">updateUniformModelSemantic</a> (const StringHash &amp;semantic, const TypedMem &amp;value)</td></tr>
<tr class="memdesc:a58445a5ef6ad908c74e918eba705c61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a Model Uniform semantic (the updated value will be read when the corresponding recorded update command is executed). <a href="#a58445a5ef6ad908c74e918eba705c61c">More...</a><br/></td></tr>
<tr class="separator:a58445a5ef6ad908c74e918eba705c61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dac10c764b31422cf493358ad69efb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_pipeline.html#a12dac10c764b31422cf493358ad69efb">updateUniformNodeSemantic</a> (const StringHash &amp;semantic, const TypedMem &amp;value, RendermanNode &amp;node)</td></tr>
<tr class="memdesc:a12dac10c764b31422cf493358ad69efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of a per-Node Uniform semantic (the updated value will be read when the corresponding recorded update command is executed). <a href="#a12dac10c764b31422cf493358ad69efb">More...</a><br/></td></tr>
<tr class="separator:a12dac10c764b31422cf493358ad69efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Part of RendermanStructure. This class is a cooked EffectPipeline, exactly mirroring the PFX pipelines. It is affected on creation time by the meshes that use it (for the Vertex Input configuration) but after that it is used for rendering directly when traversing the scene.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a76e28b05a02effe9f82fb88d86d7df2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html">RendermanEffect</a> &amp; pvr::utils::RendermanPipeline::backToRendermanEffect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Navigate (in the Rendering structure) to the Renderman Effect this object belongs to</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the Renderman Effect this object belongs to</dd></dl>

</div>
</div>
<a class="anchor" id="aa72fa0887675b06b33d79bcefd4dc6c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RendermanSubpass &amp; pvr::utils::RendermanPipeline::backToSubpass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Navigate (in the Rendering structure) to the Renderman Pass this object belongs to</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the Renderman Pass this object belongs to</dd></dl>

</div>
</div>
<a class="anchor" id="a8e43f3b9f495bc962e008691d3bb3919"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RendermanSubpassGroup &amp; pvr::utils::RendermanPipeline::backToSubpassGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Navigate (in the Rendering structure) to the Renderman Subpass this object belongs to</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the Renderman Subpass this object belongs to</dd></dl>

</div>
</div>
<a class="anchor" id="ac3fd7d71c49e529bb69e08b20e61903a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::createAutomaticModelSemantics </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>useMainModelId</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a list of all the semantics that this pipeline requires, that are defined per-Model (e.g. V/VP matrices, light positions etc). Then, searches the connected asset Model for these semantics, and creates connections between them so that when updateAutomaticSemantics is called, the new values are updated in the semantics so that they can be read (with setUniformPtr, or updating buffers etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useMainModelId</td><td>The model ID to use to read the values from. Default O (the first model). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false on any error</dd></dl>

</div>
</div>
<a class="anchor" id="a96ba72d56559ad41d44057f5ae768b39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanPipeline::recordUpdateAllUniformEffectSemantics </td>
          <td>(</td>
          <td class="paramtype">api::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Uniform updating commands (setUniformPtr) for all Effect scope uniform semantics The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a637e67cabb67580398565cf5636bd2d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanPipeline::recordUpdateAllUniformModelSemantics </td>
          <td>(</td>
          <td class="paramtype">api::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Uniform updating commands (setUniformPtr) for all Model scope uniform semantics The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afee6a6116e29f1b9b2ac3ca7bd25f4d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanPipeline::recordUpdateAllUniformNodeSemantics </td>
          <td>(</td>
          <td class="paramtype">api::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RendermanNode &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Uniform updating commands (setUniformPtr) for a specific Node The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
    <tr><td class="paramname">node</td><td>The node to record commands for</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4482403743f141ee9e7d0ad79c6017e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanPipeline::recordUpdateAllUniformSemantics </td>
          <td>(</td>
          <td class="paramtype">api::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Uniform updating commands (setUniformPtr) for all the uniform semantics of this pipeline, including Effect and Model semantics, but excluding node semantics. The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e504aa4b3f16405ab303bdbe0a3955e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::recordUpdateUniformCommandsEffectSemantic </td>
          <td>(</td>
          <td class="paramtype">api::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Uniform update commands (setUniformPtr) for a specific Effect semantic The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
    <tr><td class="paramname">semantic</td><td>The effect semantic to update</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success</dd></dl>

</div>
</div>
<a class="anchor" id="a7abdf24ab0fcf33e3d501c99589e8064"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::recordUpdateUniformCommandsModelSemantic </td>
          <td>(</td>
          <td class="paramtype">api::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Uniform update commands (setUniformPtr) for a specific Model semantic The commands will read the values from the built-in Semantics objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
    <tr><td class="paramname">semantic</td><td>The Model semantic to update</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>

</div>
</div>
<a class="anchor" id="a31bd1e598899d27bd0a815113b20e7d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::recordUpdateUniformCommandsNodeSemantic </td>
          <td>(</td>
          <td class="paramtype">api::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RendermanNode &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate Uniform update commands (setUniformPtr) for a specific Node semantic</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A command buffer to record the commands to</td></tr>
    <tr><td class="paramname">semantic</td><td>The effect semantic to update</td></tr>
    <tr><td class="paramname">node</td><td>The node whose semantics to update</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success</dd></dl>

</div>
</div>
<a class="anchor" id="a507bf08cf242dc1e23e109e4173cdef4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateAutomaticModelSemantics </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of all automatic per-Model semantics. The values are updated immediately in the corresponding buffer, and where the Uniform values are located, but Uniform values will only be visible in rendering when the recorded update uniform commands are executed (i.e. the commands generated by recordUpdateUniformCommandsXXXXX)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapIdx</td><td>The swapchain index to generate commands for (ignored for Uniforms)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false on any error</dd></dl>

</div>
</div>
<a class="anchor" id="a2f5df2fff3ae0a75bac9e24032e4cd27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryEffectSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dynamicClientId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update buffer entry effect semantic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>Effect semantic to update </td></tr>
    <tr><td class="paramname">value</td><td>New value </td></tr>
    <tr><td class="paramname">swapid</td><td>swapchain id </td></tr>
    <tr><td class="paramname">dynamicClientId</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success </dd></dl>

</div>
</div>
<a class="anchor" id="a8f3759c7e0fb2f519eed1260eff83ebc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryEffectSemantics </td>
          <td>(</td>
          <td class="paramtype">const StringHash *&#160;</td>
          <td class="paramname"><em>semantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numSemantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dynamicClientId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of multiple per-Effect Buffer Entry semantic. The values is updated immediately in the corresponding buffer. The dynamic client id of the buffer (i.e. the Offset into the dynamic buffer) is automatically retrieved from the Node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantics</td><td>A c-style array of Semantic names. Must point to at least <em>numSemantics</em> elements</td></tr>
    <tr><td class="paramname">values</td><td>A c-style array of the Values to set. Must point to at least <em>numSemantics</em> elements</td></tr>
    <tr><td class="paramname">numSemantics</td><td>The number of semantics to set</td></tr>
    <tr><td class="paramname">swapid</td><td>The current swapchain index</td></tr>
    <tr><td class="paramname">dynamicClientId</td><td>(Optional) In the case of a Dynamic buffer, the "dynamic client id" is the index of the "slice" of the buffer. Built-in functionality does NOT use this parameter for either Effect or Model semantics. Default 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="a900670346e30e8adf35453a4b3fcd8d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryModelSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dynamicClientId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of a per-Model Buffer Entry semantic. The value is updated immediately in the corresponding buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Model semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value to set</td></tr>
    <tr><td class="paramname">swapid</td><td>The current swapchain index</td></tr>
    <tr><td class="paramname">dynamicClientId</td><td>(Optional) In the case of a Dynamic buffer, the "dynamic client id" is the index of the "slice" of the buffer. Built-in functionality does NOT use this parameter for Model semantics. Default 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="a27792ef6836185b6d43e684ac946d2f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryModelSemantics </td>
          <td>(</td>
          <td class="paramtype">const StringHash *&#160;</td>
          <td class="paramname"><em>semantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numSemantics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dynamicClientId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of multiple per-Effect Buffer Entry semantics. The values are updated immediately in the corresponding buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantics</td><td>The Effect semantic to update</td></tr>
    <tr><td class="paramname">values</td><td>The new values to set</td></tr>
    <tr><td class="paramname">numSemantics</td><td>The number of semantics to set.</td></tr>
    <tr><td class="paramname">swapid</td><td>The current swapchain index</td></tr>
    <tr><td class="paramname">dynamicClientId</td><td>(Optional) In the case of a Dynamic buffer, the "dynamic client id" is the index of the "slice" of the buffer. Built-in functionality does NOT use this parameter for Effect semantics. Default 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="af1455ca010c14baa5c61075ea1b00da5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntryNodeSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RendermanNode &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of a per-Node Buffer Entry semantic. The value is updated immediately in the corresponding buffer. The dynamic client id of the buffer (i.e. the Offset into the dynamic buffer) is automatically retrieved from the Node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Node semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value to set</td></tr>
    <tr><td class="paramname">swapid</td><td>The current swapchain index</td></tr>
    <tr><td class="paramname">node</td><td>The RendermanNode for which to set the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="a0c03bc0a49ac38f989a80d1a9d7d588d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateBufferEntrySemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dynamicClientId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of a per-Effect or Per-Model Buffer Entry semantic. The value is updated immediately in the corresponding buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Effect or Model semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value to set</td></tr>
    <tr><td class="paramname">swapid</td><td>The current swapchain index</td></tr>
    <tr><td class="paramname">dynamicClientId</td><td>(Optional) In the case of a Dynamic buffer, the "dynamic client id" is the index of the "slice" of the buffer. Built-in functionality does NOT use this parameter for either Effect or Model semantics. Default 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if the semantic is not found.</dd></dl>

</div>
</div>
<a class="anchor" id="adad8a898577f0a8d0bc27769b95b1c44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateUniformEffectSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypedMem &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of an Effect Uniform semantic (the updated value will be read when the corresponding recorded update command is executed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Effect semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value, contained in a TypedMem object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if the semantic is not found</dd></dl>

</div>
</div>
<a class="anchor" id="a58445a5ef6ad908c74e918eba705c61c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateUniformModelSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypedMem &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of a Model Uniform semantic (the updated value will be read when the corresponding recorded update command is executed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Model semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value, contained in a TypedMem object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if the semantic is not found</dd></dl>

</div>
</div>
<a class="anchor" id="a12dac10c764b31422cf493358ad69efb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::RendermanPipeline::updateUniformNodeSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypedMem &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RendermanNode &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of a per-Node Uniform semantic (the updated value will be read when the corresponding recorded update command is executed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The Node semantic to update</td></tr>
    <tr><td class="paramname">value</td><td>The new value, contained in a TypedMem object.</td></tr>
    <tr><td class="paramname">node</td><td>The Node for which to update the uniform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if the semantic is not found</dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVREngineUtils/<a class="el" href="_render_manager_8h_source.html">RenderManager.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
