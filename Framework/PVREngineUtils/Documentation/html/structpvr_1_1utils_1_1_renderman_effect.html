<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVREngineUtils: pvr::utils::RendermanEffect Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVREngineUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html">RendermanEffect</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structpvr_1_1utils_1_1_renderman_effect-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils::RendermanEffect Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Part of RendermanStructure. This class contains the different passes, exactly mirroring the PFX effect. Contains the original EffectApi. 
 <a href="structpvr_1_1utils_1_1_renderman_effect.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7e36be21f5a4c7e98001fc2af7917c3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html#a7e36be21f5a4c7e98001fc2af7917c3b">RendermanEffect</a> ()</td></tr>
<tr class="memdesc:a7e36be21f5a4c7e98001fc2af7917c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor <a href="#a7e36be21f5a4c7e98001fc2af7917c3b">More...</a><br/></td></tr>
<tr class="separator:a7e36be21f5a4c7e98001fc2af7917c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ebc15a47837585545a74d371f1c0ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1utils_1_1_render_manager.html">RenderManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html#ae0ebc15a47837585545a74d371f1c0ea">backToRenderManager</a> () const </td></tr>
<tr class="memdesc:ae0ebc15a47837585545a74d371f1c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classpvr_1_1utils_1_1_render_manager.html" title="The RenderManager is a rendering automation class, with class responsibilities such as: - Putting tog...">RenderManager</a> which owns this object (const) <a href="#ae0ebc15a47837585545a74d371f1c0ea">More...</a><br/></td></tr>
<tr class="separator:ae0ebc15a47837585545a74d371f1c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b029685d69fe05a9f325022f4df033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1utils_1_1_render_manager.html">RenderManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html#a65b029685d69fe05a9f325022f4df033">backToRenderManager</a> ()</td></tr>
<tr class="memdesc:a65b029685d69fe05a9f325022f4df033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classpvr_1_1utils_1_1_render_manager.html" title="The RenderManager is a rendering automation class, with class responsibilities such as: - Putting tog...">RenderManager</a> which owns this object (const) <a href="#a65b029685d69fe05a9f325022f4df033">More...</a><br/></td></tr>
<tr class="separator:a65b029685d69fe05a9f325022f4df033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e8bf95ae82f96ad526a660b82c041a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html#a26e8bf95ae82f96ad526a660b82c041a">beginBufferUpdates</a> (uint32 swapChainIndex)</td></tr>
<tr class="memdesc:a26e8bf95ae82f96ad526a660b82c041a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signify that there will be a batch of (buffer) updates, so that any possible buffers that are updated are only mapped and unmapped once. If you do NOT call this method before updating, the buffers will be mapped and unmapped with every single operation. <a href="#a26e8bf95ae82f96ad526a660b82c041a">More...</a><br/></td></tr>
<tr class="separator:a26e8bf95ae82f96ad526a660b82c041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113e532d0d299c8e7a3df33d64b7e0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html#a113e532d0d299c8e7a3df33d64b7e0c3">createAutomaticSemantics</a> ()</td></tr>
<tr class="memdesc:a113e532d0d299c8e7a3df33d64b7e0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all semantic list connections for all subobjects of this effect (passes-&gt;subpasses-&gt;pipelines, nodes) by recursively calling createAutomaticSemantics on all passes. This function must have been called to be able to call updateAutomaticSemantics afterwards. <a href="#a113e532d0d299c8e7a3df33d64b7e0c3">More...</a><br/></td></tr>
<tr class="separator:a113e532d0d299c8e7a3df33d64b7e0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b45a1306f94c187bc0df1951f0c094f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html#a5b45a1306f94c187bc0df1951f0c094f">endBufferUpdates</a> (uint32 swapChainIndex)</td></tr>
<tr class="memdesc:a5b45a1306f94c187bc0df1951f0c094f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signify that the updates for the specified swapchain index have finished. Any and all mapped buffers will now be unmapped (once). If you do not call this function after you have called beginBufferUpdates, the data in your buffers are undefined. <a href="#a5b45a1306f94c187bc0df1951f0c094f">More...</a><br/></td></tr>
<tr class="separator:a5b45a1306f94c187bc0df1951f0c094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad344c6152a80ad2ef49b161e63aabbae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html#ad344c6152a80ad2ef49b161e63aabbae">recordRenderingCommands</a> (api::CommandBuffer &amp;cbuff, uint16 swapIdx, bool beginEnderRenderPasses, bool recordUpdateUniforms=true)</td></tr>
<tr class="memdesc:ad344c6152a80ad2ef49b161e63aabbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the commands necessary to render this entire Effect (for pass, subpass, node: bind pipeline, descriptor sets, draw commands etc.) into a Primary command buffer (secondary command buffers cannot be used at this level) <a href="#ad344c6152a80ad2ef49b161e63aabbae">More...</a><br/></td></tr>
<tr class="separator:ad344c6152a80ad2ef49b161e63aabbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a486515f13c0fbaef1bfa9e4e09ff3"><td class="memItemLeft" align="right" valign="top">RendermanPass &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html#ab0a486515f13c0fbaef1bfa9e4e09ff3">toRendermanPass</a> (uint16 toPass)</td></tr>
<tr class="memdesc:ab0a486515f13c0fbaef1bfa9e4e09ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate to a RendermanPass object of this effect by the pass ID <a href="#ab0a486515f13c0fbaef1bfa9e4e09ff3">More...</a><br/></td></tr>
<tr class="separator:ab0a486515f13c0fbaef1bfa9e4e09ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1101d4eaac2f93754ae5d1948a6b93c4"><td class="memItemLeft" align="right" valign="top">const RendermanPass &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html#a1101d4eaac2f93754ae5d1948a6b93c4">toRendermanPass</a> (uint16 toPass) const </td></tr>
<tr class="memdesc:a1101d4eaac2f93754ae5d1948a6b93c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Navigate to a RendermanPass object of this effect by the pass ID <a href="#a1101d4eaac2f93754ae5d1948a6b93c4">More...</a><br/></td></tr>
<tr class="separator:a1101d4eaac2f93754ae5d1948a6b93c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fd93e0dbf2420edf86856c1b7bbd31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_renderman_effect.html#a01fd93e0dbf2420edf86856c1b7bbd31">updateAutomaticSemantics</a> (uint32 swapidx)</td></tr>
<tr class="memdesc:a01fd93e0dbf2420edf86856c1b7bbd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates all the nodes semantics per-effect, per-pass, per-subpass, per-model, per-node, and updates their values to their updated per-node values. CreateAutomaticSemantics must have been called otherwise no semantics will have been generated. <a href="#a01fd93e0dbf2420edf86856c1b7bbd31">More...</a><br/></td></tr>
<tr class="separator:a01fd93e0dbf2420edf86856c1b7bbd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Part of RendermanStructure. This class contains the different passes, exactly mirroring the PFX effect. Contains the original EffectApi.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7e36be21f5a4c7e98001fc2af7917c3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::utils::RendermanEffect::RendermanEffect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae0ebc15a47837585545a74d371f1c0ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1utils_1_1_render_manager.html">RenderManager</a> &amp; pvr::utils::RendermanEffect::backToRenderManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classpvr_1_1utils_1_1_render_manager.html" title="The RenderManager is a rendering automation class, with class responsibilities such as: - Putting tog...">RenderManager</a> which owns this object (const)</p>
<dl class="section return"><dt>Returns</dt><dd>The root <a class="el" href="classpvr_1_1utils_1_1_render_manager.html" title="The RenderManager is a rendering automation class, with class responsibilities such as: - Putting tog...">RenderManager</a> object</dd></dl>

</div>
</div>
<a class="anchor" id="a65b029685d69fe05a9f325022f4df033"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1utils_1_1_render_manager.html">RenderManager</a> &amp; pvr::utils::RendermanEffect::backToRenderManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classpvr_1_1utils_1_1_render_manager.html" title="The RenderManager is a rendering automation class, with class responsibilities such as: - Putting tog...">RenderManager</a> which owns this object (const)</p>
<dl class="section return"><dt>Returns</dt><dd>The root <a class="el" href="classpvr_1_1utils_1_1_render_manager.html" title="The RenderManager is a rendering automation class, with class responsibilities such as: - Putting tog...">RenderManager</a> object</dd></dl>

</div>
</div>
<a class="anchor" id="a26e8bf95ae82f96ad526a660b82c041a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanEffect::beginBufferUpdates </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapChainIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signify that there will be a batch of (buffer) updates, so that any possible buffers that are updated are only mapped and unmapped once. If you do NOT call this method before updating, the buffers will be mapped and unmapped with every single operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapChainIndex</td><td>The swapchain index to be updated.</td></tr>
  </table>
  </dd>
</dl>
<p>Unless really doing a one-off operation, always call this function before calling any of the updateAutomaticSemantics and similar operations</p>

</div>
</div>
<a class="anchor" id="a113e532d0d299c8e7a3df33d64b7e0c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanEffect::createAutomaticSemantics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all semantic list connections for all subobjects of this effect (passes-&gt;subpasses-&gt;pipelines, nodes) by recursively calling createAutomaticSemantics on all passes. This function must have been called to be able to call updateAutomaticSemantics afterwards.</p>

</div>
</div>
<a class="anchor" id="a5b45a1306f94c187bc0df1951f0c094f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanEffect::endBufferUpdates </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapChainIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signify that the updates for the specified swapchain index have finished. Any and all mapped buffers will now be unmapped (once). If you do not call this function after you have called beginBufferUpdates, the data in your buffers are undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapChainIndex</td><td>The swapchain index to be updated.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad344c6152a80ad2ef49b161e63aabbae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanEffect::recordRenderingCommands </td>
          <td>(</td>
          <td class="paramtype">api::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>cbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>swapIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>beginEnderRenderPasses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recordUpdateUniforms</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the commands necessary to render this entire Effect (for pass, subpass, node: bind pipeline, descriptor sets, draw commands etc.) into a Primary command buffer (secondary command buffers cannot be used at this level)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuff</td><td>A Primary command buffer to record the commands into.</td></tr>
    <tr><td class="paramname">swapIdx</td><td>The current swap chain (framebuffer image) index to record commands for.</td></tr>
    <tr><td class="paramname">beginEnderRenderPasses</td><td>If set to False, the beginRenderPass and endRenderPass commands will not be recorded</td></tr>
    <tr><td class="paramname">recordUpdateUniforms</td><td>If set to false, skip the generation of any update uniforms commands. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0a486515f13c0fbaef1bfa9e4e09ff3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RendermanPass&amp; pvr::utils::RendermanEffect::toRendermanPass </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>toPass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Navigate to a RendermanPass object of this effect by the pass ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toPass</td><td>The Pass index (its order of appearance in the pass)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The RendermanPass object with id toPass. There is always at least one subpass per pass.</dd></dl>
<p>It is undefined behaviour to pass an index that does not exist.</p>

</div>
</div>
<a class="anchor" id="a1101d4eaac2f93754ae5d1948a6b93c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const RendermanPass&amp; pvr::utils::RendermanEffect::toRendermanPass </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>toPass</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Navigate to a RendermanPass object of this effect by the pass ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toPass</td><td>The Pass index (its order of appearance in the pass)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The RendermanPass object with id toPass. There is always at least one subpass per pass.</dd></dl>
<p>It is undefined behaviour to pass an index that does not exist.</p>

</div>
</div>
<a class="anchor" id="a01fd93e0dbf2420edf86856c1b7bbd31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::RendermanEffect::updateAutomaticSemantics </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>swapidx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterates all the nodes semantics per-effect, per-pass, per-subpass, per-model, per-node, and updates their values to their updated per-node values. CreateAutomaticSemantics must have been called otherwise no semantics will have been generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapidx</td><td>The current swap chain (framebuffer image) index to record commands for.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/Framework/PVREngineUtils/<a class="el" href="_render_manager_8h_source.html">RenderManager.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
